const Ld = {
  LOCAL: "local"
};
var nt = /* @__PURE__ */ ((t) => (t.IDLE = "idle", t.UPLOADING = "uploading", t.COMPLETED = "completed", t.FAILED = "failed", t))(nt || {}), Z;
(function(t) {
  t.ACCESS_DENIED = "http://ns.adobe.com/adobecloud/problem/accessdenied", t.ASSET_LOCKED = "http://ns.adobe.com/adobecloud/problem/assetlocked", t.ASSET_MOVED = "http://ns.adobe.com/adobecloud/problem/assetmoved", t.ASSET_NAME_CONFLICT = "http://ns.adobe.com/adobecloud/problem/assetnameconflict", t.ASSET_NAME_INVALID = "http://ns.adobe.com/adobecloud/problem/assetnamenotvalid", t.ASSET_NOT_FOUND = "http://ns.adobe.com/adobecloud/problem/assetnotfound", t.ASSET_STATE_NOT_ALLOWED = "http://ns.adobe.com/adobecloud/problem/assetstatenotallowed", t.BAD_REQUEST = "http://ns.adobe.com/adobecloud/problem/badrequest", t.BULK_REQUEST_NOT_ATTEMPTED = "http://ns.adobe.com/adobecloud/problem/bulkrequestnotattempted", t.COMPOSITE_INTEGRITY = "http://ns.adobe.com/adobecloud/problem/compositeintegrity", t.DCX_VALIDATION = "http://ns.adobe.com/adobecloud/problem/dcxvalidation", t.DIRECTORY_NOT_EMPTY = "http://ns.adobe.com/adobecloud/problem/directorynotempty", t.EMBED_INVALID = "http://ns.adobe.com/adobecloud/problem/embedinvalid", t.EMBED_TOO_LARGE = "http://ns.adobe.com/adobecloud/problem/embedtoolarge", t.ENCRYPTION_KEY_INACCESSIBLE = "http://ns.adobe.com/adobecloud/problem/encryptionkeyinaccessible", t.INVALID_FRAGMENT = "http://ns.adobe.com/adobecloud/problem/invalidfragment", t.LIMIT_CHILDREN_COUNT = "http://ns.adobe.com/adobecloud/problem/limit/childrencount", t.LIMIT_COMPONENT_COUNT = "http://ns.adobe.com/adobecloud/problem/limit/componentcount", t.LIMIT_EMBED_SELECTOR_COUNT = "http://ns.adobe.com/adobecloud/problem/limit/embedspecifierselectorcount", t.LIMIT_MILESTONE_COUNT = "http://ns.adobe.com/adobecloud/problem/limit/milestonecount", t.LIMIT_MILESTONE_LABEL_LENGTH = "http://ns.adobe.com/adobecloud/problem/limit/milestonelabellength", t.LIMIT_NAME_LENGTH = "http://ns.adobe.com/adobecloud/problem/limit/namelength", t.LIMIT_OPERATION_COUNT = "http://ns.adobe.com/adobecloud/problem/limit/operationcount", t.LIMIT_PATH_SEGMENT_COUNT = "http://ns.adobe.com/adobecloud/problem/limit/pathsegmentcount", t.LIMIT_RESOURCE_COUNT = "http://ns.adobe.com/adobecloud/problem/limit/resourcecount", t.LIMIT_RESOURCE_SIZE = "http://ns.adobe.com/adobecloud/problem/limit/resourcesize", t.NOT_ENTITLED = "http://ns.adobe.com/adobecloud/problem/notentitled", t.OPERATION_FAILED = "http://ns.adobe.com/adobecloud/problem/operationfailed", t.OPERATION_TARGET_CONFLICT = "http://ns.adobe.com/adobecloud/problem/operation/targetconflict", t.QUOTA_EXCEEDED = "http://ns.adobe.com/adobecloud/problem/quotaexceeded", t.REPOSITORY_NOT_FOUND = "http://ns.adobe.com/adobecloud/problem/repositorynotfound", t.RESOURCE_BLOCKED = "http://ns.adobe.com/adobecloud/problem/resourceblocked", t.RESOURCE_NOT_ALLOWED = "http://ns.adobe.com/adobecloud/problem/resourcenotallowed", t.RESOURCE_NOT_FOUND = "http://ns.adobe.com/adobecloud/problem/resourcenotfound", t.RESOURCE_NOT_READY = "http://ns.adobe.com/adobecloud/problem/resourcenotready", t.RESPONSE_TOO_LARGE = "http://ns.adobe.com/adobecloud/problem/responsetoolarge", t.USER_BLOCKED = "http://ns.adobe.com/adobecloud/problem/userblocked", t.VERSION_NOT_FOUND = "http://ns.adobe.com/adobecloud/problem/versionnotfound", t.PARTIAL_ASSET = "http://ns.adobe.com/adobecloud/problem/partialasset";
})(Z || (Z = {}));
const A = { ASSET_MOVED: "ASSET_MOVED", INVALID_JSON: "INVALID_JSON", READ_ONLY: "READ_ONLY", INVALID_PARAMS: "", INVALID_LINKS: "INVALID_LINKS", PRECONDITION_FAILED: "PRECONDITION_FAILED", INVALID_DATA: "INVALID_DATA", DUPLICATE_VALUE: "DUPLICATE_VALUE", NO_BASE_BRANCH_DATA: "NO_BASE_BRANCH_DATA", INVALID_STATE: "INVALID_STATE", DELETED_COMPOSITE: "DELETED_COMPOSITE", INCOMPLETE_COMPOSITE: "INCOMPLETE_COMPOSITE", UNEXPECTED_RESPONSE: "UNEXPECTED_RESPONSE", NETWORK_ERROR: "NETWORK_ERROR", COMPONENT_DOWNLOAD_ERROR: "COMPONENT_DOWNLOAD_ERROR", COMPONENT_UPLOAD_ERROR: "COMPONENT_UPLOAD_ERROR", COMPONENT_MODIFIED_ERROR: "COMPONENT_MODIFIED_ERROR", UPDATE_CONFLICT: "UPDATE_CONFLICT", NO_COMPOSITE: "NO_COMPOSITE", ALREADY_EXISTS: "ALREADY_EXISTS", SERVICE_IS_INACTIVE: "SERVICE_IS_INACTIVE", EXCEEDS_QUOTA: "EXCEEDS_QUOTA", NOT_IMPLEMENTED: "NOT_IMPLEMENTED", RETRYABLE_SERVER_ERROR: "RETRYABLE_SERVER_ERROR", TIMED_OUT: "TIMED_OUT", UNEXPECTED: "UNEXPECTED", TERMINATED_INPUTSTREAM: "TERMINATED_INPUTSTREAM", WRONG_ENDPOINT: "WRONG_ENDPOINT", OUT_OF_SPACE: "ENOSPC", FILE_EXISTS_IN_CLOUD: "FILE_EXISTS_IN_CLOUD", ASSET_NOT_FOUND: "ASSET_NOT_FOUND", COMPOSITE_NOT_FOUND: "COMPOSITE_NOT_FOUND", NOT_FOUND: "NOT_FOUND", UNAUTHORIZED: "UNAUTHORIZED", FORBIDDEN: "FORBIDDEN", METHOD_NOT_ALLOWED: "METHOD_NOT_ALLOWED", NOT_ACCEPTABLE: "NOT_ACCEPTABLE", BANDWIDTH_LIMIT_EXCEEDED: "BANDWIDTH_LIMIT_EXCEEDED", ABORTED: "ABORTED", TOO_MANY_REDIRECTS: "TOO_MANY_REDIRECTS", INSECURE_REDIRECT: "INSECURE_REDIRECT", RESOURCE_NOT_READY: "RESOURCE_NOT_READY", ASSET_LOCKED: "ASSET_LOCKED" }, Bo = { [A.SERVICE_IS_INACTIVE]: !0, [A.ABORTED]: !0, [A.INSECURE_REDIRECT]: !0, [A.TOO_MANY_REDIRECTS]: !0, [A.NOT_IMPLEMENTED]: !0, [A.EXCEEDS_QUOTA]: !0, [A.RETRYABLE_SERVER_ERROR]: !0, [A.TIMED_OUT]: !0, [A.TERMINATED_INPUTSTREAM]: !0, [A.WRONG_ENDPOINT]: !0, [A.OUT_OF_SPACE]: !0, [A.INVALID_PARAMS]: !0, [A.INVALID_STATE]: !0 };
let c = class Xe extends Error {
  constructor(e, s, r, n, o) {
    var i;
    if (super(), this.code = e, this.name = "AdobeDCXError", this._additionalData = {}, ((i = n == null ? void 0 : n.headers) === null || i === void 0 ? void 0 : i["content-type"]) === "application/problem+json" && n.response && typeof n.response == "object" && typeof n.response.slice == "function") try {
      const a = JSON.parse(new TextDecoder("utf-8").decode(n.response));
      n.response = a;
    } catch (a) {
      const d = n.response;
      n.response = { originalBody: d, message: "Failed to parse JSON problem type response body.", parseError: a };
    }
    if (r instanceof Error && (this._underlyingError = r), this._response = n || (dt(r) ? r.response : void 0), this._additionalData = o, this._message = s, this.message = (typeof e == "string" && e !== "" ? "[" + e + "] " : "") + (this._message || ""), Object.setPrototypeOf(this, Xe.prototype), Error.captureStackTrace) Error.captureStackTrace(this, Xe);
    else try {
      const a = new Error();
      if (a.name = this.name, a.stack) {
        const d = a.stack.split(`
`);
        d.length > 0 && d.splice(1, 1), this.stack = d.join(`
`);
      }
    } catch {
    }
  }
  get response() {
    return this._response;
  }
  get problemType() {
    var e;
    if (((e = this._response) === null || e === void 0 ? void 0 : e.headers["content-type"]) === "application/problem+json") return this._response.response.type;
  }
  get underlyingError() {
    return this._underlyingError;
  }
  get additionalData() {
    return this._additionalData;
  }
  set additionalData(e) {
    this._additionalData = e;
  }
  get failedComponents() {
    return this._additionalData.failedComponents;
  }
  static wrapError(e, s, r, n) {
    var o, i, a, d;
    if (r && Bo[r.code]) return r;
    if (n && typeof n == "object") {
      const h = n.statusCode, l = h === 403 && (((a = (i = (o = n.response) === null || o === void 0 ? void 0 : o.message) === null || i === void 0 ? void 0 : i.match(/code=(\d+.\d+)/)) === null || a === void 0 ? void 0 : a[1]) === "403.1" || ((d = n.response) === null || d === void 0 ? void 0 : d.type) === Z.QUOTA_EXCEEDED);
      if (h >= 500 && h < 600 || l) h === 501 ? (e = A.NOT_IMPLEMENTED, s = "Unimplemented request") : h === 507 || l ? (e = A.EXCEEDS_QUOTA, s = "Quota exceeded") : (e = A.RETRYABLE_SERVER_ERROR, s = "Server error");
      else if (r instanceof Xe && e === r.code && r.code === this.UNEXPECTED_RESPONSE) return r;
    }
    return new Xe(e, s, r, n);
  }
  toString() {
    return `${this.name}: ${this.message}`;
  }
  static networkError(e, s, r) {
    return Xe.wrapError(A.NETWORK_ERROR, e, s, r);
  }
  static unexpectedResponse(e, s, r) {
    return Xe.wrapError(A.UNEXPECTED_RESPONSE, e, s, r);
  }
};
function Gs(t, e, s) {
  return c.unexpectedResponse(t, e, s);
}
function dt(t) {
  return !(!t || typeof t != "object") && t.name === "AdobeDCXError";
}
function jo(t) {
  const e = Array.isArray(t.response) ? t.response.reduce(((n, o) => n || o.error), void 0) : t.response.error;
  if (!e) return t;
  const s = zt(t.statusCode, t);
  if (s instanceof c) throw s;
  const r = Vo(e, t);
  throw r || new c(e.type || c.UNEXPECTED_RESPONSE, e.title || "Unexpected Error", e, t);
}
c.ABORTED = A.ABORTED, c.INSECURE_REDIRECT = A.INSECURE_REDIRECT, c.TOO_MANY_REDIRECTS = A.TOO_MANY_REDIRECTS, c.INVALID_JSON = A.INVALID_JSON, c.READ_ONLY = A.READ_ONLY, c.INVALID_PARAMS = A.INVALID_PARAMS, c.INVALID_DATA = A.INVALID_DATA, c.DUPLICATE_VALUE = A.DUPLICATE_VALUE, c.NO_BASE_BRANCH_DATA = A.NO_BASE_BRANCH_DATA, c.INVALID_STATE = A.INVALID_STATE, c.DELETED_COMPOSITE = A.DELETED_COMPOSITE, c.INCOMPLETE_COMPOSITE = A.INCOMPLETE_COMPOSITE, c.UNEXPECTED_RESPONSE = A.UNEXPECTED_RESPONSE, c.NETWORK_ERROR = A.NETWORK_ERROR, c.COMPONENT_DOWNLOAD_ERROR = A.COMPONENT_DOWNLOAD_ERROR, c.COMPONENT_UPLOAD_ERROR = A.COMPONENT_UPLOAD_ERROR, c.COMPONENT_MODIFIED_ERROR = A.COMPONENT_MODIFIED_ERROR, c.UPDATE_CONFLICT = A.UPDATE_CONFLICT, c.NO_COMPOSITE = A.NO_COMPOSITE, c.ALREADY_EXISTS = A.ALREADY_EXISTS, c.SERVICE_IS_INACTIVE = A.SERVICE_IS_INACTIVE, c.EXCEEDS_QUOTA = A.EXCEEDS_QUOTA, c.NOT_IMPLEMENTED = A.NOT_IMPLEMENTED, c.RETRYABLE_SERVER_ERROR = A.RETRYABLE_SERVER_ERROR, c.TIMED_OUT = A.TIMED_OUT, c.UNEXPECTED = A.UNEXPECTED, c.TERMINATED_INPUTSTREAM = A.TERMINATED_INPUTSTREAM, c.WRONG_ENDPOINT = A.WRONG_ENDPOINT, c.OUT_OF_SPACE = A.OUT_OF_SPACE, c.FILE_EXISTS_IN_CLOUD = A.FILE_EXISTS_IN_CLOUD, c.ASSET_NOT_FOUND = A.ASSET_NOT_FOUND, c.COMPOSITE_NOT_FOUND = A.COMPOSITE_NOT_FOUND, c.NOT_FOUND = A.NOT_FOUND, c.UNAUTHORIZED = A.UNAUTHORIZED, c.FORBIDDEN = A.FORBIDDEN, c.PRECONDITION_FAILED = A.PRECONDITION_FAILED, c.RESOURCE_NOT_READY = A.RESOURCE_NOT_READY, c.ASSET_LOCKED = A.ASSET_LOCKED;
const qt = /* @__PURE__ */ new Map([[400, { code: A.UNEXPECTED_RESPONSE, message: "Bad request" }], [401, { code: A.UNAUTHORIZED, message: "Unauthorized" }], [403, { code: A.FORBIDDEN, message: "Forbidden" }], [404, { code: A.NOT_FOUND, message: "Not found" }], [405, { code: A.METHOD_NOT_ALLOWED, message: "The user is authorized to act on this resource, but cannot use the specified method." }], [406, { code: A.NOT_ACCEPTABLE, message: "Unable to obtain resource in a content type matching the Accept header or rendition type parameter." }], [409, { code: A.ALREADY_EXISTS, message: "Already exists" }], [412, { code: A.PRECONDITION_FAILED, message: "Precondition failed" }], [501, { code: A.NOT_IMPLEMENTED, message: "Not implemented" }], [507, { code: A.EXCEEDS_QUOTA, message: "Exceeds quota" }], [509, { code: A.BANDWIDTH_LIMIT_EXCEEDED, message: "Bandwidth limit exceeded" }]]), cn = new Map(Object.entries({ [Z.ASSET_MOVED]: { code: A.ASSET_MOVED, message: "Asset moved to a different region while operation was in progress" }, [Z.COMPOSITE_INTEGRITY]: { code: A.INCOMPLETE_COMPOSITE, message: "Incomplete composite. invoke missingComponentsFromError with this error for more information." }, [Z.PARTIAL_ASSET]: { code: A.NO_COMPOSITE, message: "Asset is partially created. No Manifest found" }, [Z.LIMIT_RESOURCE_COUNT]: { code: A.UNEXPECTED_RESPONSE, message: "Resource count limit exceed" }, [Z.QUOTA_EXCEEDED]: { code: A.EXCEEDS_QUOTA, message: "Quota exceeded" }, [Z.ASSET_LOCKED]: { code: A.ASSET_LOCKED, message: "Asset is locked and cannot be modified" } })), Vo = (t, e) => {
  var s;
  const r = cn.get((s = t.type) !== null && s !== void 0 ? s : "") || (typeof t.status == "number" ? qt.get(t.status) : void 0);
  return r ? new c(r.code, r.message, t, e) : void 0;
}, it = (t) => {
  var e, s;
  const r = cn.get((s = (e = t.response) === null || e === void 0 ? void 0 : e.type) !== null && s !== void 0 ? s : "") || qt.get(t.statusCode);
  return r ? new c(r.code, r.message, void 0, t, t.response) : void 0;
}, zt = (t, e) => t && e ? t < 300 && t > 199 || it(e) || !1 : new c(A.NETWORK_ERROR, "Invalid or missing status code or response", void 0, e);
let Ut;
const Fo = new Uint8Array(16);
function Ho() {
  if (!Ut && (Ut = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !Ut)) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return Ut(Fo);
}
var Go = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
const ie = [];
for (let t = 0; t < 256; ++t) ie.push((t + 256).toString(16).slice(1));
var Pr = { randomUUID: typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto) };
function $o(t, e, s) {
  if (Pr.randomUUID && !e && !t) return Pr.randomUUID();
  const r = (t = t || {}).random || (t.rng || Ho)();
  return r[6] = 15 & r[6] | 64, r[8] = 63 & r[8] | 128, (function(n, o = 0) {
    return ie[n[o + 0]] + ie[n[o + 1]] + ie[n[o + 2]] + ie[n[o + 3]] + "-" + ie[n[o + 4]] + ie[n[o + 5]] + "-" + ie[n[o + 6]] + ie[n[o + 7]] + "-" + ie[n[o + 8]] + ie[n[o + 9]] + "-" + ie[n[o + 10]] + ie[n[o + 11]] + ie[n[o + 12]] + ie[n[o + 13]] + ie[n[o + 14]] + ie[n[o + 15]];
  })(r);
}
const Yo = (t) => C(t) && (Y(t.pipe) || Y(t.pipeTo)), C = (t) => t != null && typeof t == "object", Y = (t) => typeof t == "function", fe = (t) => Array.isArray(t), qo = (t) => C(t) && Y(t.constructor) && t.constructor.name === "ArrayBuffer" && Y(t.slice), Cr = (t) => {
  if (typeof t != "string") return !1;
  const e = t.toLowerCase().split("application/");
  if (e.length < 2) return !1;
  const s = e[1].split(";")[0].trim();
  return s === "json" || s.endsWith("+json");
}, Wt = () => {
  try {
    return Object.prototype.toString.call(globalThis.process) === "[object process]";
  } catch {
    return !1;
  }
}, zo = () => typeof self == "object" && self.self === self, Kt = () => $o(), Xt = (t) => {
  return typeof (e = t) == "string" && Go.test(e);
  var e;
}, de = (...t) => !t || !Array.isArray(t) || t.length < 1 ? {} : t.reduce(((e, s) => {
  const r = C(e) ? e : {};
  if (C(s)) for (const n in s) Object.prototype.hasOwnProperty.call(s, n) && (r[n] = s[n]);
  return r;
})), xe = (t, ...e) => {
  if (!e.length) return t;
  const s = e.shift();
  if (C(t) && C(s)) for (const r in s) C(s[r]) && !fe(s[r]) ? (t[r] || Object.assign(t, { [r]: {} }), xe(t[r], s[r])) : fe(t[r]) && fe(s[r]) ? Object.assign(t, { [r]: s[r] }) : Object.assign(t, { [r]: s[r] });
  return xe(t, ...e);
}, dn = (...t) => {
  if (!t || !Array.isArray(t)) return "";
  const e = [], s = t.length;
  for (let r = 0; r < s; r++) {
    let n = t[r];
    typeof n == "string" && n !== "" && (r === 0 && n.length !== 1 || n.charAt(0) === "/" && (n = n.slice(1)), r !== s - 1 && n.charAt(n.length - 1) === "/" && (n = n.slice(0, n.length - 1)), e.push(n));
  }
  return e.join("/");
}, Wo = new RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?"), Ko = (t) => {
  const e = t.match(Wo) || [];
  return { scheme: e[2], authority: e[4], path: e[5], query: e[7], fragment: e[9] };
}, Ds = (t) => {
  const e = Ko(t), s = e.scheme, r = e.authority, n = s === "https" ? 443 : s === "http" ? 80 : -1;
  let o;
  return s && r && (o = (s + "://" + r).toLowerCase(), n >= 0 && r.indexOf(":") < 0 && (o = o + ":" + n)), o;
}, Xo = (t) => {
  if (!t || typeof t != "string") return t;
  const e = (t = (t = (t = (t = t.indexOf("//") > -1 ? t.split("/")[2] : t.split("/")[0]).split("?")[0]).split("/")[0]).split(":")[0]).split(".");
  return t = e.slice(Math.max(e.length - 2, 0)).join(".");
}, Ot = 48, Zo = 49, Zt = 57, ks = 97, Ls = 65, hn = 102, ln = 70, Sr = (t) => {
  const e = t.charCodeAt(0);
  return e >= Ot && e <= Zt || e >= ks && e <= hn || e >= Ls && e <= ln;
}, Ht = (t) => t.length >= 3 && t.charAt(0) === "%" && Sr(t.charAt(1)) && Sr(t.charAt(2)), xt = (t) => {
  const e = t.charCodeAt(0);
  return e >= Ot && e <= Zt ? e - Ot : e >= ks && e <= hn ? 10 + e - ks : e >= Ls && e <= ln ? 10 + e - Ls : 0;
}, $s = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_.~", Nr = "0123456789ABCDEF", Ys = (t) => {
  const e = [];
  for (let s = 0; s < 128; ++s) e.push(t.indexOf(String.fromCharCode(s)) !== -1);
  return e;
}, un = Ys($s + ":/?#[]@!$&'()*+,;="), Jo = Ys($s);
Ys($s + "/");
const Qo = (t, e) => {
  if (t < 128 && e[t]) return String.fromCharCode(t);
  let s = "%";
  return s += Nr.charAt(t >> 4 & 15), s += Nr.charAt(15 & t), s;
}, ei = (t) => {
  const e = [];
  for (let s = 0; s < t.length; s++) {
    let r = t.charCodeAt(s);
    r < 128 ? e.push(r) : r < 2048 ? e.push(192 | r >> 6, 128 | 63 & r) : r < 55296 || r >= 57344 ? e.push(224 | r >> 12, 128 | r >> 6 & 63, 128 | 63 & r) : ++s < t.length && (r = 65536 + ((1023 & r) << 10 | 1023 & t.charCodeAt(s)), e.push(240 | r >> 18, 128 | r >> 12 & 63, 128 | r >> 6 & 63, 128 | 63 & r));
  }
  return e;
}, qs = (t, e) => {
  const s = ei(t);
  let r = "";
  for (let n = 0; n < s.length; n++) r += Qo(s[n], e);
  return r;
}, Et = (t) => (t = t.normalize("NFC"), qs(t, Jo)), gs = (t) => {
  t = t.normalize("NFC");
  let e = 0, s = "";
  for (; e < t.length; ) Ht(t.substr(e)) ? (s += t.substr(e, 3), e += 3) : s += qs(t.charAt(e++), un);
  return s;
}, Fe = (t, e) => {
  let s = 0, r = "", n = !1, o = !1, i = !1, a = !0, d = !0, h = !1, l = "", p = "", _ = ",", f = -1;
  const m = (I) => {
    if (r += a ? p : h || d ? _ : ",", o && l && (a || h || d) && (r += Et(l), (!i || I.length > 0) && (r += "=")), I) {
      let R;
      R = n ? gs(I) : Et(I), f > 0 && (R = ((D, O) => {
        let N = 0;
        for (; N < D.length && O > 0; ) {
          if (Ht(D.substr(N))) {
            let M = (xt(D.substr(N + 1)) << 4) + xt(D.substr(N + 2));
            if (N += 3, !(192 & ~M)) for (; N < D.length && Ht(D.substr(N)) && (M = (xt(D.substr(N + 1)) << 4) + xt(D.substr(N + 2)), N += 3, (192 & M) == 128); ) ;
          } else ++N;
          --O;
        }
        return D.substr(0, N);
      })(R, f)), r += R;
    }
    a = !1, d = !1;
  };
  for (; s < t.length; ) if (t.charAt(s) === "{") {
    if (++s < t.length) {
      switch (n = !1, o = !1, p = "", _ = ",", i = !1, t.charAt(s++)) {
        case "+":
          n = !0;
          break;
        case "#":
          p = "#", n = !0;
          break;
        case ".":
          p = ".", _ = ".";
          break;
        case "/":
          p = "/", _ = "/";
          break;
        case ";":
          p = ";", _ = ";", o = i = !0;
          break;
        case "?":
          p = "?", _ = "&", o = !0;
          break;
        case "&":
          p = "&", _ = "&", o = !0;
          break;
        default:
          --s;
      }
      for (l = "", a = !0, d = !0; s < t.length; ) if (t.charAt(s) === "}" || t.charAt(s) === "," || t.charAt(s) === "*" || t.charAt(s) === ":") {
        if (h = !1, f = -1, t.charAt(s) === "*") {
          if (h = !0, ++s >= t.length) break;
        } else if (t.charAt(s) === ":") {
          if (++s >= t.length) break;
          for (t.charCodeAt(s) >= Zo && t.charCodeAt(s) <= Zt && (f = 0); s < t.length && t.charCodeAt(s) >= Ot && t.charCodeAt(s) <= Zt && f < 1e4; ) f = 10 * f + (t.charCodeAt(s++) - Ot);
          if (s >= t.length) break;
        }
        for (; s < t.length && t.charAt(s) !== "}" && t.charAt(s) !== ","; ) ++s;
        if (l.length > 0 && l.charAt(l.length - 1) === "*" && (h = !0, l = l.substr(0, l.length - 1)), l.length > 0) {
          const I = e ? e[l] : void 0;
          if (I || I === "") if (Array.isArray(I)) {
            f = -1;
            for (let R = 0; R < I.length; R++) m(String(I[R]));
          } else if (typeof I == "object" && I !== null) for (const R in I) Object.prototype.hasOwnProperty.call(I, R) && (y = R, P = String(I[R]), r += a ? p : h || d ? _ : ",", o && l && a && !h && (r += Et(l), (!i || P.length > 0) && (r += "=")), y && (r += n ? gs(y) : Et(y), r += h ? "=" : ",", P && (r += n ? gs(P) : Et(P))), a = !1, d = !1);
          else m(String(I));
        }
        if (t.charAt(s++) === "}") break;
        l = "", d = !0;
      } else l += t.charAt(s++);
    }
  } else Ht(t.substr(s)) ? (r += t.substr(s, 3), s += 3) : r += qs(t.charAt(s++), un);
  var y, P;
  return r;
}, Dr = (t, e) => {
  if (!t || typeof t != "string" || !e) return "";
  let s;
  return s = typeof e == "string" ? t.match(e) : e.exec(t), s ? s[1] : "";
};
function ws(t, e, s, r) {
  return new (s || (s = Promise))((function(n, o) {
    function i(h) {
      try {
        d(r.next(h));
      } catch (l) {
        o(l);
      }
    }
    function a(h) {
      try {
        d(r.throw(h));
      } catch (l) {
        o(l);
      }
    }
    function d(h) {
      var l;
      h.done ? n(h.value) : (l = h.value, l instanceof s ? l : new s((function(p) {
        p(l);
      }))).then(i, a);
    }
    d((r = r.apply(t, [])).next());
  }));
}
function ve(t, e) {
  return t ? new TextDecoder().decode(t) : "";
}
function Te(t) {
  return new TextEncoder().encode(t);
}
function Ue(t, e) {
  const s = new Uint8Array(t.length + e.length);
  return s.set(t, 0), s.set(e, t.length), s;
}
function ti(t) {
  const e = {};
  for (const [s, r] of t) e[s] = r;
  return e;
}
function si(t, e) {
  return t.reduce(((s, r, n) => (n % e == 0 ? s.unshift([r]) : s[0].push(r), s)), []).reverse();
}
let zs = class {
  constructor(e) {
    this._handlers = {}, e.forEach(((s) => {
      this._handlers[s] = [];
    }));
  }
  on(e, s) {
    return this._handlers[e].push(s) - 1;
  }
  emit(e, s) {
    this._handlers[e].forEach(((r) => {
      Y(r) && r(...s);
    }));
  }
  removeHandler(e, s) {
    delete this._handlers[e][s];
  }
  removeAllHandlers(e) {
    e ? this._handlers[e] = [] : this._handlers = {};
  }
};
const pn = [/^(?!^501$|^507$)^(5\d{2})$|429|423$/], kr = (t, e) => {
  return typeof (s = t) == "object" && typeof s.test == "function" ? t.test(e.toString()) : e === t;
  var s;
};
function ot(t, e = pn) {
  return !!t && (Array.isArray(e) ? e.some(((s) => kr(s, t))) : kr(e, t));
}
const ri = /^([^:]+):(.*)$/, Lr = /^\s+|\s+$/g, Ws = (t) => {
  const e = {}, s = t.split(/\r?\n/);
  let r, n;
  for (let o = 0; o < s.length; ++o) {
    const i = s[o];
    if (i.length > 0) {
      const a = i.charCodeAt(0);
      if (!r || a !== 9 && a !== 32) {
        const d = ri.exec(i);
        d && d.length > 1 && (r = d[1].toLowerCase(), n = d[2] || "", n = n.replace(Lr, ""), e[r] ? e[r] = e[r] + "," + n : e[r] = n);
      } else e[r] = e[r] + " " + i.replace(Lr, "");
    }
  }
  return e;
}, Pt = (t) => {
  if (t === null || typeof t != "object") return {};
  const e = {};
  for (const [s, r] of Object.entries(t)) e[s.toLowerCase()] = fe(r) ? r.join(";") : r;
  return e;
}, Ce = (t, e, s) => fe(e) ? new c(c.INVALID_PARAMS, `Param '${t}' type must be one of: [${e.join(",")}].${s && s.length > 0 ? " Possible values: " + s.join(", ") + "." : ""}`) : new c(c.INVALID_PARAMS, `Param '${t}' must be of type '${e}'.${s && s.length > 0 ? " Possible values: " + s.join(", ") + "." : ""}`), qe = (t, e, s, r = !1, n = []) => {
  if (r && e == null) return !0;
  if (fe(s)) {
    for (const i in s) {
      const a = s[i];
      try {
        return qe(t, e, a, r, n), !0;
      } catch {
      }
    }
    throw Ce(t, s, n);
  }
  if (s === "null" && e !== null || s === "undefined" && e !== void 0 || s === "nullish" && e != null) throw Ce(t, s, n);
  if (s === "null" || s === "undefined" || s === "nullish") return !0;
  if (!r && e == null) throw Ce(t, s, n);
  if (s.endsWith("[]")) {
    if (!fe(e)) throw Ce(t, s, n);
    return e.forEach(((i, a) => {
      qe(`${t}[${a}]`, i, s.substr(0, s.length - 2));
    })), !0;
  }
  let o = s.toLowerCase();
  switch (s) {
    case "integer":
    case "+number":
    case "-number":
      o = "number";
  }
  if (o === "array") {
    if (!fe(e)) throw Ce(t, s, n);
  } else if (o !== "enum" && (typeof e !== o || s === "integer" && (typeof e != "number" || !Number.isInteger(e)) || s === "+number" && (typeof e != "number" || e < 0) || s === "-number" && (typeof e != "number" || e > 0)))
    throw Ce(t, s, n);
  if (n.length > 0) {
    const i = n.length;
    let a = !1;
    for (let d = 0; d < i; d++) if (n[d] === e) {
      a = !0;
      break;
    }
    if (!a) throw Ce(t, s, n);
  }
  return !0;
};
function E(...t) {
  return t.map(((e) => qe(...e)));
}
function _n(t, e, ...s) {
  if (e = e ? " " + e + " " : " ", !t || typeof t != "object") throw new c(c.INVALID_PARAMS, `Object${e}is invalid.`);
  try {
    s.forEach(((r) => {
      qe(r[0], t[r[0]], r[1], r[2] || !1, r[3] || []);
    }));
  } catch (r) {
    throw new c(c.INVALID_PARAMS, `Object${e}is invalid. ${r.message.replace("Param", "Property")}`, r);
  }
}
const fn = (t, e) => {
  if (t() === !1) throw new c(c.INVALID_PARAMS, e);
};
function ni(t, e = {}, s) {
  const r = typeof e.selector == "function" ? e.selector : oi, n = Array.isArray(t) ? r(t, s) : t;
  if (!n) throw new c(c.INVALID_PARAMS, "Could not select appropriate link for usage");
  return n.templated ? typeof e.expander == "function" ? e.expander(n.href, s) : Fe(n.href, s) : n.href;
}
function oi(t, e = { mode: "id" }) {
  let s = t[0], r = 0;
  for (const n of t) {
    let o = 0;
    for (const i in n) i in e && n[i] === e[i] && o++;
    o > r && (r = o, s = n);
  }
  return s;
}
function L(t) {
  if (!C(t)) throw new Error("Expecting object");
  const e = {};
  for (const s in t) t[s] != null && (e[s] = t[s]);
  return e;
}
const ii = /^utf-?8|ascii|utf-?16-?le|ucs-?2|base-?64|latin-?1$/i, ai = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ci = /\s|\uFEFF|\xA0/, di = /\r?\n[\x20\x09]+/g, hi = /[;,"]/, li = /[;,"]|\s/, Bt = 1, wr = 2, Is = 4;
function Mr(t) {
  return t.replace(ai, "");
}
function Gt(t) {
  return ci.test(t);
}
function ui(t, e) {
  for (; Gt(t[e]); ) e++;
  return e;
}
function Ur(t) {
  return li.test(t);
}
class pi {
  constructor(e) {
    this.refs = [], e && this.parse(e);
  }
  rel(e) {
    const s = [];
    for (let r = 0; r < this.refs.length; r++) this.refs[r].rel === e && s.push(this.refs[r]);
    return s;
  }
  get(e, s) {
    e = e.toLowerCase();
    const r = [];
    for (let n = 0; n < this.refs.length; n++) this.refs[n][e] === s && r.push(this.refs[n]);
    return r;
  }
  set(e) {
    return this.refs.push(e), this;
  }
  has(e, s) {
    e = e.toLowerCase();
    for (let r = 0; r < this.refs.length; r++) if (this.refs[r][e] === s) return !0;
    return !1;
  }
  parse(e, s = 0) {
    let r = s ? e.slice(s) : e;
    r = Mr(r).replace(di, "");
    let n = Bt;
    const o = r.length;
    let i = 0, a = null;
    for (; i < o; ) if (n === Bt) {
      if (Gt(r[i])) {
        i++;
        continue;
      }
      if (r[i] !== "<") throw new Error('Unexpected character "' + r[i] + '" at offset ' + i);
      {
        const d = r.indexOf(">", i);
        if (d === -1) throw new Error("Expected end of URI delimiter at offset " + i);
        a = { uri: r.slice(i + 1, d) }, this.refs.push(a), i = d, n = wr;
      }
      i++;
    } else if (n === wr) {
      if (Gt(r[i])) {
        i++;
        continue;
      }
      if (r[i] === ";") n = Is, i++;
      else {
        if (r[i] !== ",") throw new Error('Unexpected character "' + r[i] + '" at offset ' + i);
        n = Bt, i++;
      }
    } else {
      if (n !== Is) throw new Error('Unknown parser state "' + n + '"');
      {
        if (r[i] === ";" || Gt(r[i])) {
          i++;
          continue;
        }
        const d = r.indexOf("=", i);
        if (d === -1) throw new Error("Expected attribute delimiter at offset " + i);
        const h = Mr(r.slice(i, d)).toLowerCase();
        let l = "";
        if (i = d + 1, i = ui(r, i), r[i] === '"') for (i++; i < o; ) {
          if (r[i] === '"') {
            i++;
            break;
          }
          r[i] === "\\" && i++, l += r[i], i++;
        }
        else {
          let p = i + 1;
          for (; !hi.test(r[p]) && p < o; ) p++;
          l = r.slice(i, p), i = p;
        }
        if (!(a && a[h] && _i(h))) if (a && h[h.length - 1] === "*") a[h] = fi(l);
        else if (l = h === "rel" || h === "type" ? l.toLowerCase() : l, a && a[h] != null) {
          const p = a[h];
          fe(p) ? p.push(l) : a[h] = [a[h], l];
        } else {
          if (!a) throw new Error("Unexpected null ref");
          a[h] = l;
        }
        switch (r[i]) {
          case ",":
            n = Bt;
            break;
          case ";":
            n = Is;
        }
        i++;
      }
    }
    return a = null, this;
  }
  toString() {
    const e = [];
    let s, r = "";
    for (let n = 0; n < this.refs.length; n++) s = this.refs[n], r = Object.keys(this.refs[n]).reduce((function(o, i) {
      return i === "uri" ? o : o + "; " + En(i, s[i]);
    }), "<" + s.uri + ">"), e.push(r);
    return e.join(", ");
  }
}
const Ms = (t) => ii.test(t), _i = (t) => t === "rel" || t === "type" || t === "media" || t === "title" || t === "title*", xr = (t) => t.replace(/"/g, '\\"'), fi = (t) => {
  const e = /([^']+)?(?:'([^']+)')?(.+)/.exec(t) || [];
  return { language: e[2].toLowerCase(), encoding: Ms(e[1]) ? null : e[1].toLowerCase(), value: Ms(e[1]) ? decodeURIComponent(e[3]) : e[3] };
}, En = (t, e) => Array.isArray(e) ? e.map(((s) => En(t, s))).join("; ") : t[t.length - 1] === "*" || typeof e != "string" ? ((s, r) => {
  const n = (r.encoding || "utf-8").toUpperCase(), o = r.language || "en";
  let i = "";
  return i = Buffer.isBuffer(r.value) && Ms(n) ? r.value.toString(n) : Buffer.isBuffer(r.value) ? r.value.toString("hex").replace(/[0-9a-f]{2}/gi, "%$1") : encodeURIComponent(r.value), s + "=" + n + "'" + o + "'" + i;
})(t, e) : (/* @__PURE__ */ ((s) => s === "rel" || s === "type" || s === "anchor")(t) ? e = Ur(e) ? '"' + xr(e) + '"' : xr(e) : Ur(e) && (e = '"' + (e = (e = encodeURIComponent(e)).replace(/%20/g, " ").replace(/%2C/g, ",").replace(/%3B/g, ";")) + '"'), t + "=" + e);
function ts(t, e, s, r = "id") {
  const n = Ks(t)[e];
  if (n) {
    if (Array.isArray(n)) {
      const o = n.filter(((i) => i.mode === r));
      return o.length > 0 ? o[0][s] : n.length > 0 ? n[0][s] : void 0;
    }
    return n[s];
  }
}
function H(t, e, s = "id") {
  const r = Ks(t), n = r[e];
  let o;
  if (C(n) && typeof n.href == "string" ? o = n.href : Array.isArray(n) && (o = ts(r, e, "href", s)), typeof o != "string") throw new c(c.INVALID_PARAMS, "Missing or invalid link href.");
  return o;
}
function J(t, e, s, r = "id") {
  const n = H(Ks(t), e, r);
  return Fe(n, L(s));
}
const Ei = (t, e = 0) => new pi().parse(t, e);
function Ks(t) {
  return C(t) ? "_links" in t ? t._links : "links" in t ? t.links : t : {};
}
let jt;
const gi = () => {
  if (jt) return jt;
  const t = Wt();
  return jt = t && C(globalThis.performance) && Y(globalThis.performance.now) ? globalThis.performance : t && C(globalThis.perf_hooks) && C(globalThis.perf_hooks.performance) && Y(globalThis.perf_hooks.performance.now) ? globalThis.perf_hooks.performance : zo() && C(self.performance) && Y(self.performance.now) ? self.performance : Date, jt;
}, ae = () => gi().now(), Ii = (t) => ws(void 0, void 0, void 0, (function* () {
  return new Promise(((e) => setTimeout(e, t)));
}));
function gn(t, e, s, r, n) {
  return ws(this, void 0, void 0, (function* () {
    return t().catch(((o) => ws(this, void 0, void 0, (function* () {
      var i, a, d;
      if (ae() - s.startTime >= s.timeoutAfter) throw new c(c.TIMED_OUT, "request aborted due to timeout");
      r || (r = (i = o.response) === null || i === void 0 ? void 0 : i.response.type);
      const h = 1e3 * parseInt((a = o.response) === null || a === void 0 ? void 0 : a.headers["retry-after"], 10) || 2e3;
      if (((d = o.response) === null || d === void 0 ? void 0 : d.statusCode) === e && o.response.response.type === r) return yield Ii(h), gn(t, e, s, r);
      throw o;
    }))));
  }));
}
var Br, jr, Vr, Ne, z;
(function(t) {
  t[t.Success = 0] = "Success", t[t.Error = 1] = "Error";
})(Br || (Br = {})), (function(t) {
  t[t.CompositeXfer = 0] = "CompositeXfer";
})(jr || (jr = {})), (function(t) {
  t[t.Push = 0] = "Push", t[t.MinPull = 1] = "MinPull", t[t.VersionPull = 2] = "VersionPull", t[t.Upload = 3] = "Upload", t[t.Download = 4] = "Download", t[t.Create = 5] = "Create", t[t.Unknown = 6] = "Unknown";
})(Vr || (Vr = {})), (function(t) {
  t.PushComposite = "analyticsPush", t.CreateComposite = "analyticsCreate", t.PullComposite = "analyticsPull", t.PullCompositeVersion = "analyticsPullVersion", t.UploadComponent = "analyticsUpload", t.DownloadComponent = "analyticsDownload", t.All = "*";
})(Ne || (Ne = {})), (function(t) {
  t[t.Deprecated = 0] = "Deprecated", t[t.Error = 1] = "Error", t[t.Warn = 2] = "Warn", t[t.Log = 3] = "Log", t[t.Debug = 4] = "Debug";
})(z || (z = {}));
const Ti = { [z.Deprecated]: "error", [z.Error]: "error", [z.Log]: "log", [z.Warn]: "warn", [z.Debug]: "debug" };
class ue extends zs {
  constructor(e) {
    super([Ne.CreateComposite, Ne.UploadComponent, Ne.PushComposite, Ne.PullComposite, Ne.PullCompositeVersion, Ne.DownloadComponent]), this._logLevel = z.Warn, this._prevDebugTime = ae(), this._debugFormatter = (s, r, n, o) => `[${s} (+${(1e3 * (r - n)).toFixed(0)})] ${o.map(((i) => typeof i == "string" ? i : JSON.stringify(i))).join(" ")}`, this._debugNamespaces = [], this._debugSkips = [], this.suppressDeprecationWarnings = !1, e && (this._logCallback = e), this._initNamespaces();
  }
  get debugNamespaces() {
    return this._debugNamespaces;
  }
  get debugSkips() {
    return this._debugSkips;
  }
  set logLevel(e) {
    if (!Object.values(z).includes(e)) throw new Error(`Invalid LogLevel, must be one of: ${Object.values(z).join(", ")}.`);
    this._logLevel = e;
  }
  get logLevel() {
    return this._logLevel;
  }
  on(e, s) {
    if (e !== Ne.All) return super.on(e, s);
    const r = Object.values(Ne);
    let n;
    for (let o = 0, i = r.length; o < i; o++) {
      const a = r[o];
      n = super.on(a, s);
    }
    return n;
  }
  static getInstance() {
    return ue._instance == null && (ue._instance = new ue()), ue._instance;
  }
  static newLogger(e) {
    return new ue(e);
  }
  set logCallback(e) {
    this._logCallback = e;
  }
  get logCallback() {
    return this._logCallback;
  }
  _initNamespaces() {
    Wt() ? this.setDebugNamespaces(process.env.DCX_DEBUG || "") : C(globalThis) && C(globalThis.dcxjs) && this.setDebugNamespaces(globalThis.dcxjs.debug || ""), this._debugNamespaces.length > 0 && (this._logLevel = z.Debug);
  }
  _log(e, s, r) {
    try {
      if (e === ue.LEVEL_DEPRECATED) !this.suppressDeprecationWarnings && this._logLevel >= e && console.warn(...r);
      else if (typeof this._logCallback == "function" && this._logLevel >= e) this._logCallback.call(void 0, ...r);
      else if (this._logLevel >= e) if (e === z.Debug) {
        if (this._debugEnabled(s)) {
          const n = this._prevDebugTime;
          this._prevDebugTime = ae(), (console.debug || console.log)(this._debugFormatter(s, this._prevDebugTime, n, r));
        }
      } else console[Ti[e]](...r.slice(0, -2));
    } catch {
    }
  }
  log(...e) {
    this._log(z.Log, void 0, e);
  }
  warn(...e) {
    this._log(z.Warn, void 0, e);
  }
  error(...e) {
    this._log(z.Error, void 0, e);
  }
  deprecated(...e) {
    this._log(z.Deprecated, void 0, e);
  }
  _debugEnabled(e) {
    if (e[e.length - 1] === "*") return !0;
    let s, r;
    for (s = 0, r = this._debugSkips.length; s < r; s++) if (this._debugSkips[s].test(e)) return !1;
    for (s = 0, r = this._debugNamespaces.length; s < r; s++) if (this._debugNamespaces[s].test(e)) return !0;
    return !1;
  }
  setDebugFormatter(e) {
    this._debugFormatter = e;
  }
  setDebugNamespaces(e) {
    let s;
    this._debugNamespaces = [], this._debugSkips = [];
    const r = (typeof e == "string" ? e : "").split(/[\s,]+/), n = r.length;
    for (s = 0; s < n; s++) r[s] && ((e = r[s].replace(/\*/g, ".*?"))[0] === "-" ? this._debugSkips.push(new RegExp("^" + e.substr(1) + "$")) : this._debugNamespaces.push(new RegExp("^" + e + "$")));
  }
  Debug(e) {
    return (...s) => {
      this._log(z.Debug, e, s);
    };
  }
}
ue.LEVEL_DEBUG = z.Debug, ue.LEVEL_LOG = z.Log, ue.LEVEL_WARN = z.Warn, ue.LEVEL_ERROR = z.Error, ue.LEVEL_DEPRECATED = z.Deprecated;
const Xs = () => {
  const t = In();
  return t._logCallback !== void 0 ? t : ue.getInstance();
}, In = () => {
  if (typeof globalThis == "object" && typeof globalThis.dcxjs == "object" && globalThis.dcxjs.logger && globalThis.dcxjs.logger.getInstance) return globalThis.dcxjs.logger.getInstance();
  const t = () => {
  };
  return { log: t, warn: t, error: t, deprecated: t, debug: t, newLogger: In };
}, Fr = (...t) => {
  const e = Xs();
  t.forEach(e.log.bind(e));
}, B = (t) => Xs().Debug(t);
Xs();
const Hr = (t) => toString.call(t) === "[object Function]";
let Ai = class {
  constructor(e, s) {
    return this._promise = null, this._props = {}, this._registeredProps = [], this._handlers = { cancel: [] }, this._done = !1, this._canceled = !1, this._internalKeys = [], this.name = "AdobePromise", this._internalKeys = [...Object.keys(this), ...Object.keys(Object.getOwnPropertyDescriptors(Object.getPrototypeOf(this))), "_cancelReason"], s && typeof s == "object" && this._setProps(s), this._promise = new Promise(((r, n) => e.call(this, ((o) => {
      this._done || (this._done = !0, r(o));
    }), ((o) => {
      this._done || (this._done = !0, n(o));
    }), this._registerCancelHandler.bind(this)))), new Proxy(this, { set: function(r, n, o) {
      if (r._internalKeys.includes(n)) {
        if (!["_promise", "_canceled", "_cancelReason", "_props", "_registeredProps"].includes(n)) throw new Error("Cannot overwrite internal AdobePromise property.");
        r[n] = o;
      } else r._registeredProps.includes(n) || r._registeredProps.push(n), r.props[n] = o;
      return !0;
    }, get: function(r, n) {
      return typeof n == "symbol" || r._internalKeys.includes(n) ? r[n] : r.props[n];
    } });
  }
  get [Symbol.toStringTag]() {
    return this.name;
  }
  static reject(e, s) {
    return new S(((r, n) => Promise.reject(e).catch(((o) => {
      n && n(o);
    }))), s);
  }
  static resolve(e, s) {
    return new S(((r) => {
      C(e) && Hr(e.then) ? e.then(((n) => {
        r(n);
      })) : r(e);
    }), s);
  }
  static allSettled(e, s) {
    return e.length === 0 ? S.resolve([], s) : new S(((r) => {
      const n = [];
      e.map(((o, i) => {
        o.then(((a) => {
          n[i] = { status: "fulfilled", value: a };
        })).catch(((a) => {
          n[i] = { status: "rejected", reason: a };
        })).then((() => {
          n.filter(((a) => !!a)).length === e.length && r(n);
        }));
      }));
    }), s);
  }
  get canceled() {
    return this._canceled;
  }
  getPromise() {
    return this._promise;
  }
  _resolveOrReject(e, s) {
    return this._promise.then(((r) => this._canceled ? s && s(this._cancelReason) : e(r))).catch(((r) => s && s(this._cancelReason || r)));
  }
  then(e, s) {
    if (e == null && s == null) return this;
    const r = new S(((n, o, i) => (i && i(((a) => {
      this.cancel.call(this, a), o && o(a);
    })), this._resolveOrReject.call(this, n, o))), this._props);
    return r._promise = r.getPromise().then(((n) => {
      const o = e && e(n);
      if (o instanceof S) {
        const i = o;
        this.onCancel(((a) => i.cancel(a)));
        for (const a in this.props) i.props[a] == null && (i.props[a] = this.props[a]);
        i._setProps(i.props), this._setProps(i.props), r._setProps(i.props);
      }
      return o;
    })).catch(s), r;
  }
  parallel(e, s) {
    return this._promise.then(e, s);
  }
  catch(e) {
    return this._promise = this._promise.catch(e), this;
  }
  finally(e) {
    return this._promise = this._promise.finally(e), this;
  }
  cancel(e) {
    this._canceled || (this._canceled = !0, this._cancelReason = e, this._callHandlers("cancel", e || new Error("Aborted")));
  }
  abort(e) {
    this.cancel(e);
  }
  onCancel(e) {
    Hr(e) && this._registerCancelHandler(e);
  }
  get props() {
    return this._props;
  }
  _setProps(e) {
    if (this._props === e) return;
    this._props = e;
    const s = [], r = Object.getOwnPropertyDescriptors(S), n = Object.getOwnPropertyDescriptors(Object.getPrototypeOf(e));
    if (n.constructor.value !== Object) for (const o in n) {
      if (o in r || o in this && !this._registeredProps.includes(o)) continue;
      s.push(o);
      const i = n[o], a = Object.assign({}, i);
      delete a.get, delete a.set, (i.get || i.set) && (delete a.value, delete a.writable, i.get && (a.get = i.get.bind(e)), i.set && (a.set = i.set.bind(e))), Object.defineProperty(this, o, a);
    }
    for (const o of Object.keys(e)) s.push(o), o in r || o in this && !this._registeredProps.includes(o) || Object.defineProperty(this, o, { get: () => this._props[o], set: (i) => {
      this._props[o] = i;
    }, configurable: !0 });
    return this._registeredProps = s, this;
  }
  _registerCancelHandler(e) {
    this._handlers.cancel.push(e);
  }
  _callHandlers(e, s) {
    this._handlers[e].map(((r) => r && r(s)));
  }
  _destroy() {
    this._handlers.cancel = [];
  }
};
const S = Ai;
var mi = typeof globalThis == "object" ? globalThis : typeof self == "object" ? self : typeof window == "object" ? window : typeof globalThis == "object" ? globalThis : {}, Ze = "1.9.0", Gr = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
function yi(t) {
  var e = /* @__PURE__ */ new Set([t]), s = /* @__PURE__ */ new Set(), r = t.match(Gr);
  if (!r)
    return function() {
      return !1;
    };
  var n = {
    major: +r[1],
    minor: +r[2],
    patch: +r[3],
    prerelease: r[4]
  };
  if (n.prerelease != null)
    return function(d) {
      return d === t;
    };
  function o(a) {
    return s.add(a), !1;
  }
  function i(a) {
    return e.add(a), !0;
  }
  return function(d) {
    if (e.has(d))
      return !0;
    if (s.has(d))
      return !1;
    var h = d.match(Gr);
    if (!h)
      return o(d);
    var l = {
      major: +h[1],
      minor: +h[2],
      patch: +h[3],
      prerelease: h[4]
    };
    return l.prerelease != null || n.major !== l.major ? o(d) : n.major === 0 ? n.minor === l.minor && n.patch <= l.patch ? i(d) : o(d) : n.minor <= l.minor ? i(d) : o(d);
  };
}
var vi = yi(Ze), bi = Ze.split(".")[0], Ct = Symbol.for("opentelemetry.js.api." + bi), St = mi;
function Nt(t, e, s, r) {
  var n;
  r === void 0 && (r = !1);
  var o = St[Ct] = (n = St[Ct]) !== null && n !== void 0 ? n : {
    version: Ze
  };
  if (!r && o[t]) {
    var i = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + t);
    return s.error(i.stack || i.message), !1;
  }
  if (o.version !== Ze) {
    var i = new Error("@opentelemetry/api: Registration of version v" + o.version + " for " + t + " does not match previously registered API v" + Ze);
    return s.error(i.stack || i.message), !1;
  }
  return o[t] = e, s.debug("@opentelemetry/api: Registered a global for " + t + " v" + Ze + "."), !0;
}
function Qe(t) {
  var e, s, r = (e = St[Ct]) === null || e === void 0 ? void 0 : e.version;
  if (!(!r || !vi(r)))
    return (s = St[Ct]) === null || s === void 0 ? void 0 : s[t];
}
function Dt(t, e) {
  e.debug("@opentelemetry/api: Unregistering a global for " + t + " v" + Ze + ".");
  var s = St[Ct];
  s && delete s[t];
}
var Ri = function(t, e) {
  var s = typeof Symbol == "function" && t[Symbol.iterator];
  if (!s) return t;
  var r = s.call(t), n, o = [], i;
  try {
    for (; (e === void 0 || e-- > 0) && !(n = r.next()).done; ) o.push(n.value);
  } catch (a) {
    i = { error: a };
  } finally {
    try {
      n && !n.done && (s = r.return) && s.call(r);
    } finally {
      if (i) throw i.error;
    }
  }
  return o;
}, Oi = function(t, e, s) {
  if (arguments.length === 2) for (var r = 0, n = e.length, o; r < n; r++)
    (o || !(r in e)) && (o || (o = Array.prototype.slice.call(e, 0, r)), o[r] = e[r]);
  return t.concat(o || Array.prototype.slice.call(e));
}, Pi = (
  /** @class */
  (function() {
    function t(e) {
      this._namespace = e.namespace || "DiagComponentLogger";
    }
    return t.prototype.debug = function() {
      for (var e = [], s = 0; s < arguments.length; s++)
        e[s] = arguments[s];
      return gt("debug", this._namespace, e);
    }, t.prototype.error = function() {
      for (var e = [], s = 0; s < arguments.length; s++)
        e[s] = arguments[s];
      return gt("error", this._namespace, e);
    }, t.prototype.info = function() {
      for (var e = [], s = 0; s < arguments.length; s++)
        e[s] = arguments[s];
      return gt("info", this._namespace, e);
    }, t.prototype.warn = function() {
      for (var e = [], s = 0; s < arguments.length; s++)
        e[s] = arguments[s];
      return gt("warn", this._namespace, e);
    }, t.prototype.verbose = function() {
      for (var e = [], s = 0; s < arguments.length; s++)
        e[s] = arguments[s];
      return gt("verbose", this._namespace, e);
    }, t;
  })()
);
function gt(t, e, s) {
  var r = Qe("diag");
  if (r)
    return s.unshift(e), r[t].apply(r, Oi([], Ri(s), !1));
}
var Ie;
(function(t) {
  t[t.NONE = 0] = "NONE", t[t.ERROR = 30] = "ERROR", t[t.WARN = 50] = "WARN", t[t.INFO = 60] = "INFO", t[t.DEBUG = 70] = "DEBUG", t[t.VERBOSE = 80] = "VERBOSE", t[t.ALL = 9999] = "ALL";
})(Ie || (Ie = {}));
function Ci(t, e) {
  t < Ie.NONE ? t = Ie.NONE : t > Ie.ALL && (t = Ie.ALL), e = e || {};
  function s(r, n) {
    var o = e[r];
    return typeof o == "function" && t >= n ? o.bind(e) : function() {
    };
  }
  return {
    error: s("error", Ie.ERROR),
    warn: s("warn", Ie.WARN),
    info: s("info", Ie.INFO),
    debug: s("debug", Ie.DEBUG),
    verbose: s("verbose", Ie.VERBOSE)
  };
}
var Si = function(t, e) {
  var s = typeof Symbol == "function" && t[Symbol.iterator];
  if (!s) return t;
  var r = s.call(t), n, o = [], i;
  try {
    for (; (e === void 0 || e-- > 0) && !(n = r.next()).done; ) o.push(n.value);
  } catch (a) {
    i = { error: a };
  } finally {
    try {
      n && !n.done && (s = r.return) && s.call(r);
    } finally {
      if (i) throw i.error;
    }
  }
  return o;
}, Ni = function(t, e, s) {
  if (arguments.length === 2) for (var r = 0, n = e.length, o; r < n; r++)
    (o || !(r in e)) && (o || (o = Array.prototype.slice.call(e, 0, r)), o[r] = e[r]);
  return t.concat(o || Array.prototype.slice.call(e));
}, Di = "diag", ke = (
  /** @class */
  (function() {
    function t() {
      function e(n) {
        return function() {
          for (var o = [], i = 0; i < arguments.length; i++)
            o[i] = arguments[i];
          var a = Qe("diag");
          if (a)
            return a[n].apply(a, Ni([], Si(o), !1));
        };
      }
      var s = this, r = function(n, o) {
        var i, a, d;
        if (o === void 0 && (o = { logLevel: Ie.INFO }), n === s) {
          var h = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
          return s.error((i = h.stack) !== null && i !== void 0 ? i : h.message), !1;
        }
        typeof o == "number" && (o = {
          logLevel: o
        });
        var l = Qe("diag"), p = Ci((a = o.logLevel) !== null && a !== void 0 ? a : Ie.INFO, n);
        if (l && !o.suppressOverrideMessage) {
          var _ = (d = new Error().stack) !== null && d !== void 0 ? d : "<failed to generate stacktrace>";
          l.warn("Current logger will be overwritten from " + _), p.warn("Current logger will overwrite one already registered from " + _);
        }
        return Nt("diag", p, s, !0);
      };
      s.setLogger = r, s.disable = function() {
        Dt(Di, s);
      }, s.createComponentLogger = function(n) {
        return new Pi(n);
      }, s.verbose = e("verbose"), s.debug = e("debug"), s.info = e("info"), s.warn = e("warn"), s.error = e("error");
    }
    return t.instance = function() {
      return this._instance || (this._instance = new t()), this._instance;
    }, t;
  })()
), ki = function(t, e) {
  var s = typeof Symbol == "function" && t[Symbol.iterator];
  if (!s) return t;
  var r = s.call(t), n, o = [], i;
  try {
    for (; (e === void 0 || e-- > 0) && !(n = r.next()).done; ) o.push(n.value);
  } catch (a) {
    i = { error: a };
  } finally {
    try {
      n && !n.done && (s = r.return) && s.call(r);
    } finally {
      if (i) throw i.error;
    }
  }
  return o;
}, Li = function(t) {
  var e = typeof Symbol == "function" && Symbol.iterator, s = e && t[e], r = 0;
  if (s) return s.call(t);
  if (t && typeof t.length == "number") return {
    next: function() {
      return t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t };
    }
  };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, wi = (
  /** @class */
  (function() {
    function t(e) {
      this._entries = e ? new Map(e) : /* @__PURE__ */ new Map();
    }
    return t.prototype.getEntry = function(e) {
      var s = this._entries.get(e);
      if (s)
        return Object.assign({}, s);
    }, t.prototype.getAllEntries = function() {
      return Array.from(this._entries.entries()).map(function(e) {
        var s = ki(e, 2), r = s[0], n = s[1];
        return [r, n];
      });
    }, t.prototype.setEntry = function(e, s) {
      var r = new t(this._entries);
      return r._entries.set(e, s), r;
    }, t.prototype.removeEntry = function(e) {
      var s = new t(this._entries);
      return s._entries.delete(e), s;
    }, t.prototype.removeEntries = function() {
      for (var e, s, r = [], n = 0; n < arguments.length; n++)
        r[n] = arguments[n];
      var o = new t(this._entries);
      try {
        for (var i = Li(r), a = i.next(); !a.done; a = i.next()) {
          var d = a.value;
          o._entries.delete(d);
        }
      } catch (h) {
        e = { error: h };
      } finally {
        try {
          a && !a.done && (s = i.return) && s.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return o;
    }, t.prototype.clear = function() {
      return new t();
    }, t;
  })()
);
ke.instance();
function Mi(t) {
  return t === void 0 && (t = {}), new wi(new Map(Object.entries(t)));
}
function Tn(t) {
  return Symbol.for(t);
}
var Ui = (
  /** @class */
  /* @__PURE__ */ (function() {
    function t(e) {
      var s = this;
      s._currentContext = e ? new Map(e) : /* @__PURE__ */ new Map(), s.getValue = function(r) {
        return s._currentContext.get(r);
      }, s.setValue = function(r, n) {
        var o = new t(s._currentContext);
        return o._currentContext.set(r, n), o;
      }, s.deleteValue = function(r) {
        var n = new t(s._currentContext);
        return n._currentContext.delete(r), n;
      };
    }
    return t;
  })()
), xi = new Ui(), tt = /* @__PURE__ */ (function() {
  var t = function(e, s) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, n) {
      r.__proto__ = n;
    } || function(r, n) {
      for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (r[o] = n[o]);
    }, t(e, s);
  };
  return function(e, s) {
    if (typeof s != "function" && s !== null)
      throw new TypeError("Class extends value " + String(s) + " is not a constructor or null");
    t(e, s);
    function r() {
      this.constructor = e;
    }
    e.prototype = s === null ? Object.create(s) : (r.prototype = s.prototype, new r());
  };
})(), Bi = (
  /** @class */
  (function() {
    function t() {
    }
    return t.prototype.createGauge = function(e, s) {
      return Wi;
    }, t.prototype.createHistogram = function(e, s) {
      return Ki;
    }, t.prototype.createCounter = function(e, s) {
      return zi;
    }, t.prototype.createUpDownCounter = function(e, s) {
      return Xi;
    }, t.prototype.createObservableGauge = function(e, s) {
      return Ji;
    }, t.prototype.createObservableCounter = function(e, s) {
      return Zi;
    }, t.prototype.createObservableUpDownCounter = function(e, s) {
      return Qi;
    }, t.prototype.addBatchObservableCallback = function(e, s) {
    }, t.prototype.removeBatchObservableCallback = function(e) {
    }, t;
  })()
), ss = (
  /** @class */
  /* @__PURE__ */ (function() {
    function t() {
    }
    return t;
  })()
), ji = (
  /** @class */
  (function(t) {
    tt(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e.prototype.add = function(s, r) {
    }, e;
  })(ss)
), Vi = (
  /** @class */
  (function(t) {
    tt(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e.prototype.add = function(s, r) {
    }, e;
  })(ss)
), Fi = (
  /** @class */
  (function(t) {
    tt(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e.prototype.record = function(s, r) {
    }, e;
  })(ss)
), Hi = (
  /** @class */
  (function(t) {
    tt(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e.prototype.record = function(s, r) {
    }, e;
  })(ss)
), Zs = (
  /** @class */
  (function() {
    function t() {
    }
    return t.prototype.addCallback = function(e) {
    }, t.prototype.removeCallback = function(e) {
    }, t;
  })()
), Gi = (
  /** @class */
  (function(t) {
    tt(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e;
  })(Zs)
), $i = (
  /** @class */
  (function(t) {
    tt(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e;
  })(Zs)
), Yi = (
  /** @class */
  (function(t) {
    tt(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e;
  })(Zs)
), qi = new Bi(), zi = new ji(), Wi = new Fi(), Ki = new Hi(), Xi = new Vi(), Zi = new Gi(), Ji = new $i(), Qi = new Yi(), ea = {
  get: function(t, e) {
    if (t != null)
      return t[e];
  },
  keys: function(t) {
    return t == null ? [] : Object.keys(t);
  }
}, ta = {
  set: function(t, e, s) {
    t != null && (t[e] = s);
  }
}, sa = function(t, e) {
  var s = typeof Symbol == "function" && t[Symbol.iterator];
  if (!s) return t;
  var r = s.call(t), n, o = [], i;
  try {
    for (; (e === void 0 || e-- > 0) && !(n = r.next()).done; ) o.push(n.value);
  } catch (a) {
    i = { error: a };
  } finally {
    try {
      n && !n.done && (s = r.return) && s.call(r);
    } finally {
      if (i) throw i.error;
    }
  }
  return o;
}, ra = function(t, e, s) {
  if (s || arguments.length === 2) for (var r = 0, n = e.length, o; r < n; r++)
    (o || !(r in e)) && (o || (o = Array.prototype.slice.call(e, 0, r)), o[r] = e[r]);
  return t.concat(o || Array.prototype.slice.call(e));
}, na = (
  /** @class */
  (function() {
    function t() {
    }
    return t.prototype.active = function() {
      return xi;
    }, t.prototype.with = function(e, s, r) {
      for (var n = [], o = 3; o < arguments.length; o++)
        n[o - 3] = arguments[o];
      return s.call.apply(s, ra([r], sa(n), !1));
    }, t.prototype.bind = function(e, s) {
      return s;
    }, t.prototype.enable = function() {
      return this;
    }, t.prototype.disable = function() {
      return this;
    }, t;
  })()
), oa = function(t, e) {
  var s = typeof Symbol == "function" && t[Symbol.iterator];
  if (!s) return t;
  var r = s.call(t), n, o = [], i;
  try {
    for (; (e === void 0 || e-- > 0) && !(n = r.next()).done; ) o.push(n.value);
  } catch (a) {
    i = { error: a };
  } finally {
    try {
      n && !n.done && (s = r.return) && s.call(r);
    } finally {
      if (i) throw i.error;
    }
  }
  return o;
}, ia = function(t, e, s) {
  if (arguments.length === 2) for (var r = 0, n = e.length, o; r < n; r++)
    (o || !(r in e)) && (o || (o = Array.prototype.slice.call(e, 0, r)), o[r] = e[r]);
  return t.concat(o || Array.prototype.slice.call(e));
}, Ts = "context", aa = new na(), rs = (
  /** @class */
  (function() {
    function t() {
    }
    return t.getInstance = function() {
      return this._instance || (this._instance = new t()), this._instance;
    }, t.prototype.setGlobalContextManager = function(e) {
      return Nt(Ts, e, ke.instance());
    }, t.prototype.active = function() {
      return this._getContextManager().active();
    }, t.prototype.with = function(e, s, r) {
      for (var n, o = [], i = 3; i < arguments.length; i++)
        o[i - 3] = arguments[i];
      return (n = this._getContextManager()).with.apply(n, ia([e, s, r], oa(o), !1));
    }, t.prototype.bind = function(e, s) {
      return this._getContextManager().bind(e, s);
    }, t.prototype._getContextManager = function() {
      return Qe(Ts) || aa;
    }, t.prototype.disable = function() {
      this._getContextManager().disable(), Dt(Ts, ke.instance());
    }, t;
  })()
), Us;
(function(t) {
  t[t.NONE = 0] = "NONE", t[t.SAMPLED = 1] = "SAMPLED";
})(Us || (Us = {}));
var An = "0000000000000000", mn = "00000000000000000000000000000000", ca = {
  traceId: mn,
  spanId: An,
  traceFlags: Us.NONE
}, mt = (
  /** @class */
  (function() {
    function t(e) {
      e === void 0 && (e = ca), this._spanContext = e;
    }
    return t.prototype.spanContext = function() {
      return this._spanContext;
    }, t.prototype.setAttribute = function(e, s) {
      return this;
    }, t.prototype.setAttributes = function(e) {
      return this;
    }, t.prototype.addEvent = function(e, s) {
      return this;
    }, t.prototype.addLink = function(e) {
      return this;
    }, t.prototype.addLinks = function(e) {
      return this;
    }, t.prototype.setStatus = function(e) {
      return this;
    }, t.prototype.updateName = function(e) {
      return this;
    }, t.prototype.end = function(e) {
    }, t.prototype.isRecording = function() {
      return !1;
    }, t.prototype.recordException = function(e, s) {
    }, t;
  })()
), Js = Tn("OpenTelemetry Context Key SPAN");
function Qs(t) {
  return t.getValue(Js) || void 0;
}
function da() {
  return Qs(rs.getInstance().active());
}
function er(t, e) {
  return t.setValue(Js, e);
}
function ha(t) {
  return t.deleteValue(Js);
}
function la(t, e) {
  return er(t, new mt(e));
}
function yn(t) {
  var e;
  return (e = Qs(t)) === null || e === void 0 ? void 0 : e.spanContext();
}
var ua = /^([0-9a-f]{32})$/i, pa = /^[0-9a-f]{16}$/i;
function _a(t) {
  return ua.test(t) && t !== mn;
}
function fa(t) {
  return pa.test(t) && t !== An;
}
function vn(t) {
  return _a(t.traceId) && fa(t.spanId);
}
function Ea(t) {
  return new mt(t);
}
var As = rs.getInstance(), bn = (
  /** @class */
  (function() {
    function t() {
    }
    return t.prototype.startSpan = function(e, s, r) {
      r === void 0 && (r = As.active());
      var n = !!(s != null && s.root);
      if (n)
        return new mt();
      var o = r && yn(r);
      return ga(o) && vn(o) ? new mt(o) : new mt();
    }, t.prototype.startActiveSpan = function(e, s, r, n) {
      var o, i, a;
      if (!(arguments.length < 2)) {
        arguments.length === 2 ? a = s : arguments.length === 3 ? (o = s, a = r) : (o = s, i = r, a = n);
        var d = i ?? As.active(), h = this.startSpan(e, o, d), l = er(d, h);
        return As.with(l, a, void 0, h);
      }
    }, t;
  })()
);
function ga(t) {
  return typeof t == "object" && typeof t.spanId == "string" && typeof t.traceId == "string" && typeof t.traceFlags == "number";
}
var Ia = new bn(), Ta = (
  /** @class */
  (function() {
    function t(e, s, r, n) {
      this._provider = e, this.name = s, this.version = r, this.options = n;
    }
    return t.prototype.startSpan = function(e, s, r) {
      return this._getTracer().startSpan(e, s, r);
    }, t.prototype.startActiveSpan = function(e, s, r, n) {
      var o = this._getTracer();
      return Reflect.apply(o.startActiveSpan, o, arguments);
    }, t.prototype._getTracer = function() {
      if (this._delegate)
        return this._delegate;
      var e = this._provider.getDelegateTracer(this.name, this.version, this.options);
      return e ? (this._delegate = e, this._delegate) : Ia;
    }, t;
  })()
), Aa = (
  /** @class */
  (function() {
    function t() {
    }
    return t.prototype.getTracer = function(e, s, r) {
      return new bn();
    }, t;
  })()
), ma = new Aa(), $r = (
  /** @class */
  (function() {
    function t() {
    }
    return t.prototype.getTracer = function(e, s, r) {
      var n;
      return (n = this.getDelegateTracer(e, s, r)) !== null && n !== void 0 ? n : new Ta(this, e, s, r);
    }, t.prototype.getDelegate = function() {
      var e;
      return (e = this._delegate) !== null && e !== void 0 ? e : ma;
    }, t.prototype.setDelegate = function(e) {
      this._delegate = e;
    }, t.prototype.getDelegateTracer = function(e, s, r) {
      var n;
      return (n = this._delegate) === null || n === void 0 ? void 0 : n.getTracer(e, s, r);
    }, t;
  })()
), yt;
(function(t) {
  t[t.UNSET = 0] = "UNSET", t[t.OK = 1] = "OK", t[t.ERROR = 2] = "ERROR";
})(yt || (yt = {}));
var ya = rs.getInstance(), va = ke.instance(), ba = (
  /** @class */
  (function() {
    function t() {
    }
    return t.prototype.getMeter = function(e, s, r) {
      return qi;
    }, t;
  })()
), Ra = new ba(), ms = "metrics", Oa = (
  /** @class */
  (function() {
    function t() {
    }
    return t.getInstance = function() {
      return this._instance || (this._instance = new t()), this._instance;
    }, t.prototype.setGlobalMeterProvider = function(e) {
      return Nt(ms, e, ke.instance());
    }, t.prototype.getMeterProvider = function() {
      return Qe(ms) || Ra;
    }, t.prototype.getMeter = function(e, s, r) {
      return this.getMeterProvider().getMeter(e, s, r);
    }, t.prototype.disable = function() {
      Dt(ms, ke.instance());
    }, t;
  })()
), Pa = Oa.getInstance(), Ca = (
  /** @class */
  (function() {
    function t() {
    }
    return t.prototype.inject = function(e, s) {
    }, t.prototype.extract = function(e, s) {
      return e;
    }, t.prototype.fields = function() {
      return [];
    }, t;
  })()
), tr = Tn("OpenTelemetry Baggage Key");
function Rn(t) {
  return t.getValue(tr) || void 0;
}
function Sa() {
  return Rn(rs.getInstance().active());
}
function Na(t, e) {
  return t.setValue(tr, e);
}
function Da(t) {
  return t.deleteValue(tr);
}
var ys = "propagation", ka = new Ca(), La = (
  /** @class */
  (function() {
    function t() {
      this.createBaggage = Mi, this.getBaggage = Rn, this.getActiveBaggage = Sa, this.setBaggage = Na, this.deleteBaggage = Da;
    }
    return t.getInstance = function() {
      return this._instance || (this._instance = new t()), this._instance;
    }, t.prototype.setGlobalPropagator = function(e) {
      return Nt(ys, e, ke.instance());
    }, t.prototype.inject = function(e, s, r) {
      return r === void 0 && (r = ta), this._getGlobalPropagator().inject(e, s, r);
    }, t.prototype.extract = function(e, s, r) {
      return r === void 0 && (r = ea), this._getGlobalPropagator().extract(e, s, r);
    }, t.prototype.fields = function() {
      return this._getGlobalPropagator().fields();
    }, t.prototype.disable = function() {
      Dt(ys, ke.instance());
    }, t.prototype._getGlobalPropagator = function() {
      return Qe(ys) || ka;
    }, t;
  })()
), wa = La.getInstance(), vs = "trace", Ma = (
  /** @class */
  (function() {
    function t() {
      this._proxyTracerProvider = new $r(), this.wrapSpanContext = Ea, this.isSpanContextValid = vn, this.deleteSpan = ha, this.getSpan = Qs, this.getActiveSpan = da, this.getSpanContext = yn, this.setSpan = er, this.setSpanContext = la;
    }
    return t.getInstance = function() {
      return this._instance || (this._instance = new t()), this._instance;
    }, t.prototype.setGlobalTracerProvider = function(e) {
      var s = Nt(vs, this._proxyTracerProvider, ke.instance());
      return s && this._proxyTracerProvider.setDelegate(e), s;
    }, t.prototype.getTracerProvider = function() {
      return Qe(vs) || this._proxyTracerProvider;
    }, t.prototype.getTracer = function(e, s) {
      return this.getTracerProvider().getTracer(e, s);
    }, t.prototype.disable = function() {
      Dt(vs, ke.instance()), this._proxyTracerProvider = new $r();
    }, t;
  })()
), Ua = Ma.getInstance();
const At = {
  context: ya,
  diag: va,
  metrics: Pa,
  propagation: wa,
  trace: Ua
}, xa = "9.12.0";
function Ba(t) {
  return function(e) {
    e.traceableAs = () => t;
  };
}
function ns(t, e, s) {
  const r = function(...n) {
    const o = At.trace.getTracer("dcx-js", xa).startSpan(t), i = At.trace.setSpan(At.context.active(), o);
    try {
      const a = At.context.with(i, (() => e.apply(this, n)));
      return o.setStatus({ code: yt.OK }), a && a instanceof Promise ? a.catch(((d) => {
        throw d instanceof Error && (o.recordException(d), o.setStatus({ code: yt.ERROR, message: d.message })), d;
      })).finally((() => {
        o.end();
      })) : (o.end(), a);
    } catch (a) {
      throw a instanceof Error && (o.recordException(a), o.setStatus({ code: yt.ERROR, message: a.message })), o.end(), a;
    }
  };
  return Object.defineProperties(r, { name: { value: e.name }, length: { value: e.length } }), r;
}
function It(t, e, s) {
  var r;
  let n;
  Y(t) && (!((r = t.prototype) === null || r === void 0) && r.constructor) ? n = t.prototype.constructor : typeof t == "object" && t.constructor && (n = t.constructor);
  const o = s.value;
  return s.value = function(...i) {
    let a = e;
    if (n) {
      let d;
      d = Y(n.traceableAs) ? n.traceableAs() : n.name, a = d + "." + a;
    }
    return ns(a, o).apply(this, i);
  }, s;
}
function pe(t, e) {
  var s;
  (s = At.trace.getActiveSpan()) === null || s === void 0 || s.setAttribute(t, e || "");
}
const u = { ACCESS_CHECK: "http://ns.adobe.com/adobecloud/rel/ac/check", ACL_POLICY: "http://ns.adobe.com/adobecloud/rel/ac/policy", ANNOTATIONS: "http://ns.adobe.com/adobecloud/rel/annotations", APP_METADATA: "http://ns.adobe.com/adobecloud/rel/metadata/application", BASE_DIRECTORY: "http://ns.adobe.com/adobecloud/rel/directory/base", BLOCK_DOWNLOAD: "http://ns.adobe.com/adobecloud/rel/download", BLOCK_EXTEND: "http://ns.adobe.com/adobecloud/rel/block/extend", BLOCK_FINALIZE: "http://ns.adobe.com/adobecloud/rel/block/finalize", BLOCK_TRANSFER: "http://ns.adobe.com/adobecloud/rel/block/transfer", BLOCK_UPLOAD_INIT: "http://ns.adobe.com/adobecloud/rel/block/init", BULK_REQUEST: "http://ns.adobe.com/adobecloud/rel/bulk", COMPONENT: "http://ns.adobe.com/adobecloud/rel/component", CREATE: "http://ns.adobe.com/adobecloud/rel/create", DESCRIBED_BY: "describedBy", DIRECTORY: "http://ns.adobe.com/adobecloud/rel/directory", DISCARD: "http://ns.adobe.com/adobecloud/rel/discard", EFFECTIVE_PRIVILAGES: "http://ns.adobe.com/adobecloud/rel/ac/effective", EMBEDDED_METADATA: "http://ns.adobe.com/adobecloud/rel/metadata/embedded", ID: "http://ns.adobe.com/adobecloud/rel/id", MANIFEST: "http://ns.adobe.com/adobecloud/rel/manifest", PAGE: "http://ns.adobe.com/adobecloud/rel/page", PATH: "http://ns.adobe.com/adobecloud/rel/path", PRIMARY: "http://ns.adobe.com/adobecloud/rel/primary", RENDITION: "http://ns.adobe.com/adobecloud/rel/rendition", REPO_METADATA: "http://ns.adobe.com/adobecloud/rel/metadata/repository", REPO_OPS: "http://ns.adobe.com/adobecloud/rel/ops", REPOSITORY: "http://ns.adobe.com/adobecloud/rel/repository", RESOLVE_BY_ID: "http://ns.adobe.com/adobecloud/rel/resolve/id", RESOLVE_BY_PATH: "http://ns.adobe.com/adobecloud/rel/resolve/path", RESTORE: "http://ns.adobe.com/adobecloud/rel/restore", VERSION_HISTORY: "version-history" };
var T, De, Yr, qr, zr, Jt, j, vt;
function ja(t) {
  return C(t) && ["headers", "responseType", "statusCode", "xhr"].every(((e) => e in t));
}
function Va(t) {
  return C(t) && ja(t.response);
}
function On(t) {
  return C(t) && Va(t) && "result" in t;
}
function Pn(t) {
  return C(t) && Y(t.slice);
}
function xs(t) {
  return C(t) && "resolvePullWithBranch" in t;
}
function Wr(t) {
  return C(t) && (["compositeId", "compositeAssetId", "compositeRepositoryId"].some(((e) => e in t)) || C(t._core));
}
function Qt(t) {
  return C(t) && (C(t.links) || typeof t.repositoryId == "string" && (typeof t.path == "string" || typeof t.assetId == "string"));
}
function Fa(t) {
  return typeof Blob < "u" && t instanceof Blob;
}
function sr(t) {
  return C(t) && (typeof t.repositoryId == "string" && typeof t.path == "string" || typeof t.assetId == "string");
}
function Ha(t) {
  return C(t) && (t.name === "AdobeHTTPService" || Y(t.invoke));
}
function rr(t) {
  return C(t) && Ha(t.service);
}
function Ga(t) {
  if (!C(t)) return !1;
  const e = t[T.LINKS];
  return C(e) ? !!(e[u.BLOCK_TRANSFER] && e[u.BLOCK_EXTEND] && e[u.BLOCK_FINALIZE]) : !1;
}
function Cn(t) {
  return (e) => {
    const s = {};
    for (const r in e) s[r.toLowerCase()] = e[r];
    for (const r of t) s.hasOwnProperty(r.toLowerCase()) && delete s[r.toLowerCase()];
    return s;
  };
}
(function(t) {
  t.DC_FORMAT = "dc:format", t.DC_TITLE = "dc:title", t.LINKS = "_links", t.PAGE = "_page", t.CHILDREN = "children", t.EMBEDDED = "_embedded", t.REPO_REPRESENTATIONS = "repo:representations", t.REPO_ASSET_ID = "repo:assetId", t.REPO_REPOSITORY_ID = "repo:repositoryId", t.REPO_REPOSITORY_TYPE = "repo:repositoryType", t.REPO_BASE_ASSET_ID = "repo:baseAssetId", t.REPO_SIZE = "repo:size", t.REPO_NAME = "repo:name", t.REPO_PATH = "repo:path", t.REPO_ASSET_CLASS = "repo:assetClass", t.REPO_CREATE_DATE = "repo:createDate", t.REPO_MODIFY_DATE = "repo:modifyDate", t.REPO_DISCARD_DATE = "repo:discardDate", t.REPO_ETAG = "repo:etag", t.REPO_CREATED_BY = "repo:createdBy", t.REPO_MODIFIED_BY = "repo:modifiedBy", t.REPO_DISCARDED_BY = "repo:discardedBy", t.REPO_DEVICE_CREATE_DATE = "storage:deviceCreateDate", t.REPO_DEVICE_MODIFY_DATE = "storage:deviceModifyDate", t.REPO_DEFAULT_SCHEDULED_DELETION_DURATION = "repo:defaultScheduledDeletionDuration", t.REPO_ASSET_TYPE = "repo:assetType", t.REPO_ASSET_SUB_TYPE = "repo:assetSubType", t.STORAGE_LES = "storage:les", t.REPO_SCHEDULED_DELETION_DATE = "repo:scheduledDeletionDate", t.REPO_VERSION = "repo:version", t.REPO_STATE = "repo:state", t.REPO_AVAILABLE_REGIONS = "repo:availableRegions", t.REPO_REGIONS = "repo:regions", t.REPO_OWNER = "repo:owner", t.REPO_OWNER_ID = "id", t.REPO_OWNER_TYPE = "type", t.REPO_CONTRIBUTORS = "repo:contributors", t.REPO_MODIFIED_BY_CLIENT_ID = "repo:modifiedByClientId", t.REPO_MODIFIED_BY_CLIENT_AGENT = "repo:modifiedByClientAgent", t.REPO_MODIFIED_BY_IP_ADDRESS = "repo:modifiedByIpAddress", t.STORAGE_ASSIGNEE = "storage:assignee", t.STORAGE_ASSIGNEE_ID = "id", t.STORAGE_ASSIGNEE_TYPE = "type", t.IMAGE_LENGTH = "tiff:imageLength", t.IMAGE_WIDTH = "tiff:imageWidth", t.NUM_OF_PAGES = "xmpTPg:NPages", t.PAGE_START = "start", t.PAGE_ORDER_BY = "orderBy", t.PAGE_NEXT = "next", t.PAGE_COUNT = "count", t.PAGE_LIMIT = "limit";
})(T || (T = {})), (function(t) {
  t.REPO_ID = "repo:id", t.CREATED = "created", t.CREATED_BY = "created_by", t.MILESTONE = "milestone", t.VERSION = "version", t.CONTRIBUTORS = "contributors", t.TOTAL_CHILDREN = "total_children";
})(De || (De = {})), (function(t) {
  t.REPO_ACL = "repo:acl", t.REPO_PRINCIPLE = "repo:principal", t.REPO_MODIFIER = "repo:modifier", t.REPO_PRIVILEGES = "repo:privileges", t.REPO_RELATIONS = "repo:relations", t.REPO_INHERITANCE = "repo:inheritance";
})(Yr || (Yr = {})), (function(t) {
  t.XDM_PROVIDER = "xdm:provider", t.ID = "@id", t.TYPE = "@type";
})(qr || (qr = {})), (function(t) {
  t.ID = "@id";
})(zr || (zr = {})), (function(t) {
  t.XML = "application/rdf+xml", t.JSON = "application/ld+json";
})(Jt || (Jt = {})), (function(t) {
  t.REPO_SIZE = "repo:size", t.REPO_BLOCK_SIZE = "repo:blocksize", t.REPO_REL_TYPE = "repo:reltype", t.COMPONENT_ID = "component_id", t.DC_FORMAT = "dc:format", t.REPO_MD5 = "repo:md5", t.REPO_EXPIRES = "repo:expires", t.REPO_IF_MATCH = "repo:if-match", t.MAX_SINGLE_TRANSFER_SIZE = "repo:maxSingleTransferSize", t.REPO_MIN_BLOCK_TRANSFER_SIZE = "repo:minBlockTransferSize";
})(j || (j = {})), (function(t) {
  t.DEVICE_MODIFY_DATE = "deviceModifyDate", t.REPO_META_PATCH = "repoMetaPatch", t.RESPOND_WITH = "respondWith";
})(vt || (vt = {}));
const Kr = B("dcx:assets:service"), x = (t) => rr(t) ? t.service : t, oe = (t) => rr(t) ? t.cache : void 0;
function ze(t, e) {
  Kr("constructServiceEndpoint()", t);
  const s = e._repoAPIBaseUrl;
  return s && (t = `${s.endsWith("/") ? s.substr(0, s.length - 1) : s}${t}`), Kr("cSE()", t), t;
}
const Ye = { Asset: "asset", Directory: "directory" };
var b, v;
(function(t) {
  t.CONTENT_ID = "content-id", t.CONTENT_LENGTH = "content-length", t.CONTENT_RANGE = "content-range", t.CONTENT_TYPE = "content-type", t.IF_MATCH = "if-match", t.IF_NONE_MATCH = "if-none-match", t.AUTHORIZATION = "authorization", t.X_API_KEY = "x-api-key", t.X_CONTRIBUTORS = "x-contributors", t.LES_SEQUENCE_NUMBER = "les-sequence-number", t.PREFER = "prefer", t.DIRECTIVE = "directive";
})(b || (b = {})), (function(t) {
  t.GET = "GET", t.PUT = "PUT", t.PATCH = "PATCH", t.HEAD = "HEAD", t.POST = "POST", t.DELETE = "DELETE";
})(v || (v = {}));
const $a = "application/vnd.adobecloud.directory+json", Ya = "application/vnd.adobe.dcx-manifest+json", qa = "application/json", Bs = "application/problem+json", lt = "application/json-patch+json", Sn = "application/vnd.adobecloud.bulk-transfer+json", za = "application/vnd.adobe.asset-operation+json", nr = ["buffer", "arraybuffer", "string", "text", "blob", "json", "stream", "defaultbuffer"];
function Nn(t, e) {
  var s = {};
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (s[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function") {
    var n = 0;
    for (r = Object.getOwnPropertySymbols(t); n < r.length; n++) e.indexOf(r[n]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[n]) && (s[r[n]] = t[r[n]]);
  }
  return s;
}
function ne(t, e, s, r) {
  return new (s || (s = Promise))((function(n, o) {
    function i(h) {
      try {
        d(r.next(h));
      } catch (l) {
        o(l);
      }
    }
    function a(h) {
      try {
        d(r.throw(h));
      } catch (l) {
        o(l);
      }
    }
    function d(h) {
      var l;
      h.done ? n(h.value) : (l = h.value, l instanceof s ? l : new s((function(p) {
        p(l);
      }))).then(i, a);
    }
    d((r = r.apply(t, [])).next());
  }));
}
function at(t) {
  return this instanceof at ? (this.v = t, this) : new at(t);
}
function Wa(t, e, s) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var r, n = s.apply(t, e || []), o = [];
  return r = {}, i("next"), i("throw"), i("return"), r[Symbol.asyncIterator] = function() {
    return this;
  }, r;
  function i(p) {
    n[p] && (r[p] = function(_) {
      return new Promise((function(f, m) {
        o.push([p, _, f, m]) > 1 || a(p, _);
      }));
    });
  }
  function a(p, _) {
    try {
      (f = n[p](_)).value instanceof at ? Promise.resolve(f.value.v).then(d, h) : l(o[0][2], f);
    } catch (m) {
      l(o[0][3], m);
    }
    var f;
  }
  function d(p) {
    a("next", p);
  }
  function h(p) {
    a("throw", p);
  }
  function l(p, _) {
    p(_), o.shift(), o.length && a(o[0][0], o[0][1]);
  }
}
const k = (t, e, s) => {
  if (t == null) return zt;
  const r = {}, n = {}, o = t || [];
  return (i, a) => {
    var d, h;
    if (!i || !a) return new c(A.NETWORK_ERROR, "Invalid or missing status code", void 0, a);
    if (o.includes(i)) return !0;
    const l = n[i] || ((d = qt.get(i)) === null || d === void 0 ? void 0 : d.message) || "Unexpected response", p = r[i] || ((h = qt.get(i)) === null || h === void 0 ? void 0 : h.code), _ = zt(i, a);
    return _ === !0 && p == null || (dt(_) ? _ : !!p && new c(p, l, void 0, a));
  };
}, V = (t, e = [], s, r) => {
  if (!C(t)) throw new c(s || c.INVALID_PARAMS, r || "Missing or invalid links on Asset");
  e.map(((n) => {
    if (!(n in t) || !C(t[n])) throw new c(s || c.INVALID_PARAMS, r || `Missing required link: ${n}`);
  }));
}, Dn = (t = {}, e = []) => {
  if (e.length !== 0) {
    for (let s = 0; s < e.length; s++) {
      const r = e[s];
      if (r in t && C(t[r])) return r;
    }
    throw new c(c.INVALID_PARAMS, `Missing links, one required: ${e.join(", ")}`);
  }
}, kn = (t, e, s, r) => {
  const n = ts(t, e, s);
  if (!n) throw new c(c.INVALID_DATA, `Missing ${s} param on Link`);
  if (n !== r) throw new c(c.INVALID_DATA, `Invalid ${s} param on Link, expected ${r}`);
}, ht = (t, e = []) => {
  try {
    V(t, e);
  } catch {
    return !1;
  }
  return !0;
}, Ka = (t, e = []) => !!C(t) && ht(t.links || t._links, e);
function Ln(t) {
  if (!sr(t)) throw new c(c.INVALID_PARAMS, "Asset must contain links or repositoryId + path or assetId to be resolved.");
}
function wn(t, e, s) {
  if (!C(t)) throw new c(c.INVALID_PARAMS, `Invalid parameter. Expected object, encountered "${t === null ? "null" : typeof t}".`);
  if (!(e in t)) throw new c(c.INVALID_PARAMS, `Invalid parameter object. Expected object containing key "${String(e)}".`);
  if (s) try {
    qe(e, t[e], s);
  } catch {
    throw new c(c.INVALID_PARAMS, `Invalid parameter object. Expected object containing key "${String(e)}" with type "${s}", encountered type "${typeof t[e]}".`);
  }
}
function Le(t, e, s) {
  if (!(e.length < 1)) {
    for (const r of e) try {
      return void wn(t, r, s);
    } catch {
    }
    throw new c(c.INVALID_PARAMS, `Invalid parameter object. Expected object containing one of [${e.join(", ")}]` + (s ? ` with type ${s}, encountered types [${e.map(((r) => typeof t[r])).join(", ")}].` : "."));
  }
}
const Xa = B("dcx:assets:util:http");
function or(t, e, s) {
  return Xa("headHTTPResource()"), x(t).invoke(v.HEAD, e, s, void 0, { isStatusValid: k() });
}
function Za(t, e, s, r) {
  return x(t).invoke(v.GET, e, s, void 0, { isStatusValid: k(), responseType: r });
}
const Mn = B("dcx:assets:util:serialization");
function se(t, e) {
  Mn("deserializeAsset()");
  const s = {};
  s.repositoryId = t.repositoryId || t[T.REPO_REPOSITORY_ID], s.assetId = t.assetId || t[T.REPO_ASSET_ID], s.name = t.name || t[T.REPO_NAME], s.size = t.size != null ? t.size : t[T.REPO_SIZE], s.path = t.path || t[T.REPO_PATH], s.assetClass = t.etag || t[T.REPO_ASSET_CLASS], s.etag = t.etag || t[T.REPO_ETAG], s.version = t.version || t[T.REPO_VERSION], s.format = t.format || t[T.DC_FORMAT], s.md5 = t.md5, s.createDate = t.createDate || t[T.REPO_CREATE_DATE], s.modifyDate = t.modifyDate || t.modifiedDate || t[T.REPO_MODIFY_DATE], s.discardDate = t.discardDate || t[T.REPO_DISCARD_DATE], s.createdBy = t.createdBy || t[T.REPO_CREATED_BY], s.modifiedBy = t.modifiedBy || t[T.REPO_MODIFIED_BY], s.discardedBy = t.discardedBy || t[T.REPO_DISCARDED_BY], s.deviceCreateDate = t.deviceCreateDate || t[T.REPO_DEVICE_CREATE_DATE], s.deviceModifyDate = t.deviceModifyDate || t[T.REPO_DEVICE_MODIFY_DATE], s.defaultScheduledDeletionDuration = t.defaultScheduledDeletionDuration || t[T.REPO_DEFAULT_SCHEDULED_DELETION_DURATION], s.scheduledDeletionDate = t.scheduledDeletionDate || t[T.REPO_SCHEDULED_DELETION_DATE], s.assetType = t.assetType || t[T.REPO_ASSET_TYPE], s.assetSubType = t.assetSubType || t[T.REPO_ASSET_SUB_TYPE], s.les = t.les || t[T.STORAGE_LES], s.baseAssetId = t.baseAssetId || t[T.REPO_BASE_ASSET_ID], s.state = t.state || t[T.REPO_STATE], s.links = t.links || t[T.LINKS], s.representations = t.representations || t[T.REPO_REPRESENTATIONS], s.contributors = t.contributors || t[T.REPO_CONTRIBUTORS], s.width = t.width || t[T.IMAGE_WIDTH], s.length = t.length || t[T.IMAGE_LENGTH];
  const r = [e, t._embedded].flat();
  return s.embedded = Object.entries({ EffectivePrivileges: u.EFFECTIVE_PRIVILAGES, RepositoryResource: u.REPOSITORY, AppMetadata: u.APP_METADATA }).reduce(((n, [o, i]) => (r.filter(((a) => a && i in a)).forEach(((a) => de(n, { [o]: i === u.REPOSITORY ? ir(a) : a }))), n)), {}), L(s);
}
function ir(t = {}) {
  Mn("deserializeRepository()");
  const e = t[u.REPOSITORY] ? t[u.REPOSITORY] : t;
  return { repositoryId: e[T.REPO_REPOSITORY_ID], repositoryType: e[T.REPO_REPOSITORY_TYPE], owner: e[T.REPO_OWNER], createDate: e[T.REPO_CREATE_DATE], title: e[T.DC_TITLE], availableRegions: e[T.REPO_AVAILABLE_REGIONS] };
}
function Ja(t) {
  const e = [];
  return t.assetType && e.push({ op: "add", path: `/${[T.REPO_ASSET_TYPE]}`, value: t.assetType }), t.assetSubType && e.push({ op: "add", path: `/${[T.REPO_ASSET_SUB_TYPE]}`, value: t.assetSubType }), e;
}
const Un = B("dcx:assets:util:link");
function xn(t, e) {
  Un("getIndexLinks()");
  const s = x(t), r = oe(t);
  if (r) {
    const n = r.getIndexLinks();
    if (n) return S.resolve(n);
    r.setPending("INDEX");
  }
  return or(s, ze("/", s), e).then(((n) => he(n))).then(((n) => (r && r.setIndexLinks(n), n))).catch(((n) => {
    throw r && r.delete("INDEX"), n;
  }));
}
function Bn(t, e) {
  Un("getIndexDocument()");
  const s = x(t), r = oe(t);
  if (r) {
    const o = r.getIndexRepository();
    if (o) return S.resolve(o);
  }
  const n = ze("/", s);
  return s.invoke(v.GET, n, e, void 0, { responseType: "json", isStatusValid: k() }).then(((o) => {
    const i = he(o), a = o.response, d = {};
    for (const h in a.children) {
      const l = a.children[h], p = l[T.LINKS];
      switch (l[T.REPO_PATH]) {
        case "/Index.json":
          d.indexLinks = p;
          break;
        case "/Assets.json":
          d.assetLinks = p;
          break;
        case "/Repositories.json":
          d.repositoryLinks = p;
      }
    }
    return r && (r.setIndexLinks(i), r.setIndexRepository(d)), d;
  }));
}
function he(t) {
  if (!t.headers || !t.headers.link) throw new c(c.INVALID_DATA, "Failed to parse, missing link header");
  return ar(t.headers.link);
}
function ar(t) {
  try {
    const e = Ei(t), s = {};
    for (const r in e.refs) {
      const n = e.refs[r], { rel: o, uri: i, templated: a, type: d, width: h, height: l } = n, p = Nn(n, ["rel", "uri", "templated", "type", "width", "height"]), _ = L({ href: i, templated: a ? a === "true" : void 0, type: d, width: h, height: l, [j.MAX_SINGLE_TRANSFER_SIZE]: p[j.MAX_SINGLE_TRANSFER_SIZE.toLowerCase()], [j.REPO_MIN_BLOCK_TRANSFER_SIZE]: p[j.REPO_MIN_BLOCK_TRANSFER_SIZE.toLowerCase()] });
      ["width", "height"].filter(((m) => m in _)).forEach(((m) => {
        const y = parseInt(_[m], 10);
        isNaN(y) || (_[m] = y);
      }));
      const f = s[o];
      Array.isArray(f) ? f.push(_) : s[o] = f ? [f, _] : _;
    }
    return Object.assign({}, s);
  } catch (e) {
    throw new c(c.INVALID_DATA, "Failed to parse, invalid link header", e);
  }
}
function we(t, e) {
  if (C(this)) {
    if (typeof this.opsHref == "string") return S.resolve(this.opsHref);
    if (Y(this.opsHref)) return S.resolve(this.opsHref());
  }
  return xn(t, e).then(((s) => {
    try {
      return H(s, u.REPO_OPS);
    } catch (r) {
      throw new c(c.UNEXPECTED, "Could not get ops href.", r);
    }
  }));
}
const Re = B("dcx:assets:operations"), Ke = B("dcx:assets:operations:builder"), Xr = 500;
function jn(t, e, s, r, n, o, i, a) {
  Re("copyAsset()"), E(["svc", t, "object"], ["srcAsset", e, "object"], ["destAsset", s, "object"], ["createIntermediates", r, "boolean"], ["overwriteExisting", n, "boolean", !0], ["manifestPatch", i, ["object", "string"], !0]), Le(e, ["repo:path", "path", "assetId", "repo:assetId"], "string"), Le(s, ["repo:path", "path", "assetId", "repo:assetId"], "string");
  const d = Ae("copy", s, e, { overwriteExisting: n, createIntermediates: r }, L({ "repo:manifestPatch": JSON.stringify(i), nameConflictPolicy: a })), h = x(t);
  return we.call(this, t).then(((l) => Ve(h, l, d, o))).then(os.bind(void 0, s)).then(cr);
}
function Vn(t, e, s, r, n, o, i) {
  Re("moveAsset()"), E(["svc", t, "object"], ["srcAsset", e, "object"], ["destAsset", s, "object"], ["createIntermediates", r, "boolean"], ["overwriteExisting", n, "boolean", !0]), Le(e, ["repo:path", "path", "assetId", "repo:assetId"], "string"), Le(s, ["repo:path", "path", "assetId", "repo:assetId"], "string");
  const a = Ae("move", s, e, { createIntermediates: r, overwriteExisting: n }, L({ nameConflictPolicy: i })), d = x(t);
  return we.call(this, t).then(((h) => Ve(d, h, a, o))).then(os.bind(void 0, s)).then(cr);
}
function Fn(t, e, s, r, n) {
  Re("discardAsset()"), E(["svc", t, "object"], ["asset", e, "object"], ["etag", s, "string", !0], ["recursive", r, "boolean", !0]);
  const o = x(t);
  Le(e, ["repo:path", "path", "assetId", "repo:assetId"], "string");
  const i = Ae("discard", Object.assign(Object.assign({}, e), { etag: s }), void 0, { recursive: r });
  return we.call(this, t).then(((a) => Ve(o, a, i, n))).then(es);
}
const Hn = ns("AdobeDCX.deleteAsset", (function(t, e, s = "*", r, n) {
  Re("deleteAsset()"), pe("mediaType", e.format), pe("assetId", e.assetId), E(["svc", t, "object"], ["asset", e, "object"], ["etag", s, "string", !0], ["recursive", r, "boolean", !0]);
  const o = x(t);
  if (e.format === $a && r == null) throw new c(c.INVALID_PARAMS, "Recursive flag is required for directory assets.");
  if (!r && Ka(e, [u.REPO_METADATA])) {
    const d = J(e, u.REPO_METADATA, {});
    return o.invoke("DELETE", d, { [b.IF_MATCH]: s }, void 0, { isStatusValid: k() }).then(es);
  }
  Le(e, ["repo:path", "path", "assetId", "repo:assetId"], "string");
  const i = Object.create(Object.getPrototypeOf(e), Object.getOwnPropertyDescriptors(e));
  i.etag = s;
  const a = Ae("delete", i, void 0, { recursive: r });
  return we.call(this, t).then(((d) => Ve(o, d, a, n))).then(es);
}));
function Gn(t, e, s, r) {
  Re("restoreAsset()"), E(["svc", t, "object"], ["asset", e, "object"]);
  const n = x(t);
  Le(e, ["assetId", "repo:assetId"], "string");
  const o = Ae("restore", e, void 0, void 0, { nameConflictPolicy: r });
  return we.call(this, t).then(((i) => Ve(n, i, o, s))).then(os.bind(void 0, e)).then(cr);
}
function $n(t, e, s, r, n, o) {
  var i, a;
  Re("packageAssets()"), E(["svc", t, "object"], ["destination", s, "object"]), qe("sources", e, ["object", "object[]"]), e = fe(e) ? e : [e], i = ["repo:path", "path", "assetId", "repo:assetId"], a = "string", e.map(((l) => Le(l, i, a))), Le(s, ["repo:path", "path", "assetId", "repo:assetId"], "string");
  const d = Ae("package", s, e, { createIntermediates: r, overwriteExisting: n }), h = x(t);
  return we.call(this, t).then(((l) => Ve(h, l, d, o))).then(os.bind(void 0, s)).then(es);
}
function Qa(t, e, s, r) {
  return Yn(t, e, s, r).then(ec);
}
function ec(t) {
  return { result: (fe(t.response) ? t.response : [t.response]).map(tc), response: t };
}
function tc(t) {
  if (!t.error) return t;
  const e = Object.assign({}, t), s = k()(t.error.status);
  return e.error = dt(s) ? s : new c(c.UNEXPECTED, "Unexpected response"), e._additionalData = t.error, e.error._message = t.error.title, e;
}
function Ve(t, e, s, r, n = !1) {
  return Re("doOperation()"), E(["svc", t, "object"], ["opsEndpoint", e, "string"], ["operationDocument", s, ["string", "object"]], ["additionalHeaders", r, "object", !0]), Yn(t, e, s, r, n).then(jo);
}
class sc {
  constructor() {
    this.opBatchLimit = 100, this._docs = [];
  }
  getDocumentEntry(e) {
    return this._docs[e];
  }
  getDocument() {
    return this._docs;
  }
  get entryCount() {
    return this._docs.length;
  }
  copyResources(e, s, r, n, o, i) {
    Ke("copyResource()"), this._assertUnderLimit(), this._checkSourceType(e), this._checkTargetType(s);
    const a = this._docs.find(/* @__PURE__ */ (function(h, l) {
      return function(p) {
        return p.op === "copy_resources" && Jr(p.source, h) && Jr(p.target, l);
      };
    })(e, s));
    if (a) return a.resources = a.resources.concat(r), o && (a["repo:manifestPatch"] = JSON.stringify(o)), n !== void 0 && (a.intermediates = n), this;
    const d = Ae("copy_resources", s, e, { createIntermediates: n }, { resources: r, "repo:manifestPatch": JSON.stringify(o), additionalHeaders: i });
    return this._docs.push(d), this;
  }
  copy(e, s, r, n, o) {
    Ke("copy()"), this._assertUnderLimit(), this._checkSourceType(e), this._checkTargetType(s);
    const i = Ae("copy", s, e, { createIntermediates: r, overwriteExisting: n }, o);
    return this._docs.push(i), this;
  }
  move(e, s, r, n, o) {
    Ke("move()"), this._assertUnderLimit(), this._checkSourceType(e), this._checkTargetType(s);
    const i = Ae("move", s, e, { createIntermediates: r, overwriteExisting: n }, o);
    return this._docs.push(i), this;
  }
  package(e, s, r, n, o) {
    Ke("package()"), this._assertUnderLimit(), (e = fe(e) ? e : [e]).map(((a) => {
      this._checkSourceType(a);
    })), this._checkTargetType(s);
    const i = Ae("package", s, e, { createIntermediates: r, overwriteExisting: n }, o);
    return this._docs.push(i), this;
  }
  discard(e, s, r) {
    Ke("discard()"), this._assertUnderLimit(), this._checkTargetType(e);
    const n = Ae("discard", e, void 0, { recursive: s }, r);
    return this._docs.push(n), this;
  }
  restore(e, s) {
    Ke("restore()"), this._assertUnderLimit(), Le(e, ["assetId", "repo:assetId"], "string"), this._checkTargetType(e);
    const r = Ae("restore", e, void 0, void 0, s);
    return this._docs.push(r), this;
  }
  delete(e, s, r) {
    Ke("delete()"), this._assertUnderLimit(), this._checkTargetType(e);
    const n = Ae("delete", e, void 0, { recursive: s }, r);
    return this._docs.push(n), this;
  }
  _assertUnderLimit() {
    if (this._docs.length >= this.opBatchLimit) throw new c(c.INVALID_STATE, `Exceeds limit of ${this.opBatchLimit} operations in a single batch.`);
  }
  _checkTargetType(e) {
    this._checkSourceOrTargetType(e, "Target");
  }
  _checkSourceType(e) {
    this._checkSourceOrTargetType(e, "Source");
  }
  _checkSourceOrTargetType(e, s) {
    if ([!!e.assetId || !!e["repo:assetId"], !!e.path || !!e["repo:path"]].filter(((o) => o)).length === 0) throw new c(c.INVALID_PARAMS, `${s} identifier is underspecified. Exactly one of [href, repo:path, repo:assetId] required.`);
    const r = this._getSourceType(e), n = s === "Source" ? this._batchSourceType : this._batchTargetType;
    if (n) {
      if (r !== n) throw new c(c.INVALID_PARAMS, `Operation ${s.toLowerCase()} types must all be the same type. Expected ${n}, encountered ${r}.`);
    } else s === "Source" ? this._batchSourceType = r : this._batchTargetType = r;
  }
  _getSourceType(e) {
    return e.assetId || e["repo:assetId"] ? "id" : e.path || e["repo:path"] ? e.baseAssetId || e["repo:baseAssetId"] ? "pathAndBaseAssetId" : "path" : void 0;
  }
}
function Zr() {
  return new sc();
}
function Jr(t, e) {
  var s, r;
  return t[T.REPO_ASSET_ID] === ((s = e[T.REPO_ASSET_ID]) !== null && s !== void 0 ? s : e.assetId) && t[T.REPO_REPOSITORY_ID] === ((r = e[T.REPO_REPOSITORY_ID]) !== null && r !== void 0 ? r : e.repositoryId);
}
function Yn(t, e, s, r = {}, n = !1) {
  return t.invoke(v.POST, e, Object.assign({ [b.CONTENT_TYPE]: za }, r), typeof s == "string" ? s : JSON.stringify(s), { isStatusValid: k(), responseType: "json", retryOptions: { pollCodes: [202], pollHeader: "location", pollMethod: "get", modifyHeadersCallback: Cn([b.PREFER]), skipPollingTimeout: n } });
}
function os(t, e) {
  return e.response.asset = Object.assign(Object.assign({}, e.response.asset || {}), { repositoryId: t.repositoryId || t["repo:repositoryId"] }), e;
}
function cr(t) {
  return { response: t, result: se(t.response.asset) };
}
function es(t) {
  return { response: t, result: { success: t.statusCode > 199 && t.statusCode < 400 } };
}
function bs(t, e, s) {
  if (Re("_convertToACPSource()"), typeof e != "object") return;
  const r = { "repo:repositoryId": e.repositoryId || e["repo:repositoryId"], "repo:path": e.path || e["repo:path"], "repo:assetId": e.assetId || e["repo:assetId"], "repo:baseAssetId": e.baseAssetId || e["repo:baseAssetId"] };
  return typeof r.href == "string" ? (delete r["repo:path"], delete r["repo:assetId"], delete r["repo:baseAssetId"]) : typeof r["repo:assetId"] == "string" && (delete r["repo:path"], delete r["repo:baseAssetId"]), t === "target" ? s === !0 ? r[b.IF_MATCH] = e.format !== Ye.Directory && e["dc:format"] !== Ye.Directory && e.etag || "*" : s === !1 ? r[b.IF_NONE_MATCH] = "*" : e.format !== Ye.Directory && e["dc:format"] !== Ye.Directory && (r[b.IF_MATCH] = e.etag) : e.format !== Ye.Directory && e["dc:format"] !== Ye.Directory && (r[b.IF_MATCH] = e.etag || "*"), e.version && (r["repo:version"] = e.version), r["repo:path"] && wn(r, "repo:repositoryId", "string"), Re("_cTACPS() out", r), L(r);
}
function Ae(t, e, s, r = {}, n = {}) {
  Re("_buildOperationDoc()");
  const o = L({ op: t, target: e, source: fe(s) ? [] : s ? {} : void 0 }), { overwriteExisting: i, createIntermediates: a, recursive: d } = r;
  if (o.source && (o.source = fe(s) ? s.map(((h) => bs("source", h, i))).filter(((h) => h != null)) : bs("source", s, i)), typeof e == "object") {
    const h = bs("target", e, i);
    h && (o.target = h);
  }
  return o.target["repo:assetId"] == null && a != null && (o.intermediates = a), d != null && (o.recursive = d), Object.assign(o, n), Re("_OD() doc", o), o;
}
function qn(t, e, s, r, n, o, i) {
  if (E(["resources", r, "array", !1]), r.length <= Xr) {
    const a = Zr().copyResources(e, s, r, n, o).getDocument();
    return we(t).then(((d) => Ve(x(t), d, a, i, !0))).then(((d) => {
      const { asset: h, source: l, target: p, resources: _ } = d.response[0];
      return { result: { source: se(l), target: se(p), resources: _, asset: h ? se(h) : void 0 }, response: d };
    }));
  }
  return (function(a, d, h, l, p, _, f, m) {
    E(["resources", l, "array", !1]);
    const y = [];
    for (let D = 0; D < l.length; D += p) y.push(l.slice(D, D + p));
    let P;
    function I(D, O) {
      const N = Zr().copyResources(d, h, O, _, f).getDocument();
      return we(a).then(((M) => Ve(x(a), M, N, m, !0))).then(((M) => {
        P ? P.response[0].resources.push(...M.response[0].resources) : P = M;
        const { asset: Q, source: X, target: le, resources: be } = M.response[0], Oe = { source: se(X), target: se(le), resources: be, asset: Q ? se(Q) : void 0 };
        return Object.assign(Object.assign({}, Oe), { resources: [...D == null ? void 0 : D.resources, ...Oe.resources], asset: Oe.asset || D.asset });
      }));
    }
    let R = S.resolve({ resources: [], source: {}, target: {} });
    for (const D of y) R = R.then(((O) => I(O, D)));
    return R.then(((D) => {
      if (!P) throw new c(c.UNEXPECTED_RESPONSE, "No response received from copy resources operation");
      return { result: D, response: P };
    }));
  })(t, e, s, r, Xr, n, o, i);
}
var g;
(function(t) {
  t.NOT_INITIALIZED = "NOT_INITIALIZED", t.INITIALIZING = "INITIALIZING", t.INITIALIZED = "INITIALIZED", t.WAITING = "WAITING", t.STARTED = "STARTED", t.PAUSING = "PAUSING", t.PAUSED = "PAUSED", t.CANCELED = "CANCELED", t.ERROR = "ERROR", t.FINALIZING = "FINALIZING", t.COMPLETE = "COMPLETE";
})(g || (g = {}));
const ce = new class {
  constructor() {
    this._uploads = [], this._downloads = [], this._pendingUploadRequests = [], this._pendingDownloadRequests = [], this._downloadChunkSize = 10485760;
  }
  get downloads() {
    return this._downloads;
  }
  get uploads() {
    return this._uploads;
  }
  set downloadChunkSize(t) {
    E(["downloadChunkSize", t, "+number"]), this._downloadChunkSize = t;
  }
  get downloadChunkSize() {
    return this._downloadChunkSize;
  }
  get pendingUploadRequests() {
    return this._pendingUploadRequests;
  }
  get pendingDownloadRequests() {
    return this._pendingDownloadRequests;
  }
  resetUploads() {
    this._uploads = [], this._pendingUploadRequests = [];
  }
  addAndStartUpload(t) {
    return this._addAndStart("upload", t);
  }
  addAndStartDownload(t) {
    return t.state !== g.INITIALIZED ? Promise.resolve(t) : this._addAndStart("download", t);
  }
  startNextWaiting(t) {
    const e = t === "upload" ? this._uploads : this._downloads, s = [];
    let r = !1;
    for (const o of e) !r && o && o.state === g.WAITING ? (o.start(), r = !0) : o.state !== g.CANCELED && o.state !== g.ERROR && o.state !== g.FINALIZING && o.state !== g.COMPLETE || s.push(o);
    const n = e.filter(((o) => !s.includes(o)));
    t === "download" ? this._downloads = n : this._uploads = n;
  }
  _addAndStart(t, e) {
    const s = t === "upload" ? this._uploads : this._downloads;
    return s.filter(((r) => r && (r.state === g.NOT_INITIALIZED || r.state === g.INITIALIZED || r.state === g.INITIALIZING || r.state === g.STARTED))).length === 0 ? e.start() : e._setWaiting(), s.push(e), e.promise;
  }
}(), $ = B("dcx:assets:blockdownload"), rc = B("dcx:assets:blockdownload:leaf"), nc = (function* () {
  let t = 0;
  for (; ; ) yield t++;
})();
class oc extends zs {
  constructor(e, s, r = {}) {
    super(["stateChanged"]), this._state = g.NOT_INITIALIZED, this._cachedBlocks = /* @__PURE__ */ new Map(), this._blockRequestIndex = 0, this._blockHandledIndex = 0, this._currentByteRange = [void 0, void 0], this._pending = [], $("constructor");
    const { startByte: n, blockSize: o, endByte: i, url: a, totalSize: d, maxConcurrentRequests: h } = Object.assign({ blockSize: ce.downloadChunkSize, maxConcurrentRequests: 4 }, L(r));
    E(["svc", e, "object"], ["responseType", s, "enum", !1, ["buffer"]], ["blockSize", o, "+number"], ["url", a, "string", !0], ["startByte", n, "number", !0], ["endByte", i, "number", !0], ["totalSize", d, "number", !0], ["maxConcurrentRequests", h, "+number"]), this._dbgId = nc.next().value, this._maxConcurrentRequests = h, this._blockSize = Math.round(o), this._service = e, this._url = a, this._startByte = n, this._endByte = i, this._totalSize = d, this._bytes = new Uint8Array(), this._promise = new S(((l, p) => {
      this._resolve = () => {
        $(this._dbgId, "resolving"), this.removeAllHandlers(), l(this);
      }, this._reject = (_) => {
        $(this._dbgId, "rejecting: ", _), this.removeAllHandlers(), p(_);
      };
    }));
  }
  get contentType() {
    var e;
    return (e = this._contentType) !== null && e !== void 0 ? e : "";
  }
  get totalSize() {
    return this._totalSize;
  }
  get buffer() {
    return this._bytes;
  }
  get state() {
    return this._state;
  }
  get promise() {
    return this._promise;
  }
  _requestBlock(e, s, r, n) {
    $(this._dbgId, "_requestBlock(): ", e, s, r, n);
    const o = zn(e, s);
    return this._service.invoke(v.GET, this._url, o, void 0, { responseType: "defaultbuffer", isStatusValid: k(), isExternalRequest: !0 }).then(((i) => ({ response: i, index: r, lane: n }))).catch(this._handleErrorAndThrow.bind(this));
  }
  init(e = this._url, s = this._totalSize) {
    if ($(this._dbgId, "init(): ", e, s), this._state === g.INITIALIZED && e === this._url && s === this._totalSize) return S.resolve(this);
    if (this._assertStateIsValid("init"), this._shiftState(g.INITIALIZING), this._url = e, this._initByteRange(s), this._totalSize !== 1 / 0 || this._currentByteRange[0] == null) return this._shiftState(g.INITIALIZED), S.resolve(this);
    const { startByte: r, endByte: n, blockIndex: o } = this._nextBlockData();
    let i = g.INITIALIZED;
    return this._requestBlock(r, n, o, 0).then(((a) => (this._updateTotalSize(a), (!n || n > this._endByte) && (i = g.FINALIZING), a))).then(this._handleBlock.bind(this)).then((() => this._shiftState(i))).catch(this._handleErrorAndThrow.bind(this));
  }
  start() {
    if ($(this._dbgId, "start()"), this._assertStateIsValid("start"), this._shiftState(g.STARTED), this._currentByteRange[0] != null) return this._start(), this._promise;
    const [e, s] = this._currentByteRange, r = this._blockRequestIndex;
    return this._blockRequestIndex += 1, this._currentByteRange = [s + 1, s], this._requestBlock(e, s, r, 0).then(this._handleBlock.bind(this)).catch(this._handleError.bind(this)), this._promise;
  }
  pause() {
    return $(this._dbgId, "pause()"), this._assertStateIsValid("pause"), this._shiftState(g.PAUSING), S.allSettled(this._pending).then((() => (this._shiftState(g.PAUSED), ce.startNextWaiting("download"), this)));
  }
  resume() {
    return $(this._dbgId, "resume()"), this.state === g.PAUSED && (this._shiftState(g.STARTED), this._start()), this;
  }
  cancel() {
    return $(this._dbgId, "cancel()"), this._assertStateIsValid("cancel"), this._shiftState(g.CANCELED), this._reject(new c(c.ABORTED, "BlockDownload aborted.")), ce.startNextWaiting("download"), this._promise;
  }
  _setWaiting() {
    this._shiftState(g.WAITING);
  }
  _start() {
    $(this._dbgId, "_start()");
    for (let e = 0; e < this._maxConcurrentRequests; e++) this._loop(e).catch(this._handleError.bind(this));
  }
  get _loopShouldContinue() {
    const e = this._state === g.STARTED && this._currentByteRange[0] <= this._endByte;
    return $(this._dbgId, "_loopShouldContinue() ", e, this._currentByteRange, this._endByte), e;
  }
  _loop(e) {
    return ne(this, void 0, void 0, (function* () {
      $(this._dbgId, "_loop(): ", e);
      let s = !1;
      for (; this._loopShouldContinue && !s; ) {
        const { startByte: r, endByte: n, blockIndex: o, done: i } = this._nextBlockData();
        s = i;
        const a = this._requestBlock(r, n, o, e).then(this._handleBlock.bind(this)).catch(this._handleError.bind(this));
        this._pending[e] = a, yield a;
      }
      $(this._dbgId, `_loop(${e}) done, ${s}`), s && ($(this._dbgId, `_loop(${e}) finalize`), this._shiftState(g.FINALIZING));
    }));
  }
  _nextBlockData() {
    $(this._dbgId, "_nextBlockData()");
    const e = this._blockRequestIndex;
    this._blockRequestIndex += 1;
    const [s, r] = this._currentByteRange;
    return this._currentByteRange[0] += this._blockSize, this._currentByteRange[1] = Math.min(this._currentByteRange[1] + this._blockSize, this._endByte), { startByte: s, endByte: r, blockIndex: e, done: r >= this._endByte };
  }
  _initByteRange(e = this._totalSize) {
    if ($(this._dbgId, "_initByteRange(): ", e), this._totalSize = e, this._totalSize != null && this._totalSize < 0) throw new c(c.INVALID_PARAMS, "Total size must be positive.");
    if (this._totalSize || (this._totalSize = 1 / 0), this._endByte || (this._endByte = this._totalSize), !this._startByte && this._endByte === this._totalSize) return this._startByte = 0, void (this._currentByteRange = [0, this._blockSize - 1]);
    if (!this._startByte && this._endByte < 0 && this._totalSize !== 1 / 0 ? (this._startByte = Math.max(0, this._totalSize + this._endByte), this._endByte = this._totalSize) : !this._startByte && this._endByte > 0 && (this._startByte = 0), this._startByte != null && (this._currentByteRange[0] = Math.max(this._startByte, 0)), (this._endByte == null || this._endByte > 0) && (this._currentByteRange[1] = Math.min(this._endByte, (this._startByte || 0) + this._blockSize - 1)), this._startByte != null || this._endByte === 1 / 0) return;
    if (this._totalSize === 1 / 0) {
      if (-this._endByte > this._blockSize) throw new c(c.INVALID_PARAMS, "Cannot download last N bytes without a total size.");
      return void (this._currentByteRange = [void 0, this._endByte]);
    }
    this._startByte = Math.max(0, this._totalSize + this._endByte), this._endByte = this._totalSize;
    const s = Math.min(this._startByte + this._blockSize - 1, this._endByte);
    this._currentByteRange = [this._startByte, s];
  }
  _finalize() {
    return $(this._dbgId, "_finalize() start"), ce.startNextWaiting("download"), S.allSettled(this._pending).then((() => {
      this._checkCachedBlocks(), this._shiftState(g.COMPLETE);
    }));
  }
  _updateTotalSize(e) {
    if ($(this._dbgId, "_updateTotalSize()"), this._totalSize == null || this._totalSize === 1 / 0) try {
      const s = e.response.headers["content-range"], r = parseInt(s.split("/")[1]);
      fn((() => !isNaN(r)), "Invalid number."), this._totalSize = r, this._endByte === 1 / 0 && (this._endByte = this._totalSize);
    } catch (s) {
      throw new c(c.INVALID_DATA, "Could not determine total size.", s, e.response);
    }
    return $(this._dbgId, "_uTS(): ", this._totalSize, this._endByte), e;
  }
  _handleError(e) {
    $(this._dbgId, "_handleError(): ", e), this._shiftState(g.ERROR), this._error = e, dt(e) || (this._error = new c(c.UNEXPECTED, "An unexpected error occurred.", e)), this._reject(this._error);
  }
  _handleErrorAndThrow(e) {
    throw this._handleError(e), this._error;
  }
  _handleBlock(e) {
    this._endByte === 1 / 0 && this._updateTotalSize(e);
    const { index: s, response: r } = e;
    if ($(this._dbgId, `_handleBlock(${s})`), s !== this._blockHandledIndex) return $(this._dbgId, `_handleBlock(${s}) cached`), void this._cachedBlocks.set(s, e);
    $(this._dbgId, `_handleBlock(${s}) handled`), this._pushBlockData(r), this._markCurrentBlockHandled();
  }
  _markCurrentBlockHandled() {
    this._cachedBlocks.delete(this._blockHandledIndex), this._blockHandledIndex += 1, this._checkCachedBlocks();
  }
  _checkCachedBlocks() {
    const e = this._cachedBlocks.get(this._blockHandledIndex);
    e && this._handleBlock(e);
  }
  _pushBlockData(e) {
    if (this._state === g.ERROR) return;
    this._contentType = this._contentType || e.headers[b.CONTENT_TYPE];
    const s = typeof Buffer < "u" && e.response instanceof Buffer ? e.response : new Uint8Array(e.response);
    this._bytes = Ue(this._bytes, s);
  }
  _shiftState(e) {
    return $(this._dbgId, "_shiftState(): ", e), this._state === g.COMPLETE || this._state === g.ERROR || this._state === g.CANCELED || (this._state = e, this.emit("stateChanged", [this._state, this]), e === g.FINALIZING && this._finalize(), e === g.COMPLETE && Promise.all(this._pending).then(this._resolve.bind(this))), this;
  }
  _assertStateIsValid(e, s = this._state) {
    $(this._dbgId, "_assertStateIsValid() ", e, s);
    let r = !1;
    const n = "Invalid state transition.";
    switch (e) {
      case "init":
        s === g.NOT_INITIALIZED && (r = !0);
        break;
      case "start":
        s !== g.INITIALIZED && s !== g.WAITING && s !== g.STARTED || (r = !0);
        break;
      case "pause":
        s !== g.INITIALIZING && s !== g.STARTED || (r = !0);
        break;
      case "cancel":
        r = !0;
    }
    if (!r) throw $(this._dbgId, "_aSIV() throw ", n), new c(c.INVALID_STATE, n, void 0, void 0, { method: e, currentState: s });
  }
}
function ic(t, e, s) {
  return new oc(t, e, s);
}
function et(t, e, s, r, n = "defaultbuffer", o, i, a) {
  rc("_doBlockDownload()");
  const d = n === "stream" ? void 0 : ic(t, "buffer", { startByte: s, endByte: r });
  (this != null ? this : {}).blockDownload = d;
  let h = S.resolve(e, this !== void 0 ? this : {});
  return o || (h = h.then((() => t.invoke(v.GET, e, Object.assign({ priority: "u=1" }, a), void 0, { responseType: "text", isStatusValid: k(), retryOptions: { pollCodes: [202], pollHeader: "location", pollMethod: "GET" } }))).then(((l) => {
    const p = l.response.indexOf("href") > 0 ? Dr(l.response, '"href":\\s*"([^;"]*)"') : "";
    if (typeof p != "string" || p === "") throw new c(c.UNEXPECTED_RESPONSE, "No block download href found in response.", void 0, l);
    return i = i || parseInt(Dr(l.response, '"size":\\s*(\\d+)')), p;
  }))), h.then(((l) => ne(this, void 0, void 0, (function* () {
    return d ? Promise.race([d.init(l, i).then((() => ce.addAndStartDownload(d))), d.promise]).then((() => ({ statusCode: 200, headers: L({ [b.CONTENT_TYPE]: d.contentType, [b.CONTENT_LENGTH]: d.totalSize }), responseType: n, response: ac(d.buffer, n, d.contentType), message: "OK" }))) : t.invoke(v.GET, l, zn(s, r), void 0, { responseType: "stream", isExternalRequest: !0 });
  }))));
}
function ac(t, e, s) {
  if (e === "defaultbuffer" || e === "buffer" || e === "arraybuffer") return t.buffer;
  if (e === "blob") return new Blob([t], { type: s });
  const r = ve(t);
  if (e === "text") return r;
  try {
    return JSON.parse(r);
  } catch {
    return r;
  }
}
function zn(t, e) {
  return t == null && e == null ? {} : { range: `bytes=${t ?? (e != null && e > 0 ? "0" : "")}-${e != null ? Math.abs(e) : ""}` };
}
const $t = B("dcx:assets:private");
function dr(t, e, s, r, n = "defaultbuffer", o, i, a = {}, d = !1) {
  let h;
  $t("_getUrlFallbackDirect()");
  const l = this !== void 0 ? this : {};
  return S.resolve(void 0, l).then((() => t.invoke(v.GET, s, Object.assign({ priority: "u=1" }, a), void 0, { responseType: n, isStatusValid: k([400]) }))).then(((p) => ($t("_gUFD() status code", p.statusCode), h = p, p.statusCode === 400 && p.xhr ? p.xhr.getResponseDataAsJSON() : p))).then(((p) => {
    const _ = C(p) && (h.statusCode === 400 || p.status === 400) && p.type === Z.RESPONSE_TOO_LARGE;
    if ($t("_gUFD() do direct", _), !_ && h.statusCode === 400) throw new c(c.UNEXPECTED_RESPONSE, "Unexpected response", void 0, h);
    return _;
  })).then(((p) => {
    if (!p) return h;
    if (!("location" in h.headers) || typeof h.headers.location != "string" || "location" in h.headers && h.headers.location.includes("platform")) {
      if (!ht(e.links, [u.BLOCK_DOWNLOAD])) throw new c(c.INVALID_DATA, "Resource too large and missing download link.");
      const _ = L({ reltype: r, component_id: o, revision: i }), f = J(e.links, u.BLOCK_DOWNLOAD, { resource: r ? JSON.stringify(_) : void 0 });
      return d ? { statusCode: 200, headers: L({ [b.CONTENT_TYPE]: h.headers["content-type"], [b.CONTENT_LENGTH]: h.headers["content-length"] }), responseType: n, response: { href: f }, message: "OK" } : et.call(l, t, f, void 0, void 0, n, !1, void 0, a);
    }
    return d ? { statusCode: 200, headers: L({ [b.CONTENT_TYPE]: h.headers["content-type"], [b.CONTENT_LENGTH]: h.headers["content-length"] }), responseType: n, response: { href: h.headers.location }, message: "OK" } : et.call(l, t, h.headers.location, void 0, void 0, n, !0, void 0, a);
  }));
}
function Yt({ additionalHeaders: t = {}, asset: e, contentType: s, data: r, etag: n, headHref: o, href: i, maybeIsNew: a, relation: d, service: h }, l = !1) {
  if ($t("_doUpload()"), E(["service", h, "object"], ["asset", e, "object"], ["href", i, "string"], ["headHref", o, "string"], ["contentType", s, "string", !0], ["maybeIsNew", a, "boolean", !0], ["etag", n, "string", !0], ["isRetry", l, "boolean", !0], ["additionalHeaders", t, "object", !0]), a == null) return h.invoke(v.HEAD, o, t, void 0, { isStatusValid: k([404]) }).then(((_) => {
    const f = _.statusCode !== 200;
    return Yt({ additionalHeaders: t, asset: e, contentType: s, data: r, etag: n, headHref: o, href: i, maybeIsNew: f, relation: d, service: h }, l);
  }));
  const p = a;
  return p ? delete t[b.IF_MATCH] : t[b.IF_MATCH] = n || "*", s && (t[b.CONTENT_TYPE] = s), h.invoke(v.PUT, i, t, r, { isStatusValid: k([404, 409, 412]), retryOptions: { pollHeader: "location", pollCodes: [202] } }).then(((_) => {
    const f = _.statusCode;
    if (f > 400 && !l) {
      if (n != null) throw k()(f, _);
      if (!p && f === 404) return Yt({ additionalHeaders: t, asset: e, contentType: s, data: r, etag: n, headHref: o, href: i, maybeIsNew: !0, relation: d, service: h }, !0);
      if (f === 404) throw new c(c.NOT_FOUND, "Unexpected response", void 0, _);
      if (f === 409 || f === 412) return Yt({ additionalHeaders: t, asset: e, contentType: s, data: r, etag: n, headHref: o, href: i, maybeIsNew: void 0, relation: d, service: h }, !0);
    }
    return _;
  }));
}
const cc = B("dcx:assets:bulk");
function dc(t, e) {
  let r = Uint8Array.from([]);
  for (let n = 0; n < t.length; n++) {
    const o = t[n];
    r = Ue(r, Te(n === 0 ? `--${e}\r
` : `\r
--${e}\r
`)), r = Ue(r, Te(`${[b.CONTENT_TYPE]}: application/http\r
`)), r = Ue(r, Te(`\r
${o.method} ${o.href}`));
    let i = !1;
    for (const a in o.headers) {
      const d = a.toLowerCase();
      d === "content-length" && (i = !0), r = Ue(r, Te(`\r
${d}: ${o.headers[a]}`));
    }
    if (o.body) {
      const a = hc(o.body);
      i || (r = Ue(r, Te(`\r
content-length: ${a.length}`))), r = Ue(r, Te(`\r
\r
`)), r = Ue(r, a);
    }
  }
  return r = Ue(r, Te(`\r
--${e}--\r
`)), r;
}
function hc(t) {
  if (typeof t == "string") return Te(t);
  if (qo(t)) return new Uint8Array(t);
  if (Pn(t)) return t;
  throw new c(c.INVALID_PARAMS, "Bulk subrequest body expecting string | ArrayBuffer | Buffer");
}
function hr(t, e) {
  const s = t.headers[b.CONTENT_TYPE];
  if (!s) throw new c(c.UNEXPECTED_RESPONSE, "Missing boundary header in multipart response");
  const r = s.split("=")[1], n = (function(o, i) {
    const a = new Uint8Array(o), d = Te(`--${i}`);
    return Wn(a, js(a, d), d.byteLength).map(((l) => is(l, !0)));
  })(t.response, r);
  if (e && n.length !== e) throw new c(c.UNEXPECTED_RESPONSE, `Unexpected number of parts; Expected ${e}, Received ${n.length}`);
  return n;
}
function js(t, e) {
  const s = new Array(256).fill(-1), r = [];
  for (let o = 0; o < e.length; o++) s[e[o]] = o;
  let n = 0;
  for (; n <= t.length - e.length; ) {
    let o = e.length - 1;
    for (; o >= 0 && e[o] === t[n + o]; ) o--;
    o < 0 ? (r.push(n), n += n + e.length < t.length ? e.length - s[t[n + e.length]] : 1) : n += Math.max(1, o - s[t[n + o]]);
  }
  return r;
}
function Wn(t, e, s, r = !1) {
  let n = r ? 0 : void 0;
  const o = [];
  for (const i of e) n !== void 0 && o.push(t.subarray(n, i)), n = i + s;
  return r && o.push(t.subarray(n)), o;
}
function is(t, e = !1) {
  const s = Te(`\r
\r
`), r = js(t, s).slice(0, 2), n = Te(`

`), o = Wn(t, ...r.length > 0 ? [r, s.byteLength] : [js(t, n).slice(0, 2), n.byteLength], !0), i = o.slice(0, e || o.length > 1 ? 2 : 1).reduce(((p, _) => Object.assign(p, Ws(ve(_)))), {}), a = o.length > 1 ? o[o.length - 1] : void 0, d = parseInt(ve(o[e ? 1 : 0]).split(`\r
`, 1)[0].split(" ")[1]), h = parseInt(i["content-length"], 10);
  let l;
  return l = isNaN(h) ? (a == null ? void 0 : a.length) === 0 ? new Uint8Array([]) : a : h === 0 ? new Uint8Array([]) : a == null ? void 0 : a.subarray(0, h), { headers: i, response: i[b.CONTENT_TYPE] === Bs && l !== void 0 ? JSON.parse(ve(l)) : l, statusCode: d };
}
function lc(t) {
  if (t.length > 10) throw new c(c.INVALID_PARAMS, "A single bulk request can only contain a maximum of 10 sub-requests.");
  const { writeOperations: e, readOperations: s } = t.reduce(((r, n) => {
    if (typeof n.href != "string") throw new c(c.INVALID_PARAMS, "A sub-request of the bulk operation is missing an href");
    if (typeof n.method != "string") throw new c(c.INVALID_PARAMS, "A sub-request of the bulk operation is missing the HTTP method");
    const o = n.method.toUpperCase();
    if (!Object.values(v).includes(o)) throw new c(c.INVALID_PARAMS, "A sub-request of the bulk operation includes an invalid HTTP method");
    return [v.GET, v.HEAD].includes(o) ? r.readOperations.push(n) : r.writeOperations.push(n), r;
  }), { readOperations: [], writeOperations: [] });
  if (e.length > 0 && s.length > 0) throw new c(c.INVALID_PARAMS, "Cannot mix READ and WRITE operations in bulk sub requests.");
}
function as(t, e, s, r = "id", n = {}, o = !1) {
  return cc("performBulkRequest()"), E(["svc", t, "object"], ["asset", e, "object"], ["requests", s, "array"], ["linkMode", r, "string", !0, ["id", "path"]]), V(e.links, [u.BULK_REQUEST]), lc(s), Kn(t, e, s, r, n).then((({ response: i, subresponses: a }) => ne(this, void 0, void 0, (function* () {
    const d = Xn(a, s);
    return { result: o ? yield Zn(t, e, d, r, n, a) : a, response: i };
  }))));
}
function Kn(t, e, s, r = "id", n = {}) {
  const o = `boundary-${Date.now()}`, i = dc(s, o), a = Object.assign(Object.assign({}, n), { [b.CONTENT_TYPE]: `multipart/mixed;boundary=${o}` }), d = H(e.links, u.BULK_REQUEST, r);
  return t.invoke(v.POST, d, a, i, { isStatusValid: k(), responseType: "defaultbuffer", retryOptions: { pollHeader: "location", pollCodes: [202], pollMethod: v.GET } }).then(((h) => ({ response: h, subresponses: hr(h, s.length) })));
}
function Xn(t, e) {
  return t.filter((({ statusCode: s }) => ot(s))).map(((s) => e.find((({ href: r }) => r === s.headers["content-id"])))).filter(((s) => s));
}
function Zn(t, e, s, r = "id", n = {}, o, i = 5) {
  return ne(this, void 0, void 0, (function* () {
    if (s.length === 0 || i <= 0) return o;
    if (s.length === 1) {
      const [d] = s, h = yield x(t).invoke(d.method, d.href, d.headers, d.body, { isStatusValid: k(), responseType: "defaultbuffer", retryOptions: { pollHeader: "location", pollCodes: [202], pollMethod: v.GET } });
      return h.headers["content-id"] = d.href, o.map(((l) => "content-id" in l.headers && l.headers["content-id"] === h.headers["content-id"] ? h : l));
    }
    const a = yield Kn(t, e, s, r, n).then(((d) => ne(this, void 0, void 0, (function* () {
      const h = Xn(d.subresponses, s);
      return h.length ? yield Zn(t, e, h, r, n, d.subresponses, i - 1) : d.subresponses;
    }))));
    return o.map(((d) => a.find(((h) => h.headers["content-id"] === d.headers["content-id"])) || d));
  }));
}
const F = B("dcx:assets:asset"), G = B("dcx:assets:asset:leaf");
class bt {
  constructor(e, s, r = {}) {
    this.type = Ye.Asset, this._data = {}, this._data = se(e), this._svc = x(s), this._cache = oe(s), this._links = de({}, e.links || {}, e._links || {}, r);
  }
  setLinks(e) {
    this._links = e, this._updateCachedLinks();
  }
  get links() {
    return this._links;
  }
  set links(e) {
    this.setLinks(e);
  }
  setLink(e, s) {
    this._links[e] = s, this._updateCachedLinks();
  }
  getLink(e) {
    return this._links[e];
  }
  removeLink(e) {
    delete this._links[e], this._updateCachedLinks();
  }
  _updateCachedLinks() {
    this._cache && this._cache.setValueWithAsset(this.links, this.asset);
  }
  getLinkProperty(e, s, r = "id") {
    return F("getLinkProperty()"), ts({ _links: this._links }, e, s, r);
  }
  getLinkHrefTemplated(e, s, r = "id") {
    return F("getLinkHrefTemplated()"), J({ _links: this._links }, e, s, r);
  }
  getLinkHref(e, s = "id") {
    return F("getLinkHref()"), H({ _links: this._links }, e, s);
  }
  get asset() {
    return Object.assign(Object.assign({}, this._data), this.links);
  }
  get serviceConfig() {
    return { service: this._svc, cache: this._cache };
  }
  get repositoryId() {
    return this._data.repositoryId;
  }
  set repositoryId(e) {
    this._data.repositoryId = e;
  }
  get assetId() {
    return this._data.assetId;
  }
  set assetId(e) {
    this._data.assetId = e;
  }
  get path() {
    return this._data.path;
  }
  set path(e) {
    this._data.path = e;
  }
  get name() {
    return this._data.name;
  }
  get etag() {
    return this._data.etag;
  }
  set etag(e) {
    this._data.etag = e;
  }
  get version() {
    return this._data.version;
  }
  set version(e) {
    this._data.version = e;
  }
  get format() {
    return this._data.format;
  }
  set format(e) {
    this._data.format = e;
  }
  get assetClass() {
    return this._data.assetClass;
  }
  get createDate() {
    return this._data.createDate;
  }
  get modifyDate() {
    return this._data.modifyDate;
  }
  get discardDate() {
    return this._data.discardDate;
  }
  get createdBy() {
    return this._data.createdBy;
  }
  get modifiedBy() {
    return this._data.modifiedBy;
  }
  get discardedBy() {
    return this._data.discardedBy;
  }
  get deviceCreateDate() {
    return this._data.deviceCreateDate;
  }
  get deviceModifyDate() {
    return this._data.deviceModifyDate;
  }
  get baseAssetId() {
    return this._data.baseAssetId;
  }
  set baseAssetId(e) {
    this._data.baseAssetId = e;
  }
  get state() {
    return this._data.state;
  }
  get size() {
    return this._data.size;
  }
  set size(e) {
    this._data.size = e;
  }
  get md5() {
    return this._data.md5;
  }
  set defaultScheduledDeletionDuration(e) {
    this._data.defaultScheduledDeletionDuration = e;
  }
  get defaultScheduledDeletionDuration() {
    return this._data.defaultScheduledDeletionDuration;
  }
  set scheduledDeletionDate(e) {
    this._data.scheduledDeletionDate = e;
  }
  get scheduledDeletionDate() {
    return this._data.scheduledDeletionDate;
  }
  get assetType() {
    return this._data.assetType;
  }
  set assetType(e) {
    this._data.assetType = e;
  }
  get assetSubType() {
    return this._data.assetSubType;
  }
  set assetSubType(e) {
    this._data.assetSubType = e;
  }
  get representations() {
    return this._data.representations;
  }
  get contributors() {
    return this._data.contributors;
  }
  get les() {
    return this._data.les;
  }
  set width(e) {
    this._data.width = e;
  }
  get width() {
    return this._data.width;
  }
  set length(e) {
    this._data.length = e;
  }
  get length() {
    return this._data.length;
  }
  fetchLinksIfMissing(e = [], s) {
    return F("fetchLinksIfMissing()"), fo(this.serviceConfig, this, e, void 0, s).then((({ result: r, response: n }) => (this._updateDataWithResponse(n), this)));
  }
  useLinkOrResolveResource(e, s) {
    return F("useLinkOrResolveResource()"), _o(this.serviceConfig, this, e, s).then(((r) => (this._updateDataWithResponse(r.response), this.setLinks(de(this.links, r.result.links)), r)));
  }
  headPrimaryResource(e) {
    return F("headPrimaryResource()"), this.fetchLinksIfMissing([u.PRIMARY], e).then((() => Qn(this.serviceConfig, this, e))).then(((s) => (this._updateDataWithResponse(s), s)));
  }
  getRepresentation(e) {
    return this._data.representations ? this._data.representations[e] : void 0;
  }
  getRepoMetadata() {
    return F("getRepoMetadata()"), this.useLinkOrResolveResource(u.REPO_METADATA, "json").then(((e) => {
      this._data = de(this._data, e.result, se(e.response.response));
      const s = e.response.response;
      return s && s._links && this.setLinks(de(this.links, s._links)), { result: this._data, response: e.response };
    }));
  }
  updateRepoMetadata(e) {
    return F("updateRepoMetadata()"), this.fetchLinksIfMissing([u.REPO_METADATA], e).then((() => so(this._svc, this, e)));
  }
  headAppMetadata(e) {
    return F("headAppMetadata()"), this.fetchLinksIfMissing([u.APP_METADATA], e).then((() => no(this.serviceConfig, this)));
  }
  getAppMetadata(e, s) {
    return F("getAppMetadata()"), E(["etag", e, "string", !0]), this.fetchLinksIfMissing([u.APP_METADATA], s).then((() => oo(this._svc, this, e, s)));
  }
  putAppMetadata(e, s, r) {
    return F("putAppMetadata()"), E(["etag", s, "string", !0], ["metadata", e, ["object", "string"]]), this.fetchLinksIfMissing([u.APP_METADATA], r).then((() => io(this._svc, this, e, s, r)));
  }
  patchAppMetadata(e, s, r) {
    return F("patchAppMetadata()"), E(["patchDoc", e, ["string", "object[]"]], ["etag", s, "string"]), this.fetchLinksIfMissing([u.APP_METADATA], r).then((() => ao(this._svc, this, e, s, r)));
  }
  getBaseDirectoryMetadata() {
    return F("getBaseDirectoryMetadata()"), Tc(this._svc);
  }
  getLinks(e) {
    return F("getLinks()"), C(this.links) && Object.keys(this.links).length > 0 ? S.resolve(this.links) : to(this._svc, this, e).then(((s) => (this.setLinks(s), s)));
  }
  getRepositoryResource(e) {
    return F("getRepositoryResource()"), this.fetchLinksIfMissing([u.REPOSITORY], e).then((() => ro(this._svc, this, e))).then(((s) => (this.repositoryId = s.result["repo:repositoryId"], s)));
  }
  getEffectivePrivileges(e) {
    return F("getEffectivePrivileges()"), this.fetchLinksIfMissing([u.EFFECTIVE_PRIVILAGES], e).then((() => co(this._svc, this)));
  }
  performBulkRequest(e, s, r) {
    return F("performBulkRequest()"), E(["requests", e, "array"], ["linkMode", s, "string", !0, ["id", "path"]]), this.fetchLinksIfMissing([u.BULK_REQUEST], r).then((() => as(this._svc, this, e, s, r)));
  }
  getACLPolicy(e) {
    return F("getACLPolicy()"), this.fetchLinksIfMissing([u.ACL_POLICY], e).then((() => ho(this._svc, this)));
  }
  checkACLPrivilege(e, s, r) {
    return F("checkACLPrivilege()"), E(["privilege", e, "string"], ["relation", s, "string"]), this.fetchLinksIfMissing([u.ACCESS_CHECK], r).then((() => lo(this._svc, this, e, s)));
  }
  patchACLPolicy(e, s, r) {
    return F("patchACLPolicy()"), E(["policy", e, ["string", "object"]]), this.fetchLinksIfMissing([u.ACL_POLICY], r).then((() => uo(this._svc, this, e, s)));
  }
  deleteACLPolicy(e) {
    return F("deleteACLPolicy()"), this.fetchLinksIfMissing([u.ACL_POLICY], e).then((() => po(this._svc, this)));
  }
  getPrimaryResource(e, s) {
    F("getPrimaryResource()"), E(["responseType", e, "string"]);
    const r = {};
    return this._withSourcePromise(r).then((() => this.fetchLinksIfMissing([u.PRIMARY], s))).then((() => Jn.call(r, this._svc, this, e, s)));
  }
  copy(e, s, r, n, o, i) {
    return F("copy()"), E(["destination", e, ["object", "string"]], ["createIntermediates", s, "boolean"], ["overwriteExisting", r, "boolean"], ["manifestPatch", o, ["object", "string"], !0]), jn(this.serviceConfig, { repositoryId: this.repositoryId, assetId: this.assetId, path: this.path }, e, s, r, n, o, i).then((({ response: a, result: d }) => ({ response: a, result: new bt(d, this.serviceConfig) })));
  }
  copyResources(e, s, r, n, o) {
    return F("copyResources()"), E(["targetAsset", e, "object"], ["resources", s, "array"], ["manifestPatch", n, ["object", "string"], !0], ["intermediates", r, "boolean", !0]), qn(this.serviceConfig, { repositoryId: this.repositoryId, assetId: this.assetId, path: this.path, version: this.version }, e, s, r, n, o);
  }
  move(e, s, r, n, o) {
    return F("move()"), E(["destination", e, ["object", "string"]], ["createIntermediates", s, "boolean"], ["overwriteExisting", r, "boolean"]), Vn(this.serviceConfig, { repositoryId: this.repositoryId, assetId: this.assetId, path: this.path }, e, s, r, n, o).then((({ response: i, result: a }) => (this._data = Object.assign(Object.assign({}, this._data), L(a)), { response: i, result: this })));
  }
  delete(e, s = !1, r) {
    return F("delete()"), E(["etag", e, "string", !0], ["recursive", s, "boolean"]), Hn(this.serviceConfig, { repositoryId: this.repositoryId, assetId: this.assetId, path: this.path }, e, s, r).then(((n) => (this._data.state = "DELETED", n)));
  }
  discard(e, s = !1, r) {
    return F("discard()"), E(["etag", e, "string", !0], ["recursive", s, "boolean"]), Fn(this.serviceConfig, { repositoryId: this.repositoryId, assetId: this.assetId, path: this.path }, e, s, r).then(((n) => (this._data.state = "DISCARDED", n)));
  }
  package(e, s, r, n) {
    return F("package()"), E(["destination", e, ["object", "string"]], ["createIntermediates", s, "boolean"], ["overwriteExisting", r, "boolean"]), $n(this._svc, { repositoryId: this.repositoryId, assetId: this.assetId, path: this.path }, e, s, r, n);
  }
  restore(e, s) {
    return F("restore()"), Gn(this._svc, { repositoryId: this.repositoryId, assetId: this.assetId }, e, s).then((({ response: r, result: n }) => (this._data = Object.assign(Object.assign(Object.assign({}, this._data), L(n)), { state: "ACTIVE" }), { response: r, result: this })));
  }
  _updateDataWithResponse(e) {
    return e && (this._data.etag = e.headers.etag || this._data.etag, this._data.version = e.headers.version || this._data.version, this._data.assetId = e.headers["asset-id"] || this._data.assetId, this._data.md5 = e.headers["content-md5"] || this._data.md5, this._data.repositoryId = e.headers["repository-id"] || this._data.repositoryId, e);
  }
  _withSourcePromise(e) {
    return S.resolve(void 0, e);
  }
}
function Jn(t, e, s, r) {
  F("getPrimaryResource()"), E(["svc", t, "object"], ["asset", e, "object"], ["responseType", s, "enum", !0, nr]), V(e.links, [u.PRIMARY]);
  const n = H(e.links, u.PRIMARY);
  return dr.call({}, t, e, n, u.PRIMARY, s, void 0, void 0, r);
}
function Qn(t, e, s) {
  F("headPrimaryResource()"), E(["svc", t, "object"], ["asset", e, "object"]), V(e.links, [u.PRIMARY]);
  const r = H(e.links, u.PRIMARY);
  return x(t).invoke(v.HEAD, r, s, void 0, { isStatusValid: k() }).then(((n) => {
    const o = he(n);
    e.links = de(e.links || {}, o);
    const i = oe(t);
    return i && i.setValueWithAsset(e.links || {}, e), n;
  }));
}
const uc = "/content/directory/resolve{?repositoryId,id,resource,mode}", pc = "/content/directory/resolve{?repositoryId,path,resource,mode}";
function _c(t, e, s = "id", r, n) {
  G("getResolveLinkForAsset()"), E(["svc", t, "object"], ["asset", e, "object"], ["mode", s, "enum", !1, ["id", "path"]], ["resource", r, ["string", "object"], !0]), Ln(e);
  const o = { repositoryId: e.repositoryId, id: e.assetId, path: e.path, mode: s, resource: C(r) ? JSON.stringify(r) : r }, i = x(t), a = ze(e.assetId ? uc : pc, i);
  return S.resolve(Fe(a, L(o)));
}
const fc = "/content/create/~/:create{?path,mode,intermediates,respondWith,nameConflictPolicy,repoMetaPatch*}", Ec = "/content/create/~/:block_upload";
function lr(t, e, s = "id", r, n, o) {
  G("resolveAsset()"), E(["svc", t, "object"], ["asset", e, "object"], ["mode", s, "enum", !0, ["id", "path"]], ["resource", r, ["string", "object"], !0]), Ln(e);
  const i = x(t), a = oe(t), d = a && e.assetId && e.repositoryId && s === "id";
  return d && (G("rA() set pending"), a.setPending(e.assetId, e.repositoryId)), _c(t, e, s, r).then(((h) => r == null ? or(i, h, o) : Za(i, h, o, n))).then(((h) => ({ response: h, result: go(e, h, s === "id", a) }))).catch(((h) => {
    throw d && a.deleteWithAsset(e), h;
  }));
}
function gc(t, e, s) {
  return G("fetchLinksForAsset()"), eo(t, e, s).then(((r) => r.result.links));
}
function eo(t, e, s) {
  if (G("fetchAsset()"), E(["svc", t, "object"], ["asset", e, "object"]), sr(e)) return lr(t, e, "id", void 0, void 0, s).then(((a) => a));
  let r;
  try {
    r = Dn(e.links, [u.ID, u.REPO_METADATA, u.PRIMARY, u.PATH]);
  } catch (a) {
    throw new c(c.INVALID_PARAMS, "Asset is not resolvable. Must contain repositoryId & path, assetId, or links.", a);
  }
  const n = H(e.links, r), o = x(t), i = oe(t);
  return o.invoke(v.HEAD, n, s, void 0, { isStatusValid: k() }).then(((a) => ({ result: go(e, a, r === u.ID, i), response: a })));
}
function to(t, e, s) {
  G("getLinksForAsset()"), E(["svc", t, "object"], ["asset", e, "object"]);
  const r = e.links || e[T.LINKS];
  if (C(r) && Object.keys(r).length !== 0) return S.resolve(r);
  const n = oe(t);
  if (n) {
    const o = n.getValueWithAsset(e);
    if (o) return S.resolve(o);
  }
  return gc(t, e, s);
}
function Ic(t, e, s) {
  G("getRepoMetadata()"), E(["svc", t, "object"], ["asset", e, "object"]), V(e.links, [u.REPO_METADATA]);
  const r = H(e.links, u.REPO_METADATA);
  return t.invoke(v.GET, r, s, void 0, { responseType: "json", isStatusValid: k() }).then(((n) => {
    const o = he(n), i = n.response;
    return i[T.LINKS] = de({}, i[T.LINKS], o), { result: i, response: n };
  }));
}
function so(t, e, s) {
  G("updateRepoMetadata()"), E(["svc", t, "object"], ["asset", e, "object"]), V(e.links, [u.REPO_METADATA]);
  const r = H(e.links, u.REPO_METADATA), n = Object.assign({ [b.CONTENT_TYPE]: lt }, s), o = Ja(e);
  return t.invoke(v.PATCH, r, n, JSON.stringify(o), { responseType: "json", isStatusValid: k() }).then(((i) => ({ result: i.response, response: i })));
}
function Tc(t, e) {
  throw G("getBaseDirectoryMetadata()"), new c(c.NOT_IMPLEMENTED, "Method not implemented.");
}
function ro(t, e, s) {
  G("getRepositoryResource()"), E(["svc", t, "object"], ["asset", e, "object"]), V(e.links, [u.REPOSITORY]);
  const r = H(e.links, u.REPOSITORY);
  return t.invoke(v.GET, r, s, void 0, { responseType: "json", isStatusValid: k() }).then(((n) => ({ result: n.response, response: n })));
}
function no(t, e, s) {
  F("headAppMetadata()"), E(["svc", t, "object"], ["asset", e, "object"]), V(e.links, [u.APP_METADATA]);
  const r = H(e.links, u.APP_METADATA);
  return x(t).invoke(v.HEAD, r, s, void 0, { isStatusValid: k() }).then(((n) => {
    const o = he(n);
    e.links = de(e.links || {}, o);
    const i = oe(t);
    return i && i.setValueWithAsset(e.links, e), n;
  }));
}
function oo(t, e, s, r = {}) {
  G("getAppMetadata()"), E(["svc", t, "object"], ["asset", e, "object"], ["etag", s, "string", !0]);
  const n = H(e.links, u.APP_METADATA), o = Object.assign({}, r);
  return s && (o[b.IF_NONE_MATCH] = s), t.invoke(v.GET, n, o, void 0, { responseType: "json", isStatusValid: k([304]) }).then(((i) => {
    let a = i.response, d = i.headers.etag;
    return i.statusCode === 304 && (a = null, d = s), { result: a, response: i, etag: d };
  }));
}
function io(t, e, s, r, n = {}) {
  G("putAppMetadata()"), E(["svc", t, "object"], ["asset", e, "object"], ["metadata", s, ["object", "string"]], ["etag", r, "string", !0]), V(e.links, [u.APP_METADATA]);
  const o = H(e.links, u.APP_METADATA);
  return t.invoke(v.PUT, o, L(Object.assign(n, { [b.IF_MATCH]: r, [b.CONTENT_TYPE]: qa })), typeof s == "string" ? s : JSON.stringify(s), { isStatusValid: k() }).then(((i) => ({ response: i, result: { etag: i.headers.etag } })));
}
function ao(t, e, s, r, n = {}) {
  G("patchAppMetadata()"), E(["svc", t, "object"], ["asset", e, "object"], ["metadata", s, ["object[]", "string"]], ["etag", r, "string"]), V(e.links, [u.APP_METADATA]);
  const o = H(e.links, u.APP_METADATA);
  return t.invoke(v.PATCH, o, L(Object.assign(n, { [b.IF_MATCH]: r, [b.CONTENT_TYPE]: lt })), typeof s == "string" ? s : JSON.stringify(s), { isStatusValid: k() }).then(((i) => ({ response: i, result: { etag: i.headers.etag } })));
}
function co(t, e, s) {
  G("getEffectivePrivileges()"), E(["svc", t, "object"], ["asset", e, "object"]), V(e.links, [u.EFFECTIVE_PRIVILAGES]);
  const r = H(e.links, u.EFFECTIVE_PRIVILAGES);
  return t.invoke(v.GET, r, s, void 0, { responseType: "json", isStatusValid: k() }).then(((n) => ({ result: n.response, response: n })));
}
function ho(t, e, s) {
  G("getACLPolicy()"), E(["svc", t, "object"], ["asset", e, "object"]), V(e.links, [u.ACL_POLICY]);
  const r = H(e.links, u.ACL_POLICY);
  return t.invoke(v.GET, r, s, void 0, { responseType: "json", isStatusValid: k() }).then(((n) => ({ result: n.response, response: n })));
}
function lo(t, e, s, r, n = {}) {
  G("checkACLPrivilege()"), E(["svc", t, "object"], ["asset", e, "object"], ["privilege", s, "string", !1, ["ack", "read", "write", "delete"]]), V(e.links, [u.ACCESS_CHECK]);
  const o = J(e.links, u.ACCESS_CHECK, { privilege: s.toString(), relation: r });
  return t.invoke(v.GET, o, Object.assign({ directive: "acl-check-no-body" }, n), void 0, { responseType: "json", isStatusValid: k([403]) }).then(((i) => ({ result: i.statusCode !== 403, response: i })));
}
function uo(t, e, s, r, n = {}) {
  G("patchACLPolicy()"), E(["svc", t, "object"], ["asset", e, "object"], ["policy", s, ["string", "object"]], ["etag", r, "string", !0]), V(e.links, [u.ACL_POLICY]);
  const o = L(Object.assign(n, { [b.CONTENT_TYPE]: lt, [b.IF_MATCH]: r })), i = H(e.links, u.ACL_POLICY);
  return x(t).invoke(v.PATCH, i, o, typeof s == "string" ? s : JSON.stringify(s), { responseType: "json", isStatusValid: k() }).then(((a) => ({ result: a.response, response: a })));
}
function po(t, e, s = {}) {
  G("deleteACLPolicy()"), E(["svc", t, "object"], ["asset", e, "object"]), V(e.links, [u.ACL_POLICY]);
  const r = H(e.links, u.ACL_POLICY);
  return x(t).invoke(v.DELETE, r, s, void 0, { responseType: "json", isStatusValid: k() }).then(((n) => ({ result: n.response, response: n })));
}
function _o(t, e, s, r, n) {
  G("useLinkOrResolveResource()"), E(["svc", t, "object"], ["asset", e, "object"], ["resource", s, "string"]);
  const o = x(t);
  let i;
  try {
    i = H(e.links, s);
  } catch {
  }
  return S.resolve(i).then(((a) => {
    if (typeof a == "string") return G("uLORR() asset has link"), a;
    const d = oe(t);
    return Eo(e, d, [s]);
  })).then(((a) => {
    if (typeof a == "string") return a;
    try {
      return H(a, s);
    } catch {
      return;
    }
  })).then(((a) => {
    if (typeof a == "string") return G("uLORR() cache or asset had link"), o.invoke(v.GET, a, n, void 0, { isStatusValid: k(), responseType: r });
    if (!sr(e)) throw new c(c.INVALID_PARAMS, "Asset is not resolvable. Must contain repository ID + path/id or links.");
    return lr(t, e, "id", s, r, n);
  })).then(((a) => On(a) ? a : { result: e, response: a }));
}
function ut(t, e, s = [], r = !1, n) {
  return fo(t, e, s, r, n).then((({ result: o }) => o));
}
const Ac = /* @__PURE__ */ new Set([u.BASE_DIRECTORY, u.RESOLVE_BY_ID, u.RESOLVE_BY_PATH, u.REPO_OPS, u.REPOSITORY, u.DIRECTORY, u.DISCARD, u.RESTORE, u.PATH, u.ANNOTATIONS]), mc = "/links{?assetId,repositoryId,clientRegion}";
function yc(t, e, s) {
  const r = (function(n, o) {
    G("getLinksAPIUrlForAsset()"), E(["svc", n, "object"], ["asset", o, "object"]);
    const i = x(n), a = ze(mc, i), { assetId: d, repositoryId: h, contentRegion: l } = o, p = L({ assetId: d, repositoryId: h, contentRegion: l });
    return Fe(a, p);
  })(t, e);
  return x(t).invoke(v.GET, r, s, void 0, { responseType: "json" }).then(((n) => {
    const o = oe(t);
    return e.links = Object.assign({}, e.links, n.response._links), o == null || o.setValueWithAsset(e.links, e), { response: n, result: e };
  }));
}
function fo(t, e, s = [], r = !1, n) {
  if (G("fetchLinksIfMissing()", s), E(["svc", t, "object"], ["asset", e, "object"], ["linksToPopulate", s, "string[]"], ["suppressMissingErrors", r, "boolean", !0]), ht(e.links, s)) return G("fLIM() links exist"), S.resolve({ result: e.links });
  const o = oe(t);
  return Eo(e, o, s, !0).then(((i) => i || ((function(a, d) {
    return typeof a.assetId == "string" && a.assetId.length > 0 && d.every(((h) => !Ac.has(h)));
  })(e, s) ? yc(t, e, n) : (G("fLIM() fetching links"), eo(t, e, n))))).then(((i) => {
    let a, d, h = i;
    if (On(i) && (a = i.response, h = i.result.links, d = i.result), e.links !== h) {
      e.links = de(e.links || {}, h);
      const l = oe(t);
      l && l.setValueWithAsset(e.links, e);
    }
    if (!r && !ht(h, s)) throw new c(c.INVALID_PARAMS, "Required links could not be fetched for asset.", void 0, a, L({ required: s, asset: d }));
    return G("fLIM() fetchedOCached exists"), { result: h || e.links, response: a };
  }));
}
function Eo(t, e, s, r) {
  if (G("getLinksFromCache()"), !e) return S.resolve(void 0);
  const n = e.getValueWithAsset(t);
  return n == null ? (r && e.setPending(t.assetId, t.repositoryId), S.resolve(void 0)) : S.resolve(n).then(((o) => s ? ht(o, s) ? o : void (r && e.setPending(t.assetId, t.repositoryId)) : o));
}
function vc(t, e, s, r, n, o, i) {
  return qn(t, e, s, r, n, o, i);
}
function go(t, e, s, r) {
  const n = he(e), o = Object.assign(Object.assign(Object.assign({}, (function(i) {
    return C(i.asset) ? i.asset : i;
  })(t)), L({ assetId: e.headers["asset-id"] || e.headers["x-resource-id"], format: e.headers[b.CONTENT_TYPE], md5: e.headers["content-md5"], etag: e.headers.etag, version: e.headers.version, repositoryId: e.headers["repository-id"] })), { links: n });
  return s && n && Object.keys(n).length > 0 && r && r.setValueWithAsset(n, o), o;
}
B("dcx:assets:block_transfer");
const cs = 10485760, bc = 52428800, Rc = cs / 4;
let Io = bc;
function ur(t, e) {
  const s = (function(n) {
    return To(n, j.REPO_MIN_BLOCK_TRANSFER_SIZE);
  })(t);
  if (s && e < s) return !1;
  const r = Oc(t);
  return !!(r && e > r) || e > cs;
}
function To(t, e) {
  if (!ht(t.links, [u.BLOCK_UPLOAD_INIT])) return;
  const s = ts(t.links, u.BLOCK_UPLOAD_INIT, e);
  return s ? parseInt(s) : void 0;
}
function Oc(t) {
  return To(t, j.MAX_SINGLE_TRANSFER_SIZE);
}
const Be = (t) => typeof t == "string" ? t.length >= Rc ? Te(t).byteLength : t.length : "size" in t ? t.size : t.byteLength, Je = (t, e) => {
  if (!Y(t)) return t;
  if (t.length < 2) throw new c(c.INVALID_PARAMS, "GetSliceCallback is expected to accept 2 parameters");
  if (e === void 0 || isNaN(e) || e < 0) throw new c(c.INVALID_PARAMS, "Size parameter should indicate total number of bytes to be read from GetSliceCallback");
  return { getSlice: t, size: e };
}, Ao = () => Io, Pc = (t) => {
  if (Number.isNaN(t) || typeof t != "number" || t <= 0) throw new c(c.INVALID_PARAMS, "Invalid block download threshold, must be positive integer");
  Io = t;
};
function Cc(t, e, s, r) {
  const n = Ws(r);
  return { id: e, length: s, type: t, links: ar(n.link), etag: n.etag, location: n.location, version: n.version, revision: n.revision, md5: n["content-md5"] };
}
const w = B("dcx:assets:blockupload"), Sc = B("dcx:assets:blockupload:leaf");
class Nc extends zs {
  constructor(e, s, r, n, o, i, a, d, h, l, p, _, f, m, y) {
    super(["stateChanged"]), this._internalBlockUploadId = Kt(), this._state = g.NOT_INITIALIZED, this._currentBlockIndex = 0, this._pendingBlockRequests = /* @__PURE__ */ new Map(), this._bytesUploaded = 0, this._indeterminateTransfer = !1, this._maxConcurrentRequests = 4, this._retryQueue = /* @__PURE__ */ new Set(), this._activeBlockIndex = 0, this._lastExtendTime = 0, this._uploadedBlocksURLs = [], this._service = e, this._getSliceCallback = s, Ga(r) ? (E([j.REPO_SIZE, r[j.REPO_SIZE], "number"]), this._blockTransferDocument = r, this._transferBlockLinks = this._blockTransferDocument[T.LINKS][u.BLOCK_TRANSFER], this._dataSize = this._blockTransferDocument[j.REPO_SIZE], this._relationType = this._blockTransferDocument[j.REPO_REL_TYPE], this._shiftState(g.INITIALIZED), w(`BlockUpload Initialized: Transfer document found with ${this._transferBlockLinks.length} links. BlockUploadId: ${this._internalBlockUploadId}`)) : (E(["relationType", n, "string"], ["dataSize", o, "number"], ["contentType", i, "string"], ["componentId", a, "string", !0], ["etag", h, "string", !0]), this._asset = r, V(this._asset.links, [u.BLOCK_UPLOAD_INIT], c.UNEXPECTED, "/rel/block/init missing from BlockTransferDocument."), this._relationType = n, this._dataSize = o, this._contentType = i, this._componentId = a, this._md5 = d, this._ifMatch = h), this._relPath = l, this._createIntermediates = p, this._respondWith = _, this._repoMetaPatch = f, this._maxConcurrentRequests = m || 4, this._nameConflictPolicy = y, this._promise = new S(((P, I) => {
      this._reject = I, this._resolve = P;
    })), ce.uploads.push(this);
  }
  init(e) {
    if (this._assertStateIsValid("init"), !this._blockTransferDocument || !this._blockTransferDocument[T.LINKS]) {
      this._shiftState(g.INITIALIZING);
      const s = L(Object.assign({ [j.REPO_REL_TYPE]: this._relationType, [j.REPO_IF_MATCH]: this._ifMatch, [j.REPO_SIZE]: this._dataSize, [j.DC_FORMAT]: this._contentType, [j.COMPONENT_ID]: this._componentId, [j.REPO_MD5]: this._md5 }, this._blockTransferDocument));
      return pr(this._service, this._asset, s, e).then(((r) => (this._blockTransferDocument = r.result, this._transferBlockLinks = this._blockTransferDocument[T.LINKS][u.BLOCK_TRANSFER], this._shiftState(g.INITIALIZED), w(`BlockUpload Initialized: Transfer document found with ${this._transferBlockLinks.length} links. BlockUploadId: ${this._internalBlockUploadId}`), this)));
    }
    return S.resolve(this);
  }
  get state() {
    return this._state;
  }
  get promise() {
    return this._promise;
  }
  start() {
    return this._assertStateIsValid("start"), ce.uploads[0] !== this || this._state !== g.INITIALIZED && this._state !== g.PAUSED || (w(`Starting the transfer of BlockUpload: ${this._internalBlockUploadId}`), this._shiftState(g.STARTED), this._uploadLoop()), this._promise;
  }
  pause() {
    return this._assertStateIsValid("pause"), this._shiftState(g.PAUSING), S.allSettled([...this._pendingBlockRequests.values()]).then((() => (this._shiftState(g.PAUSED), w(`BlockUploading has been paused.  BlockUploadId: ${this._internalBlockUploadId}`), this)));
  }
  resume() {
    return this._assertStateIsValid("resume"), w(`BlockUploading has been resumed.  BlockUploadId: ${this._internalBlockUploadId}`), this.start(), this;
  }
  cancel() {
    this._assertStateIsValid("cancel"), this._shiftState(g.CANCELED), w(`A BlockUpload has been canceled... BlockUploadId: ${this._internalBlockUploadId}`), this._promise.cancel(), this._cancel();
  }
  _setWaiting() {
    this._shiftState(g.WAITING);
  }
  uploadNextBlock(e) {
    if (this._assertStateIsValid("uploadNextBlock"), this._isEmptyBlock(e)) throw new c(c.INVALID_PARAMS, "Trying to upload empty data block.");
    const s = this._activeBlockIndex, r = Date.now(), n = this._blockTransferDocument[T.LINKS][u.BLOCK_TRANSFER][s].href;
    let o;
    w(`Uploading a block... BlockUploadId: ${this._internalBlockUploadId}`);
    const i = Be(e), a = this._uploadBlock(e, n).then(((d) => (this._uploadedBlocksURLs[s] = { href: n }, this._updateProgress(i), o(), w(`A block has completed... ${this._pendingBlocksCount} requests still active. BlockUploadId: ${this._internalBlockUploadId}`), d))).catch(((d) => (o(), this._isTransferUrlExpiredError(d) ? (w(`A block with index as ${s} has FAILED due to Transfer Expiry!! ${this._pendingBlocksCount} requests still active. BlockUploadId: ${this._internalBlockUploadId}`), this._retryQueue.add(s), r <= this._lastExtendTime ? (w(`Skipping extend for block ${s} — request started after last extend.`), this._maybePauseForRetry().then((() => S.reject(g.PAUSED)))) : this._maybeExtendWithPauseResume().catch(((h) => (w(`Extend flow failed for block ${s}`, h), S.reject(h))))) : (w(`A block upload has failed. BlockUploadId: ${this._internalBlockUploadId}`), this._shiftState(g.ERROR), this._reject(new c(c.UNEXPECTED_RESPONSE, "A block has failed during upload", d, d.response)), this.cancel(), S.reject(d)))));
    return o = this._pushPendingBlockRequest(s, a), a;
  }
  get _pendingBlocksCount() {
    return ce.pendingUploadRequests.filter(((e) => !!e)).length;
  }
  _nextBlockLock() {
    return this._pendingBlocksCount < this._maxConcurrentRequests ? Promise.resolve() : Promise.race(ce.pendingUploadRequests.filter(((e) => !!e)));
  }
  _handleAssetMoved(e) {
    throw w("_handleAssetMoved"), this._pendingBlockRequests.forEach(((s) => {
      s.abort();
    })), this._pendingBlockRequests.clear(), this._uploadedBlocksURLs.length = 0, this._transferBlockLinks.length = 0, this._asset.links = Object.assign(Object.assign({}, this._asset.links), he(e.response)), this._retryQueue.clear(), this._activeBlockIndex = 0, this._lastExtendTime = 0, this._currentBlockIndex = 0, this._bytesUploaded = 0, this._state = g.NOT_INITIALIZED, this._blockTransferDocument[T.LINKS] = void 0, this.init().then((() => this.start())), g.INITIALIZING;
  }
  _getNextUploadBlockData() {
    if (this._retryQueue.size > 0) {
      const [e] = this._retryQueue;
      this._retryQueue.delete(e), this._activeBlockIndex = e;
    } else this._activeBlockIndex = this._currentBlockIndex;
    return this._getBlockAtIndex(this._activeBlockIndex);
  }
  _uploadLoop() {
    this._nextBlockLock().then((() => {
      if (this._state === g.FINALIZING || this._state === g.COMPLETE) throw g.COMPLETE;
      if (this._state === g.PAUSING || this._state === g.PAUSED) throw g.PAUSED;
      if (this._state === g.CANCELED) throw g.CANCELED;
      if (this._state === g.ERROR) throw g.ERROR;
    })).then((() => this._getNextUploadBlockData())).then(((e) => this._isEmptyBlock(e) ? (w(`No more blocks.  BlockUploadId: ${this._internalBlockUploadId}`), Promise.all([...this._pendingBlockRequests.values()]).then(this._finalize.bind(this))) : e && Be(e) > 0 && this._activeBlockIndex >= this._transferBlockLinks.length ? this._extend().then((() => e)) : e)).then(((e) => {
      if (!e) throw g.COMPLETE;
      this.uploadNextBlock(e), this._activeBlockIndex === this._currentBlockIndex && this._currentBlockIndex++;
    })).then((() => {
      this._uploadLoop();
    })).catch(((e) => {
      if (typeof e != "string" && (this._continueBlockUploads(), this._reject(e)), e !== g.INITIALIZING) if (e !== g.COMPLETE) {
        if (e !== g.PAUSED) return e === g.CANCELED ? (w(`BlockUpload loop is terminated due to the upload being canceled. BlockUploadId: ${this._internalBlockUploadId}`), void this._continueBlockUploads()) : e === g.ERROR ? (w(`BlockUpload loop is terminated due to error state. BlockUploadId: ${this._internalBlockUploadId}`), void this._continueBlockUploads()) : void 0;
        w(`BlockUpload loop is terminated due to paused state. BlockUploadId: ${this._internalBlockUploadId}`);
      } else w(`BlockUpload loop is complete. BlockUploadId: ${this._internalBlockUploadId}`);
      else w(`BlockUpload loop must be re-started due to assetmoved BlockUploadId: ${this._internalBlockUploadId}`);
    }));
  }
  _getBlockAtIndex(e) {
    w(`_getBlockAtIndex(${e})`);
    const s = Math.min(this._dataSize, this._blockTransferDocument[j.REPO_BLOCK_SIZE]);
    if (this._state === g.STARTED) {
      const r = e * s;
      return w("calling _getSliceCallback", r, r + s), this._getSliceCallback(r, r + s).catch(((n) => {
        throw new c(c.UNEXPECTED_RESPONSE, "The getSliceCallback threw an unexpected error.", n);
      }));
    }
  }
  _uploadBlock(e, s) {
    return this._service.invoke(v.PUT, s, void 0, e, { isStatusValid: k(), isExternalRequest: !0 });
  }
  _isEmptyBlock(e) {
    return typeof e == "string" ? e.length === 0 : Fa(e) ? e.size === 0 : !e || e.byteLength === 0;
  }
  _extend(e = !0) {
    V(this._blockTransferDocument[T.LINKS], [u.BLOCK_EXTEND], c.UNEXPECTED, "The transfer document does not contain an extend href");
    const s = this._blockTransferDocument[j.REPO_SIZE], r = e ? Math.ceil(1.5 * s) : s, n = J(this._blockTransferDocument[T.LINKS], u.BLOCK_EXTEND, { size: r });
    return this._service.invoke(v.POST, n, {}, void 0, { isStatusValid: k(), responseType: "json" }).then(((o) => (this._indeterminateTransfer = !0, this._blockTransferDocument = o.response, this._transferBlockLinks = this._blockTransferDocument[T.LINKS][u.BLOCK_TRANSFER], w(`Transfer document extended (${e ? "size increased" : "URL refresh only"}): ${this._transferBlockLinks.length} transfer links. BlockUploadId: ${this._internalBlockUploadId}`), o))).catch(((o) => {
      throw dt(o) && o.problemType === Z.ASSET_MOVED && this._handleAssetMoved(o), new c(c.UNEXPECTED_RESPONSE, "An unexpected error occurred while extending the block transfer document.", o, o.response);
    }));
  }
  _maybeExtendWithPauseResume() {
    if (this._extendPromise) return w("Reusing in-progress extend (with pause/resume)"), S.reject(g.PAUSED);
    w("[_maybeExtendWithPauseResume] Setting state to PAUSED and triggering extend"), this._shiftState(g.PAUSED);
    const e = S.resolve().then((() => (w("[_maybeExtendWithPauseResume] Pause done, calling _extend()"), this._extend(!1)))).then(((s) => (this._lastExtendTime = Date.now(), w("[_maybeExtendWithPauseResume] Extend done, calling resume()"), S.resolve(this.resume()).then((() => (w("[_maybeExtendWithPauseResume] Resume done"), s))))));
    return this._extendPromise = e.finally((() => {
      this._extendPromise = void 0;
    })), S.reject(g.PAUSED);
  }
  _maybePauseForRetry() {
    return this._state === g.PAUSED || this._state === g.PAUSING ? (w("[_maybePauseForRetry] Already in PAUSED or PAUSING state — skipping."), S.resolve()) : (w("[_maybePauseForRetry] Shifting to PAUSED state to trigger retry mechanism."), this._shiftState(g.PAUSED), w("[_maybePauseForRetry] Calling resume() to restart upload loop for retries."), this.resume(), S.resolve());
  }
  _isTransferUrlExpiredError(e) {
    var s, r;
    const n = (s = e == null ? void 0 : e.response) === null || s === void 0 ? void 0 : s.statusCode, o = e == null ? void 0 : e.code, i = ((r = e == null ? void 0 : e.response) === null || r === void 0 ? void 0 : r.response) || "";
    return w(`[TransferExpiryCheck] StatusCode: ${n}`), w(`[TransferExpiryCheck] Code: ${o}`), w(`[TransferExpiryCheck] RawResponse: ${i}`), !(n !== 403 && o !== "FORBIDDEN" || typeof i != "string" || !i.toLowerCase().includes("request has expired"));
  }
  _pushPendingBlockRequest(e, s) {
    this._pendingBlockRequests.set(e, s);
    const r = ce.pendingUploadRequests.push(s);
    return () => {
      this._pendingBlockRequests.delete(e), delete ce.pendingUploadRequests[r - 1];
    };
  }
  _updateProgress(e) {
    if (w("_updateProgress()", e), typeof e == "number" && (this._bytesUploaded += e), this.onProgress && Y(this.onProgress)) try {
      this.onProgress(this._bytesUploaded, Math.max(this._blockTransferDocument[j.REPO_SIZE], this._bytesUploaded), this._indeterminateTransfer);
    } catch (s) {
      console.error("Error in onProgress callback", s);
    }
  }
  _cancel() {
    this._pendingBlockRequests.forEach(((e) => {
      e == null || e.cancel();
    })), this._state !== g.ERROR && this._resolve(this);
  }
  _assertStateIsValid(e, s) {
    const r = s || this._state;
    switch (e) {
      case "init":
        if (r !== g.NOT_INITIALIZED && r !== g.INITIALIZED) throw new c(c.INVALID_STATE, "BlockUpload has already been initialized");
        break;
      case "start":
        if (r === g.NOT_INITIALIZED) throw new c(c.INVALID_STATE, "Please call init before starting the block upload");
        break;
      case "uploadNextBlock":
        if (r === g.PAUSED || r === g.CANCELED) throw new c(c.INVALID_STATE, "Cannot add block when Paused or Cancelled");
        break;
      case "getBlockAtIndex":
        if (r !== g.STARTED) throw new c(c.INVALID_STATE, `Cannot fetch block while in the ${r} state`);
        break;
      case "cancel":
        if (r !== g.STARTED && r !== g.FINALIZING && r !== g.PAUSING && r !== g.PAUSED && r !== g.ERROR) throw new c(c.INVALID_STATE, `Trying to cancel while in an invalid state ${r}`);
    }
  }
  _continueBlockUploads() {
    if (w("continueBlockUploads()"), ce.uploads[0] === this) if (ce.uploads.shift(), ce.uploads.length > 0) {
      const e = ce.uploads[0];
      w("Another block upload found in the queue, starting..."), e.start();
    } else this._pendingBlocksCount === 0 && (w("There are no more pending block transfers.. Clean up blockUploadManager.."), ce.resetUploads());
  }
  _finalize() {
    w(`Finalizing block transfer.  BlockUploadId: ${this._internalBlockUploadId}`), this._shiftState(g.FINALIZING);
    const e = J(this._blockTransferDocument[T.LINKS], u.BLOCK_FINALIZE, L({ path: this._relPath, intermediates: this._createIntermediates, respondWith: C(this._respondWith) ? JSON.stringify(this._respondWith) : this._respondWith, repoMetaPatch: this._repoMetaPatch, nameConflictPolicy: this._nameConflictPolicy }));
    return this._blockTransferDocument[T.LINKS][u.BLOCK_TRANSFER] = this._uploadedBlocksURLs, this._service.invoke(v.POST, e, { [b.CONTENT_TYPE]: Sn }, JSON.stringify(L(this._blockTransferDocument)), { isStatusValid: k(), retryOptions: { pollHeader: "location", pollCodes: [202], timeoutAfter: 12e4 }, responseType: "arraybuffer" }).then(((s) => {
      if (s.statusCode === 200 || s.statusCode === 201) {
        w(`Finalize complete.  BlockUploadId: ${this._internalBlockUploadId}`);
        const r = is(new Uint8Array(s.response));
        if (this._relationType === u.PRIMARY) {
          if (this.finalizeResponse = r, this.createdAsset = L({ assetId: r.headers["asset-id"], repositoryId: r.headers["repository-id"], links: ar(r.headers.link), etag: r.headers.etag, md5: r.headers["content-md5"] }), r.response && this._respondWith) try {
            const n = JSON.parse(ve(r.response));
            r.response = n, this.createdAsset = xe(this.createdAsset, se(n));
          } catch (n) {
            throw new c(c.UNEXPECTED, "Unexpected error parsing respondWith parameter", n);
          }
        } else {
          this.finalizeResponse = s;
          try {
            this.uploadRecord = Cc(this._blockTransferDocument[j.DC_FORMAT], this._blockTransferDocument[j.COMPONENT_ID], this._bytesUploaded, ve(s.response));
          } catch (n) {
            throw new c(c.UNEXPECTED, "An error occurred while deserializing upload component record.", n, r);
          }
        }
        this._shiftState(g.COMPLETE), this._updateProgress(!0), this._resolve(this);
      }
      this._continueBlockUploads();
    })).catch(((s) => {
      if (dt(s)) switch (s.problemType) {
        case Z.ASSET_MOVED:
          return void this._handleAssetMoved(s);
        case Z.ASSET_NAME_CONFLICT:
          return w("Error occurred finalizing the block transfer due to asset name conflict.. Rejecting with ALREADY_EXISTS"), this._reject(new c(c.ALREADY_EXISTS, "Asset name conflict occurred during block transfer finalization.", s, s.response)), void this._continueBlockUploads();
      }
      w("Error occurred finalizing the block transfer.. Rejecting"), this._reject(new c(c.UNEXPECTED_RESPONSE, "An error occurred while finalizing the block transfer.", s, s.response)), this._continueBlockUploads();
    }));
  }
  _shiftState(e) {
    return w(`_shiftState(): ${e}`), this._state === g.COMPLETE || this._state === g.ERROR || this._state === g.CANCELED || (this._state = e, this.emit("stateChanged", [this._state])), this;
  }
}
function pr(t, e, s, r = {}) {
  if (E(["svc", t, "object"], ["assetOrLink", e, ["object", "string"]], ["transferDocument", s, "object"], ["additionalHeaders", r, "object", !0]), Qt(e) && V(e.links, [u.BLOCK_UPLOAD_INIT]), s["repo:resource"]) {
    if (!s["repo:resource"].reltype) throw new c(c.INVALID_DATA, "reltype param is required in the Resource Designator");
    s[j.REPO_REL_TYPE] = s["repo:resource"].reltype, s["repo:resource"].component_id && (s[j.COMPONENT_ID] = s["repo:resource"].component_id), s["repo:resource"].etag && (s[j.REPO_IF_MATCH] = s["repo:resource"].etag), delete s["repo:resource"];
  }
  if (s[j.REPO_REL_TYPE] === u.COMPONENT && !s[j.COMPONENT_ID]) throw new c(c.INVALID_DATA, "Component Id required to block upload to a component");
  const n = Qt(e) ? H(e.links, u.BLOCK_UPLOAD_INIT) : e;
  r[b.CONTENT_TYPE] = Sn;
  const o = Pt(r);
  return o.priority = o.priority || "u=1", t.invoke(v.POST, n, o, JSON.stringify(s), { responseType: "json", isStatusValid: k() }).then(((i) => ({ response: i, result: i.response })));
}
function mo({ additionalHeaders: t, asset: e, componentId: s, contentType: r, dataOrSliceCallback: n, etag: o, maybeIsNew: i, md5: a, progressCb: d, relation: h, size: l, svc: p, blockSize: _, maxConcurrentRequests: f }) {
  Sc("_upload()"), E(["svc", p, "object"], ["asset", e, "object"], ["size", l, "number", !0], ["md5", a, "string", !0], ["etag", o, "string", !0]);
  const m = Je(n, l), y = Be(m), P = x(p);
  if (ur(e, y)) return Rt({ asset: e, additionalHeaders: t, componentId: s, contentType: r, dataOrSliceCallback: n, etag: o, md5: a, progressCb: d, relation: h, size: l, service: P, blockSize: _, maxConcurrentRequests: f });
  V(e.links, [h]);
  const I = J(e.links, h, { component_id: s });
  return S.resolve(void 0, { blockUpload: void 0, progress: d }).then((() => Promise.resolve(Y(n) ? n(0, y) : n))).then(((R) => Yt({ asset: e, additionalHeaders: t, contentType: r, data: R, etag: o, headHref: I, href: I, maybeIsNew: i, relation: h, service: P }))).then(((R) => {
    let D = {};
    try {
      D = he(R), e.links = de(e.links || {}, D);
      const O = oe(p);
      O && O.setValueWithAsset(e.links, e);
    } catch {
    }
    return { response: R, result: { revision: R.headers.revision || R.headers.version, location: R.headers.location, links: D, etag: R.headers.etag, version: R.headers.version || R.headers.revision, md5: R.headers.md5 || R.headers["content-md5"], length: y, type: r }, isBlockUpload: !1, asset: { assetId: e.assetId || R.headers["asset-id"], repositoryId: e.repositoryId || R.headers["repository-id"], links: e.links || D } };
  })).catch(((R) => {
    throw R;
  }));
}
function yo({ service: t, asset: e, additionalHeaders: s, dataOrSliceCallback: r, contentType: n, progressCb: o, relation: i, size: a, componentId: d, md5: h, etag: l, relPath: p, createIntermediates: _, respondWith: f, blockSize: m, repoMetaPatch: y, maxConcurrentRequests: P, nameConflictPolicy: I }) {
  const R = Y(r) ? r : (function(O) {
    if (!Y(O.slice)) throw new c(c.INVALID_PARAMS, "Data cannot be sliced");
    return function(N, M) {
      return ne(this, void 0, void 0, (function* () {
        return O.slice(N, M);
      }));
    };
  })(r);
  e && V(e.links, [u.BLOCK_UPLOAD_INIT]);
  const D = pr(t, e || (function(O) {
    F("getBlockUploadLinkForGuest"), E(["svc", O, "object"]);
    const N = x(O), M = ze(Ec, N);
    return Fe(M, {});
  })(t), L({ [j.REPO_REL_TYPE]: i, [j.REPO_IF_MATCH]: l, [j.REPO_SIZE]: a, [j.DC_FORMAT]: n, [j.COMPONENT_ID]: d, [j.REPO_MD5]: h, [j.REPO_BLOCK_SIZE]: m }), s);
  return D.then(((O) => {
    const N = new Nc(t, R, O.result, i, a, n, d, h, l, p, _, f, y, P, I);
    return N.onProgress = o, Object.assign(D, { blockUpload: N }), N.init(s);
  })).then(((O) => O.start())).then(((O) => {
    const N = O.finalizeResponse || { headers: {} }, M = O.uploadRecord || O.createdAsset;
    return { response: N, result: M, blockUpload: O, isBlockUpload: !0, asset: { assetId: N.headers["asset-id"] || e.assetId, repositoryId: N.headers["repository-id"] || e.repositoryId, etag: N.headers.etag, links: e ? e.links : M.links } };
  }));
}
function Rt({ service: t, asset: e, additionalHeaders: s, dataOrSliceCallback: r, contentType: n, progressCb: o, relation: i, size: a, componentId: d, md5: h, etag: l, relPath: p, createIntermediates: _, respondWith: f, blockSize: m, repoMetaPatch: y, maxConcurrentRequests: P, nameConflictPolicy: I }) {
  return yo({ service: t, asset: e, additionalHeaders: s, dataOrSliceCallback: r, contentType: n, progressCb: o, relation: i, size: a, componentId: d, md5: h, etag: l, relPath: p, createIntermediates: _, respondWith: f, blockSize: m, repoMetaPatch: y, maxConcurrentRequests: P, nameConflictPolicy: I });
}
function Rs({ service: t, additionalHeaders: e, dataOrSliceCallback: s, contentType: r, progressCb: n, relation: o, size: i, componentId: a, md5: d, etag: h, relPath: l, respondWith: p, blockSize: _, repoMetaPatch: f, maxConcurrentRequests: m, nameConflictPolicy: y }) {
  return yo({ service: t, asset: void 0, additionalHeaders: e, dataOrSliceCallback: s, contentType: r, progressCb: n, relation: o, size: i, componentId: a, md5: d, etag: h, relPath: l, createIntermediates: !0, respondWith: p, blockSize: _, repoMetaPatch: f, maxConcurrentRequests: m, nameConflictPolicy: y });
}
function Dc(t) {
  return t || "defaultbuffer";
}
function kc(t) {
  return !!(t.deviceModifyDate || t.assetType || t.assetSubType);
}
function Lc(t, e, s = "json", r = {}) {
  E(["svc", t, "object"], ["asset", e, "object"], ["format", s, "enum", !1, ["json", "xml"]]), V(e.links, [u.EMBEDDED_METADATA]);
  const n = H(e.links, u.EMBEDDED_METADATA);
  return t.invoke(v.GET, n, Object.assign(Object.assign({}, r), { accept: Jt[s.toUpperCase()] }), void 0, { isStatusValid: k(), responseType: s === "json" ? "json" : "text" }).then(((o) => ({ result: o.response, response: o })));
}
function wc(t, e, s, r, n = "json", o = {}) {
  E(["svc", t, "object"], ["asset", e, "object"], ["data", s, ["string", "object", "object[]"]], ["etag", r, "string", !0], ["format", n, "enum", !1, ["json", "xml"]]), V(e.links, [u.EMBEDDED_METADATA]);
  const i = H(e.links, u.EMBEDDED_METADATA), a = Object.assign(Object.assign({}, o), { [b.CONTENT_TYPE]: Jt[n.toUpperCase()], [b.IF_MATCH]: r });
  return t.invoke(v.PUT, i, a, typeof s == "string" ? s : JSON.stringify(s), { isStatusValid: k() });
}
function Mc(t, e, s, r, n = {}) {
  E(["svc", t, "object"], ["asset", e, "object"], ["data", s, ["string", "object", "object[]"]], ["etag", r, "string", !0]), V(e.links, [u.EMBEDDED_METADATA]);
  const o = H(e.links, u.EMBEDDED_METADATA);
  return t.invoke(v.PATCH, o, Object.assign(n, { [b.CONTENT_TYPE]: lt, [b.IF_MATCH]: r }), typeof s == "string" ? s : JSON.stringify(s), { isStatusValid: k(), retryOptions: { pollCodes: [202], pollHeader: "location", pollMethod: "GET" } });
}
B("dcx:assets:filebase");
const _r = B("dcx:assets:filebase:leaf"), vo = "application/vnd.adobe.versions+json";
function Uc(t, e, s, r = "defaultbuffer", n, o) {
  _r("getRendition()"), E(["svc", t, "object"], ["asset", e, "object"], ["renditionOptions", s, "object", !0], ["linkProvider", n, "object", !0]), V(e.links, [u.RENDITION]);
  const i = n ? ni(e.links[u.RENDITION], n, s) : J(e.links, u.RENDITION, Object.assign({}, s));
  return t.invoke(v.GET, i, o, void 0, { responseType: Dc(r), isStatusValid: k() }).then(((a) => ({ result: a.response, response: a })));
}
function Qr(t, e, s, r, n, o, i, a, d) {
  _r("doBlockDownload()"), E(["svc", t, "object"], ["assetOrPresignedUrl", e, ["object", "string"]], ["startByte", s, "number", !0], ["endByte", r, "number", !0], ["resource", n, "string", !0], ["componentId", o, "string", !0], ["version", i, "string", !0], ["responseType", a, "enum", !0, nr]), fn((() => s == null || r == null || s < r), "endByte must be greater than startByte");
  const h = this != null ? this : {};
  if (typeof e == "string") return et.call(h, t, e, s, r, a, !0, void 0, d);
  const l = e;
  V(l.links, [u.BLOCK_DOWNLOAD]);
  const p = L({ reltype: n, component_id: o, revision: i }), _ = J(l.links, u.BLOCK_DOWNLOAD, { resource: n !== void 0 ? JSON.stringify(p) : void 0 });
  return et.call(h, t, _, s, r, a, !1, void 0, d);
}
function xc(t, e, s, r, n, o, i, a) {
  return _r("updatePrimaryResource()"), E(["service", t, "object"], ["asset", e, "object"], ["dataOrSliceCallback", s, ["function", "object", "string"]], ["contentType", r, "string"], ["size", n, "number", !0], ["md5", i, "string", !0]), V(e.links, [u.PRIMARY]), mo({ svc: t, asset: e, dataOrSliceCallback: s, contentType: r, relation: u.PRIMARY, size: n, md5: i, maybeIsNew: !1, etag: o, additionalHeaders: a }).catch(((d) => {
    var h;
    if (((h = d.response) === null || h === void 0 ? void 0 : h.statusCode) === 413) return Rt({ service: x(t), asset: e, dataOrSliceCallback: s, contentType: r, relation: u.PRIMARY, size: n, md5: i, etag: o, additionalHeaders: a });
    throw d;
  }));
}
const Tt = B("dcx:assets:pagination");
class ds {
  constructor(e, s, r, n) {
    if (this._links = e, this._svc = s, this._transformer = r, this._items = {}, this.ListResource = n, !e || !e[u.PAGE]) throw new c(c.INVALID_PARAMS, "Asset must have links that contain a page relation.");
  }
  get items() {
    return Object.values(this._items);
  }
  get data() {
    return this._data;
  }
  getPage(e = {}, s) {
    Tt("getPage()");
    const { embed: r } = e, n = Nn(e, ["embed"]);
    r && (n.embed = r.some(((i) => typeof i == "object")) ? JSON.stringify(r) : r.join(",")), this.ListResource && Object.assign(n, { resource: this.ListResource });
    const o = J(this._links, u.PAGE, n);
    return this._svc.invoke(v.GET, o, s, void 0, { isStatusValid: k(), responseType: "json" }).then(((i) => {
      const a = this.parseResponse(i);
      return this._data = a, { paged: this, result: this._data, response: i };
    }));
  }
  getNextPage() {
    if (Tt("getNextPage()"), this.hasNextPage() && this._nextPageLink) return this._svc.invoke(v.GET, this._nextPageLink.href, void 0, void 0, { isStatusValid: k(), responseType: "json" }).then(((e) => {
      const s = this.parseResponse(e);
      return this._data = s, { paged: this, result: this._data, response: e };
    }));
  }
  hasNextPage() {
    return Tt("hasNextPage() ", this._nextPageLink !== void 0), this._nextPageLink !== void 0;
  }
  *[Symbol.iterator]() {
    for (const e in this._items) yield this._items[e];
  }
  [Symbol.asyncIterator]() {
    return Wa(this, arguments, (function* () {
      for (const e in this._items) yield yield at(this._items[e]);
      for (; this.hasNextPage(); ) {
        const e = yield at(this.next());
        for (const s of e.value.paged) yield yield at(s);
      }
    }));
  }
  next() {
    return ne(this, void 0, void 0, (function* () {
      if (Tt("next()"), !this.hasNextPage()) return { done: !0, value: void 0 };
      const e = yield this.getNextPage();
      return e ? { done: !1, value: e } : { done: !0, value: void 0 };
    }));
  }
  parseResponse(e) {
    Tt("parseResponse()"), this._items = {};
    const s = e.response;
    for (const r in s[T.CHILDREN]) {
      const n = s[T.CHILDREN][r], [o, i] = this._transformer(n, this._svc);
      this._items[o] = i;
    }
    return this._nextPageLink = s[T.LINKS].next, this.currentPage = s[T.PAGE], s;
  }
}
B("dcx:assets:version");
const bo = B("dcx:assets:version:leaf");
function Bc(t) {
  bo("adobeVersionTransformer()");
  const e = fr(t);
  return e.links = de({}, t.links, t._links), [e.version, e];
}
function fr(t) {
  return bo("deserializeVersion()"), { version: t.version || t[De.VERSION], createDate: t.created || t[De.CREATED], createdBy: t.createdBy || t[De.CREATED_BY], milestone: t.milestone || t[De.MILESTONE], contributorIds: t.contributorIds || t[De.CONTRIBUTORS], links: t._links };
}
B("dcx:assets:file");
const Er = B("dcx:assets:file:leaf");
function jc(t, e, s, r, n) {
  Er("patchVersions()"), E(["svc", t, "object"], ["asset", e, "object"], ["patchDoc", s, ["string", "array"]], ["etag", r, "string", !0]), V(e.links, [u.VERSION_HISTORY]);
  const o = Object.assign(Object.assign({}, n), { [b.CONTENT_TYPE]: lt });
  r && (o[b.IF_MATCH] = r);
  const i = H(e.links, u.VERSION_HISTORY);
  return t.invoke(v.PATCH, i, o, typeof s == "string" ? s : JSON.stringify(s), { isStatusValid: k() });
}
function Ro(t, e, s, r) {
  Er("getVersionResource()"), E(["svc", t, "object"], ["asset", e, "object"], ["version", s, "string"]), V(e.links, [u.PAGE]), kn(e.links, u.PAGE, "type", vo);
  const n = J(e.links, u.PAGE, { version: s });
  return t.invoke(v.GET, n, r, void 0, { responseType: "json", isStatusValid: k() }).then(((o) => ({ result: o.response[De.TOTAL_CHILDREN] > 0 ? o.response[T.CHILDREN][0] : void 0, response: o })));
}
function Vc(t, e, s = {}, r) {
  return Er("getPagedVersions()"), E(["svc", t, "object"], ["asset", e, "object"], ["pageOpts", s, "object"]), V(e.links, [u.PAGE]), kn(e.links, u.PAGE, "type", vo), new ds(e.links, t, s.itemTransformer || Bc, u.VERSION_HISTORY).getPage(s, r);
}
B("dcx:assets:composite");
const _e = B("dcx:assets:composite:leaf"), Fc = ue.getInstance();
function Hc(t, e, s) {
  return _e("headCompositeManifest()"), E(["svc", t, "object"], ["asset", e, "object"]), V(e.links, [u.MANIFEST]), hs(t, e, void 0, s).then(((r) => t.invoke(v.HEAD, r, s, void 0, { responseType: "json", isStatusValid: k() })));
}
function Gc(t, e, s, r, n) {
  return _e("getCompositeManifest()"), E(["svc", t, "object"], ["asset", e, "object"], ["version", s, "string", !0], ["etag", r, "string", !0]), V(e.links, [u.MANIFEST]), hs(t, e, s, n).then(((o) => t.invoke(v.GET, o, Object.assign(n ?? {}, r ? { [b.IF_NONE_MATCH]: r } : {}), void 0, { isStatusValid: k([304]), retryOptions: { pollCodes: [404, 202], pollHeader: "location", pollMethod: v.GET, problemWithCode: { problemType: Z.RESOURCE_NOT_READY, code: 404 } } }))).then(((o) => {
    if ((o.statusCode === 200 || o.statusCode === 201) && o.headers[b.CONTENT_TYPE] === "application/http") {
      if (o.response) {
        const i = is(Te(o.response));
        return { manifestData: JSON.parse(ve(i.response)) || null, manifestEtag: i.headers.etag, response: i };
      }
      return { manifestData: o.response || null, manifestEtag: o.headers.etag, response: o.response };
    }
    if (typeof o.response == "string") return { manifestData: o.response ? JSON.parse(o.response) : null, manifestEtag: o.headers.etag, response: o };
    if (o.response === null && ["application/problem+json", "application/json"].includes(o.headers["content-type"])) throw new c(c.UNEXPECTED, "Unexpected response type");
    return { manifestData: o.response || null, manifestEtag: o.headers.etag, response: o };
  }));
}
function hs(t, e, s, r) {
  return _e("getCompositeManifestUrl()"), gr(t, e, u.MANIFEST, s, r).then(((n) => Fe(n, {})));
}
function $c(t, e, s, r) {
  return _e("_getComponentPathUrl()"), gr(t, e, u.COMPONENT, e.version, r).then(((n) => Fe(n, L({ component_path: s }))));
}
function gr(t, e, s, r, n) {
  return _e("_getUrl()"), E(["svc", t, "object"], ["asset", e, "object"], ["versionId", r, "string", !0]), S.resolve().then((() => {
    if (r) return Ro(t, e, r, n);
  })).then(((o) => {
    if (r != null) {
      if (!o || !C(o) || typeof o.result != "object") throw new c(c.UNEXPECTED_RESPONSE, "Invalid version resource.", void 0, o ? o.response : void 0);
      return V(o.result[T.LINKS], [s]), H(o.result[T.LINKS], s);
    }
    return H(e.links, s);
  }));
}
function Yc(t, e, s, r, n, o) {
  E(["svc", t, "object"], ["asset", e, "object"], ["components", s, "array"], ["version", r, "string", !0], ["etag", n, "string", !0]);
  const i = [u.MANIFEST, u.COMPONENT, u.BULK_REQUEST, u.BLOCK_DOWNLOAD];
  return r && i.push(u.PAGE), ut(t, e, i, void 0, o).then(((a) => ne(this, void 0, void 0, (function* () {
    e.links = Object.assign({}, e.links, a);
    const d = x(t), h = s.map((({ component_path: _, responseType: f, subrequestHeaders: m }) => ({ method: v.GET, href: J(e.links, u.COMPONENT, { component_path: _ }), headers: Object.assign(m || {}, o), component_path: _, responseType: f }))), l = yield hs(d, e, r, o);
    h.unshift({ method: v.GET, href: l, headers: Object.assign(n ? { [b.IF_NONE_MATCH]: n } : {}, o) });
    const p = { startTime: ae(), timeoutAfter: 72e5 };
    return gn(qc.bind(void 0, t, e, s, h, o), 404, p, Z.RESOURCE_NOT_READY);
  }))));
}
function qc(t, e, s, r, n) {
  return ne(this, void 0, void 0, (function* () {
    const o = x(t), i = yield Promise.all(si(r, 10).map(((a) => as(o, e, a, void 0, n, !0))));
    return S.resolve(yield i.reduce(((a, d) => ne(this, void 0, void 0, (function* () {
      var h, l;
      const p = yield a;
      if (p.responses.push(d.response), d.response.statusCode !== 200) return p;
      const { componentResponses: _, manifestResponse: f } = (function(y, P) {
        return y.reduce(((I, R) => {
          const D = P.find(((O) => O.href === R.headers[b.CONTENT_ID]));
          if (!D) throw new c(c.UNEXPECTED_RESPONSE, "Bulk sub-response content-id did not match any bulk request", void 0, R);
          return "component_path" in D ? I.componentResponses.push(R) : I.manifestResponse = R, I;
        }), { componentResponses: [] });
      })(d.result, r), m = {};
      if (s.forEach(((y) => {
        y.hasOwnProperty("skipBlockDownload") && (m[y.component_path] = y.skipBlockDownload);
      })), Object.assign(p.components, yield (function(y, P, I, R, D, O) {
        return ne(this, void 0, void 0, (function* () {
          return (yield Promise.all(P.map(((N) => ne(this, void 0, void 0, (function* () {
            if (N.headers[b.CONTENT_TYPE] === Bs && N.response.type === Z.RESPONSE_TOO_LARGE) {
              const M = en(N, y), Q = N.headers.location ? N.headers.location : J(R, u.BLOCK_DOWNLOAD, { resource: JSON.stringify({ component_path: M.component_path }) });
              if (O && O[M.component_path]) return { statusCode: 200, headers: L({ [b.CONTENT_TYPE]: N.headers["content-type"], [b.CONTENT_LENGTH]: N.headers["content-length"], [b.CONTENT_ID]: N.headers[b.CONTENT_ID] }), responseType: "application/json", response: { href: Q }, message: "OK" };
              const X = yield et(x(I), Q, void 0, void 0, "defaultbuffer", !0, void 0, D);
              return Object.assign(X.headers, { [b.CONTENT_ID]: N.headers[b.CONTENT_ID] }), X;
            }
            return N;
          })))))).reduce(((N, M) => {
            const Q = en(M, y);
            try {
              const X = it(M);
              N[Q.component_path] = Object.assign({}, Q, { response: M, [X ? "error" : "data"]: X || Os(M.response, Q.responseType || "defaultbuffer", M.headers["content-type"]) });
            } catch (X) {
              N[Q.component_path] = Object.assign({}, Q, { response: M, error: new c(c.UNEXPECTED, "Error parsing sub-response into requested responseType", X) });
            }
            return N;
          }), {});
        }));
      })(r.slice(1), _, t, e.links, n, m)), !f) return p;
      if (f.statusCode === 200) {
        p.manifest.data = Os(f.response, "json"), p.manifest.response = f, xs(e) && typeof ((h = e.current) === null || h === void 0 ? void 0 : h.parse) == "function" && (e.current.parse(ve(f.response)), e.current.versionId = f.headers.version), e.links = he(f);
        const y = oe(t);
        return y && y.setValueWithAsset(e.links, e), p;
      }
      if (f.statusCode === 304) return p.manifest.response = f, p;
      if (f.statusCode === 404) {
        if (f.response = Os(f.response, "json"), f.response && f.response.type === Z.RESOURCE_NOT_READY) throw new c(c.NOT_FOUND, void 0, void 0, f);
        return p.manifest.error = it(f) || new c(c.NO_COMPOSITE, "Composite missing or deleted", void 0, f), p;
      }
      if (f.headers[b.CONTENT_TYPE] === Bs && f.response.type === Z.RESPONSE_TOO_LARGE) {
        try {
          const y = f.headers.location ? f.headers.location : J(e.links, u.BLOCK_DOWNLOAD, { resource: JSON.stringify({ reltype: u.MANIFEST }) }), P = yield et(o, y, void 0, void 0, "json", !0, void 0, n);
          p.manifest.data = P.response, p.manifest.response = P, xs(e) && typeof ((l = e.current) === null || l === void 0 ? void 0 : l.parse) == "function" && e.current.parse(JSON.stringify(P.response)), e.links = he(P);
        } catch (y) {
          p.manifest.error = y instanceof c ? y : new c(c.UNEXPECTED, "Error fetching manifest via block download", y);
        }
        return p;
      }
      return p.manifest.error = it(f) || new c(c.UNEXPECTED_RESPONSE, f.response.title || "Failed to fetch manifest. Operation failed.", void 0, f), p;
    }))), Promise.resolve({ manifest: {}, components: {}, responses: [] })));
  }));
}
function en(t, e) {
  if (!t.headers[b.CONTENT_ID]) throw new c(c.UNEXPECTED_RESPONSE, "Sub-response is missing content-id header", void 0, t);
  const s = e.find((({ href: r }) => r === t.headers[b.CONTENT_ID]));
  if (!s) throw new c(c.UNEXPECTED_RESPONSE, "Bulk sub-response content-id did not match any bulk request", void 0, t);
  return s;
}
function Os(t, e, s) {
  if (!Pn(t)) return t;
  switch (e) {
    case "text":
      return ve(t);
    case "json":
      return JSON.parse(ve(t));
    case "blob":
      return new Blob([t], { type: s });
    case "buffer":
    case "defaultbuffer":
      return t;
    case "arraybuffer":
      return t.buffer;
  }
  throw new c(c.INVALID_PARAMS, "requested response type is not supported");
}
function zc(t, e, s, r, n, o) {
  return ne(this, void 0, void 0, (function* () {
    const i = [{ method: v.PUT, href: s, headers: n, body: r }], a = [];
    if (e.deviceModifyDate && a.push({ op: "add", path: `/${[T.REPO_DEVICE_MODIFY_DATE]}`, value: e.deviceModifyDate }), a.length) {
      const _ = { [b.CONTENT_TYPE]: lt };
      i.push({ method: v.PATCH, href: H(e.links, u.REPO_METADATA), headers: _, body: JSON.stringify(a) });
    }
    const { result: d, response: h } = yield as(t, e, i, void 0, o, !0), { manifestResponse: l, repoMetadataResponse: p } = (function(_, f) {
      const m = { manifestResponse: {}, repoMetadataResponse: {} };
      return f.forEach(((y) => {
        const P = _.find(((I) => I.headers[b.CONTENT_ID] === y.href));
        if (!P) throw new c(c.UNEXPECTED_RESPONSE, "Bulk sub-response content-id did not match any bulk request", void 0, P);
        y.href.includes(":repometadata") ? m.repoMetadataResponse = P : m.manifestResponse = P;
      })), m;
    })(d, i);
    return { manifestResponse: l, repoMetadataResponse: p, response: h };
  }));
}
function Ir(t, e, s, r) {
  return _e("getCompositeComponentUrl()"), E(["svc", t, "object"], ["asset", e, "object"], ["componentId", s, "string"], ["componentRevision", r, "string", !0]), V(e.links, [u.COMPONENT]), J(e.links, u.COMPONENT, { component_id: s, revision: r });
}
function Oo(t, e, s, r) {
  return _e("getPresignedUrl()"), E(["svc", t, "object"], ["asset", e, "object"]), ut(t, e, [u.BLOCK_DOWNLOAD], void 0, r).then(((n) => {
    const o = s ? JSON.stringify(s) : void 0, i = J(n, u.BLOCK_DOWNLOAD, { resource: o });
    return (rr(t) ? t.service : t).invoke(v.GET, i, Object.assign({ priority: "u=1" }, r), void 0, { isStatusValid: k(), responseType: "json", retryOptions: { pollCodes: [202], pollHeader: "location", pollMethod: v.GET } });
  })).then(((n) => {
    if (typeof n.response.href != "string") throw new c(c.INVALID_DATA, "Direct download URL not found.", void 0, n);
    return { response: n, result: n.response.href };
  }));
}
const Po = ns("AdobeDCX.getCompositeComponentPresignedUrl", (function(t, e, s, r, n) {
  return _e("getCompositeComponentPresignedUrl()"), pe("componentId", s), pe("componentRevision", r), E(["svc", t, "object"], ["asset", e, "object"], ["componentId", s, "string"], ["componentRevision", r, "string"]), Oo(t, e, { reltype: u.COMPONENT, revision: r, component_id: s }, n);
}));
function Wc(t, e, s, r = "defaultbuffer", n, o) {
  return E(["svc", t, "object"], ["asset", e, "object"], ["componentPath", s, "string"], ["responseType", r, "string", !0], ["additionalHeaders", n, "object", !0]), ut(t, e, [u.COMPONENT, u.PAGE], void 0, n).then(((i) => {
    if (e.links = i, e.version) return $c(x(t), e, s);
  })).then(((i) => dr(x(t), e, i ?? J(e.links, u.COMPONENT, { component_path: s }), u.COMPONENT, r, void 0, void 0, n, o)));
}
function Kc(t, e, s, r, n = "defaultbuffer", o, i) {
  _e("getCompositeComponent()"), E(["svc", t, "object"], ["asset", e, "object"], ["componentId", s, "string"], ["componentRevision", r, "string"], ["responseType", n, "string", !0], ["additionalHeaders", o, "object", !0], ["componentSize", i, "number", !0]);
  const a = {};
  if (!i || i < Ao()) {
    const d = Ir(t, e, s, r);
    return dr.call(a, t, e, d, u.COMPONENT, n, s, r, o);
  }
  return Po(t, e, s, r, o).then((({ response: d, result: h }) => et.call(a, t, h, void 0, void 0, n, !0, d.response.size, o)));
}
function Vs(t, e, s, r, n = 1, o, i = {}, a) {
  if (_e("updateCompositeManifest() ", r, o), E(["svc", t, "object"], ["asset", e, "object"], ["manifest", s, ["object", "string"]], ["overwrite", r, "boolean"], ["validationLevel", n, "+number"], ["etag", o, "string", !0]), n < 1) throw new c(c.INVALID_PARAMS, "ValidationLevel must be >=1");
  return V(e.links, [u.BULK_REQUEST, u.REPO_METADATA]), gr(t, e, u.MANIFEST, void 0, i).then(((d) => ne(this, void 0, void 0, (function* () {
    const h = Object.assign({}, i);
    r ? h[b.IF_MATCH] = "*" : o && (h[b.IF_MATCH] = o);
    const l = `${Ya}; validation-level=${n}`;
    h[b.CONTENT_TYPE] = l;
    const p = typeof s == "string" ? s : JSON.stringify(s);
    let _, f, m;
    const y = d.includes(vt.REPO_META_PATCH) || d.includes(vt.RESPOND_WITH);
    if (y) {
      const I = {}, R = L({ [T.REPO_DEVICE_MODIFY_DATE]: e.deviceModifyDate });
      Object.keys(R).length && (I[vt.REPO_META_PATCH] = R), d = Fe(d, I), _ = yield (function(D, O, N, M) {
        return ne(this, void 0, void 0, (function* () {
          return yield D.invoke(v.PUT, O, M, N, { isStatusValid: k([412, 409]), responseType: "arraybuffer", retryOptions: { pollCodes: [202], pollHeader: "location", pollMethod: v.GET, modifyHeadersCallback: Cn([b.IF_MATCH]) } });
        }));
      })(t, d, p, h);
    } else {
      const I = yield zc(t, e, d, p, h, i);
      _ = I.manifestResponse, f = I.repoMetadataResponse, m = I.response;
    }
    if (_e("uCM() status code for manifest response: ", _.statusCode), _.statusCode === 412 && r) return _e("uCM() retry 412 without overwrite"), Vs(t, e, s, !1, n, void 0, i);
    if (_.statusCode === 409 && r) return _e("uCM() retry 409 without overwrite"), Vs(t, e, s, !1, n, o, i);
    if (_.statusCode === 409) throw new c(c.UPDATE_CONFLICT, "Manifest has been changed", void 0, _);
    if (_.statusCode === 412) throw new c(c.PRECONDITION_FAILED, "Precondition failed", void 0, _);
    if (_.statusCode === 400) {
      const I = it(_);
      throw new c(I == null ? void 0 : I.code, I == null ? void 0 : I.message, void 0, _);
    }
    {
      const I = k()(_.statusCode, _);
      if (I !== !0) throw new c(I.code || c.UNEXPECTED_RESPONSE, I._message || I.message, I.underlyingError, _);
    }
    if (!y) {
      if (_.xhr = m.xhr, _e("uCM() status code for metadata response: ", f.statusCode), kc(e) && f.statusCode !== 200 && f.statusCode !== 201 && f.statusCode !== 204) throw new c(c.UNEXPECTED_RESPONSE, "Unexpected HTTP Response", void 0, f);
      return _;
    }
    let P = _;
    if (_.statusCode === 200 && (P = is(new Uint8Array(_.response))), P.response && a) try {
      const I = JSON.parse(ve(P.response));
      P.response = se(I);
    } catch (I) {
      throw new c(c.UNEXPECTED, "Unexpected error parsing respondWith parameter", I);
    }
    return P;
  }))));
}
function Xc(t, e, s, r, n, o, i, a, d, h, l) {
  if (E(["service", t, "object"], ["asset", e, "object"], ["componentId", s, "string"], ["contentType", n, "string"], ["maybeIsNew", o, "boolean", !0], ["size", i, "number", !0], ["blockSize", l, "number", !0], ["md5", a, "string", !0]), o && !Xt(s)) throw new c(c.INVALID_PARAMS, "Component id is not a uuid");
  return Xt(s) || Fc.warn("Existing component id is not a uuid"), mo({ svc: t, asset: e, dataOrSliceCallback: r, contentType: n, relation: u.COMPONENT, size: i, componentId: s, md5: a, maybeIsNew: o, additionalHeaders: h, progressCb: d, blockSize: l }).then((({ response: p, result: _, isBlockUpload: f, asset: m }) => {
    const y = { response: p, result: Object.assign(Object.assign({}, _), { id: s, type: n }), isBlockUpload: f, asset: m };
    return Object.defineProperty(y, "compositeAsset", { get: () => m }), y;
  }));
}
function Zc(t, e, s, r) {
  return ut(t, e, [u.COMPONENT, u.BLOCK_UPLOAD_INIT], void 0, r).then(((n) => {
    var o;
    const i = x(t);
    (o = oe(t)) === null || o === void 0 || o.setValueWithAsset(n, e), e.links = Object.assign(Object.assign({}, e.links), n);
    const a = Pt(L(Object.assign(Object.assign({}, r), { [b.AUTHORIZATION]: i.authProvider.authToken, [b.X_API_KEY]: i.authProvider.apiKey })));
    return Promise.all(s.map(((d) => ur(e, d.size) ? (function(h, l, p, _) {
      const f = L({ "repo:reltype": u.COMPONENT, "repo:size": p.size, "dc:format": p.contentType, component_id: p.componentId });
      return pr(h, l, f, _).then(((m) => {
        if (m.response.statusCode !== 200) throw new c(c.UNEXPECTED_RESPONSE, "Unexpected response from block upload init", m.response);
        const y = m.result;
        return { blockSize: y[j.REPO_BLOCK_SIZE], uploadRequestParameters: y[T.LINKS][u.BLOCK_TRANSFER].map((({ href: P }) => ({ href: P, method: v.PUT }))), finalizeRequestParameters: { href: J(y[T.LINKS], u.BLOCK_FINALIZE, {}), method: v.POST, headers: _, body: `${JSON.stringify(y)}` } };
      })).catch(((m) => {
        throw new c(c.UNEXPECTED_RESPONSE, "Unexpected response from block upload init", m);
      }));
    })(i, e, d, a) : (function(h, l, p, _) {
      return S.resolve({ blockSize: p.size, uploadRequestParameters: [{ href: Ir(h, l, p.componentId), method: v.PUT, headers: _ }] });
    })(i, e, d, a))));
  }));
}
const Ps = B("dcx:assets:directory"), kt = B("dcx:assets:directory:leaf");
class Tr extends bt {
  constructor(e, s, r) {
    super(e, s, r), this.type = Ye.Directory, this.children = [], this.children = e[T.CHILDREN];
  }
  getPagedChildren(e, s) {
    return Ps("getPagedChildren()"), this.fetchLinksIfMissing([u.PAGE], s).then((() => So(this._svc, this, e, s)));
  }
  createAsset(e, s, r, n, o, i, a, d, h, l) {
    return Ps("createAsset()"), No(this._svc, this, e, s, r, n, o, i, a, d, h, l).then(((p) => ({ result: new bt(p.result, this.serviceConfig), response: p.response })));
  }
  createAssetForGuest(e, s, r, n, o, i, a, d, h) {
    return Ps("createAssetForGAT"), Do(this._svc, e, s, r, n, o, i, a, d, h).then(((l) => ({ result: new bt(l.result, this.serviceConfig), response: l.response })));
  }
  copy(e, s, r, n, o, i) {
    return super.copy(e, s, r, n, void 0, i).then((({ response: a, result: d }) => ({ response: a, result: new Tr(d, this.serviceConfig) })));
  }
}
function Co(t) {
  var e;
  kt("directoryTransformer()");
  const s = se(t, (e = t[T.PAGE]) === null || e === void 0 ? void 0 : e.embed);
  s.links = de({}, t.links, t._links);
  const r = t.children || t[T.CHILDREN];
  return r && r.length > 0 ? s.children = r.map(((n) => se(n))) : s.children = [], [s.assetId, s];
}
function Jc(t, e) {
  return kt("getDirectoryByURL()"), t.invoke(v.GET, e, void 0, void 0, { responseType: "json", isStatusValid: k() }).then(((s) => ({ result: s.response, response: s })));
}
function So(t, e, s = {}, r) {
  if (kt("getPagedChildren()"), V(e.links, [u.PAGE]), s && s.embed && s.embed.includes(u.REPOSITORY)) throw new c(c.INVALID_PARAMS, "Repository Resource embeds on directory listings are not supported");
  try {
    return new ds(e.links, t, Co, "api:primary").getPage(s, r);
  } catch (n) {
    return S.reject(n);
  }
}
function ct(t, e, s, r, n) {
  const o = x(t);
  return !n || n !== "rename" ? S.resolve(e.substring(e.lastIndexOf("/") + 1)) : C(s) && r && (r === u.REPO_METADATA || C(r) && r.reltype === u.REPO_METADATA) ? S.resolve(s.name || e.substring(e.lastIndexOf("/") + 1)) : Ic(o, { assetId: s.headers["asset-id"], links: he(s) }).then(((i) => i.result[T.REPO_NAME])).catch(((i) => {
    throw i.response ? it(i.response) : new c(i.code, i.message, i.underlyingError, i.response, i.additionalData);
  }));
}
const No = ns("AdobeDCX.createAsset", (function(t, e, s, r, n, o, i = {}, a, d, h, l, p) {
  kt("createAsset()"), E(["service", t, "object"], ["parentDir", e, "object"], ["relPath", s, "string"], ["createIntermediates", r, "boolean"], ["contentType", n, "string"], ["respondWith", o, ["string", "object"], !0], ["additionalHeaders", i, "object", !0], ["repoMetaPatch", h, "object", !0]), o || p !== "rename" || (o = u.REPO_METADATA);
  const _ = C(o) ? JSON.stringify(o) : o;
  return ut(t, e, [u.CREATE]).then(((f) => {
    const m = J(f, u.CREATE, { path: s, intermediates: r.toString(), respondWith: _, mode: "id", repoMetaPatch: h, nameConflictPolicy: p }), y = Object.assign({}, { [b.CONTENT_TYPE]: n }, i), P = x(t), I = a ? Je(a, d) : void 0, R = I ? Be(I) : 0;
    return a && ur(e, R) ? Rt({ service: P, contentType: n, relation: u.PRIMARY, asset: e, dataOrSliceCallback: a, size: R, relPath: s, createIntermediates: r, respondWith: o, repoMetaPatch: h, additionalHeaders: i, progressCb: l, nameConflictPolicy: p }).then((({ result: D, response: O }) => ct(t, s, O, o, p).then(((N) => ({ result: L(xe({ name: N }, D)), response: O }))))) : S.resolve().then((() => ne(this, void 0, void 0, (function* () {
      const D = Y(a) ? yield a(0, R) : I;
      return P.invoke(v.POST, m, y, D, { responseType: "json", isStatusValid: k([413]), reuseRequestDesc: { id: "createAsset", method: v.POST, href: m, headers: y, progress: l } }).then(((O) => {
        var N;
        if (O.statusCode === 413) return Rt({ service: P, contentType: n, relation: u.PRIMARY, asset: e, dataOrSliceCallback: a, size: Be(Je(a, d)), relPath: s, createIntermediates: r, respondWith: o, repoMetaPatch: h, additionalHeaders: i, progressCb: l, nameConflictPolicy: p }).catch(((re) => {
          var ge;
          if (re.problemType === Z.ASSET_NAME_CONFLICT) {
            const Pe = { assetId: (ge = re.response.response) === null || ge === void 0 ? void 0 : ge["repo:assetId"], links: he(re.response) };
            return Rt({ service: P, contentType: n, relation: u.PRIMARY, asset: Pe, dataOrSliceCallback: a, size: Be(Je(a, d)), relPath: s, createIntermediates: r, respondWith: o, repoMetaPatch: h, additionalHeaders: i, progressCb: l, nameConflictPolicy: p });
          }
          throw re;
        })).then((({ result: re, response: ge }) => ct(t, s, ge, o, p).then(((Pe) => ({ result: L(xe({ name: Pe }, re)), response: ge })))));
        let M;
        e.path && (M = dn(e.path, s));
        const Q = he(O), X = O.headers;
        if (!((N = X[b.CONTENT_TYPE]) === null || N === void 0) && N.includes("multipart/mixed")) {
          const re = hr(O)[1];
          throw re.statusCode === 404 ? new c(c.ASSET_NOT_FOUND, "Asset was created successfully but repository metadata could not be found.", void 0, O) : re.statusCode === 403 ? new c(c.FORBIDDEN, "Asset was created successfully but Permission denied for fetching repository metadata.", void 0, O) : Gs("Unexpected Server Response", void 0, O);
        }
        const le = C(O.response) ? O.response : { etag: "", md5: "" }, be = X["asset-id"] || X["x-resource-id"], Oe = e.repositoryId;
        pe("assetId", be);
        let q = le.etag, Me = le.md5;
        o == null && (q = X.etag, Me = X["content-md5"]);
        const Ee = C(O.response) && o && (o === u.REPO_METADATA || C(o) && o.reltype === u.REPO_METADATA) ? se(O.response) : {};
        O.response && (Ee.representations = O.response.representations || O.response[T.REPO_REPRESENTATIONS]);
        const Lt = oe(t);
        return Lt && Lt.setValueWithAsset(Q, Ee), ct(t, s, O, o, p).then(((re) => ({ result: L(xe({ name: re }, Ee, L({ links: Q, assetId: be, etag: q, md5: Me, repositoryId: Oe, format: n, path: M }))), response: O })));
      }));
    }))));
  }));
}));
function Do(t, e, s, r, n = {}, o, i, a, d, h) {
  kt("createAssetForGuest()"), E(["service", t, "object"], ["relPath", e, "string"], ["contentType", s, "string"], ["respondWith", r, ["string", "object"], !0], ["additionalHeaders", n, "object", !0], ["repoMetaPatch", a, "object", !0]), r || h !== "rename" || (r = u.REPO_METADATA);
  const l = C(r) ? JSON.stringify(r) : r, p = x(t);
  return (function(_, f, m, y, P) {
    F("getCreateLinkForGuestUser"), E(["svc", _, "object"], ["assetPath", f, "string"]);
    const I = { path: f, mode: "id", intermediates: "true", repoMetaPatch: y, respondWith: m, nameConflictPolicy: P }, R = x(_), D = ze(fc, R);
    return S.resolve(Fe(D, L(I)));
  })(p, e, l, a, h).then(((_) => {
    const f = Object.assign({}, { [b.CONTENT_TYPE]: s }, n), m = o ? Je(o, i) : void 0, y = m ? Be(m) : 0;
    return o && y > cs ? Rs({ service: p, contentType: s, relation: u.PRIMARY, dataOrSliceCallback: o, size: y, relPath: e, respondWith: r, repoMetaPatch: a, additionalHeaders: n, progressCb: d, nameConflictPolicy: h }).then((({ result: P, response: I }) => ct(t, e, I, r, h).then(((R) => ({ result: L(xe({ name: R }, P)), response: I }))))) : S.resolve().then((() => ne(this, void 0, void 0, (function* () {
      const P = Y(o) ? yield o(0, y) : m;
      return p.invoke(v.POST, _, f, P, { responseType: "json", isStatusValid: k([413]), reuseRequestDesc: { id: "createAssetForGuest", method: v.POST, href: _, headers: f, progress: d } }).then(((I) => {
        var R;
        if (I.statusCode === 413) return Rs({ service: p, contentType: s, relation: u.PRIMARY, dataOrSliceCallback: o, size: Be(Je(o, i)), relPath: e, respondWith: r, repoMetaPatch: a, additionalHeaders: n, progressCb: d, nameConflictPolicy: h }).catch(((q) => {
          if (q.problemType === Z.ASSET_NAME_CONFLICT) return Rs({ service: p, contentType: s, relation: u.PRIMARY, dataOrSliceCallback: o, size: Be(Je(o, i)), relPath: e, respondWith: r, repoMetaPatch: a, additionalHeaders: n, progressCb: d, nameConflictPolicy: h });
          throw q;
        })).then((({ result: q, response: Me }) => ct(t, e, Me, r, h).then(((Ee) => ({ result: L(xe({ name: Ee }, q)), response: Me })))));
        const D = he(I), O = I.headers;
        if (!((R = O[b.CONTENT_TYPE]) === null || R === void 0) && R.includes("multipart/mixed")) {
          const q = hr(I)[1];
          throw q.statusCode === 404 ? new c(c.ASSET_NOT_FOUND, "Asset was created successfully but repository metadata could not be found.", void 0, I) : q.statusCode === 403 ? new c(c.FORBIDDEN, "Asset was created successfully but Permission denied for fetching repository metadata.", void 0, I) : Gs("Unexpected Server Response", void 0, I);
        }
        const N = C(I.response) ? I.response : { etag: "", md5: "" }, M = O["asset-id"] || O["x-resource-id"], Q = O["repository-id"];
        let X = N.etag, le = N.md5;
        r == null && (X = O.etag, le = O["content-md5"]);
        const be = C(I.response) && r && (r === u.REPO_METADATA || C(r) && r.reltype === u.REPO_METADATA) ? se(I.response) : {}, Oe = oe(t);
        return Oe && Oe.setValueWithAsset(D, be), ct(t, e, I, r, h).then(((q) => ({ result: L(xe({ name: q }, be, L({ links: D, assetId: M, etag: X, md5: le, format: s, repositoryId: Q, path: e }))), response: I })));
      }));
    }))));
  }));
}
const ls = B("dcx:assets:discoverable");
function Qc(t, e = {}, s) {
  ls("getDiscoverableAssets()"), E(["svc", t, "object"], ["pageOpts", e, "object"]);
  const r = x(t);
  return Bn(t, s).then(((n) => new ds(n.assetLinks, r, ed, "api:primary").getPage(e, s))).then(((n) => ({ result: n.response.response, paged: n.paged, response: n.response })));
}
function ed(t) {
  ls("discoverableAssetTransformer()");
  const e = t[T.EMBEDDED][u.REPO_METADATA], s = se(e, t[T.EMBEDDED]);
  return s.links = de({}, t.links, e._links), [s.assetId, s];
}
function td(t) {
  ls("discoverableReposTransformer()");
  const e = t[T.EMBEDDED][u.PRIMARY], s = ir(e);
  return s.links = e._links, [s.repositoryId, s];
}
function sd(t, e = {}, s) {
  ls("getDiscoverableRepos()"), E(["svc", t, "object"], ["pageOpts", e, "object"]);
  const r = x(t), n = ze("/repositories", r);
  return S.resolve(void 0).then((() => ne(this, void 0, void 0, (function* () {
    const o = oe(t);
    let i;
    return o && (i = yield o.getRepositoryLinks()), !i && (i = he(yield r.invoke(v.HEAD, n, s, void 0, { isStatusValid: k() }))), o && o.setRepositoryLinks(i), new ds(i, r, td).getPage(e, s);
  })))).then(((o) => ({ result: o.response.response, paged: o.paged, response: o.response })));
}
B("dcx:assets:factory");
const ko = B("dcx:assets:indexdocument");
function rd(t, e) {
  ko("getIndexDocument()"), E(["svc", t, "object"]);
  const s = x(t), r = ze("/index", s);
  return s.invoke(v.GET, r, e, void 0, { responseType: "json", isStatusValid: k() }).then(((n) => ({ result: nd(n.response), response: n.response })));
}
function nd(t) {
  ko("deserializeIndexDocument()");
  const e = t.children.map(((s) => {
    const r = se(s[T.EMBEDDED][u.REPO_METADATA]), n = ir(s[T.EMBEDDED][u.REPOSITORY]);
    return r.embedded = { RepositoryResource: n }, r;
  }));
  return { regions: t[T.REPO_REGIONS], assignedDirectories: e, links: t._links };
}
const od = 1e5;
class id {
  constructor(e = 1e5, s = "SESSION") {
    if (this.values = {}, this.maxEntries = od, this.promiseToResolveMap = /* @__PURE__ */ new Map(), e <= 0) throw new c(c.INVALID_PARAMS, "Cache Max enteries must be great than 0.");
    this.maxEntries = e, this.defaultSessionKey = s;
  }
  clear() {
    this.promiseToResolveMap.forEach(((e) => {
      e.call(void 0);
    }));
    for (const e in this.values) this.values[e].clear();
    this.values = {};
  }
  getKey(e) {
    if (e.assetId || typeof e != "object") return e.assetId;
  }
  getValueWithAsset(e) {
    if (!e.assetId && typeof e == "object") return;
    const s = this.getKey(e);
    return s ? this.get(s, e.repositoryId) : void 0;
  }
  setPending(e, s = this.defaultSessionKey) {
    let r;
    this.values[s] || (this.values[s] = /* @__PURE__ */ new Map());
    const n = this.values[s].get(e);
    if (n && n instanceof Promise) return this.promiseToResolveMap.get(n);
    const o = new Promise(((i) => {
      r = i;
    }));
    return this.values[s].set(e, o), this.promiseToResolveMap.set(o, r), o.then((() => this.promiseToResolveMap.delete(o))).catch((() => this.promiseToResolveMap.delete(o))), r;
  }
  get(e, s = this.defaultSessionKey) {
    if (this.values[s] && s in this.values) return this.values[s].get(e);
  }
  setValueWithAsset(e, s) {
    if (!e) return;
    const r = this.getKey(s);
    if (r) {
      const n = s.repositoryId || this.defaultSessionKey;
      this.set(e, r, n);
    }
  }
  set(e, s, r = this.defaultSessionKey) {
    if (this.values[r]) {
      if (this.values[r] && this.values[r].get(s) instanceof Promise) {
        const n = this.values[r].get(s), o = this.promiseToResolveMap.get(n);
        this.promiseToResolveMap.delete(n), o && o(e);
      }
    } else this.values[r] = /* @__PURE__ */ new Map();
    if (this.values[r].size >= this.maxEntries) {
      const n = this.values[r].keys().next().value;
      this.values[r].delete(n);
    }
    this.values[r].set(s, Promise.resolve(e));
  }
  delete(e, s = this.defaultSessionKey) {
    this.values[s] && this.values[s].delete(e);
  }
  deleteWithAsset(e) {
    const s = this.getKey(e);
    s && this.delete(s, e.repositoryId);
  }
}
class Lo extends id {
  constructor(e = 1e5, s = 2592e6) {
    super(e, "SESSION"), this.timestampsOnLinkCreation = 0, this.maxCachePeriodMS = 0, this.maxCachePeriodMS = s;
  }
  isLinkExpired() {
    return this.maxCachePeriodMS < Date.now() - this.timestampsOnLinkCreation;
  }
  setIndexLinks(e) {
    this.set(e, "INDEX", "SESSION"), this.timestampsOnLinkCreation = Date.now();
  }
  getIndexLinks() {
    if (!this.isLinkExpired()) return this.get("INDEX", "SESSION");
  }
  setIndexRepository(e) {
    this.indexRepository = e;
  }
  getIndexRepository() {
    return this.indexRepository;
  }
  setRepositoryLinks(e) {
    this.set(e, "/Repositories", "SESSION"), this.timestampsOnLinkCreation = Date.now();
  }
  getRepositoryLinks() {
    if (!this.isLinkExpired()) return this.get("/Repositories", "SESSION");
  }
}
var tn, sn;
(function(t) {
  t.IMAGE_JPG = "image/jpg", t.IMAGE_PNG = "image/png", t.IMAGE_GIF = "image/gif", t.VIDEO_MP4 = "video/mp4", t.VIDEO_METADATA = "application/vnd.adobe.ccv.videometadata";
})(tn || (tn = {})), (function(t) {
  t.NONE = "none", t.EMBEDDED = "embedded";
})(sn || (sn = {}));
B("dcx:assets:versionset");
const ad = B("dcx:assets:versionset:leaf");
function cd(t) {
  ad("deserializeVersionSet()");
  const e = { versionCount: t[De.TOTAL_CHILDREN], repositoryId: t[De.REPO_ID], assetId: t[T.REPO_ASSET_ID], links: {}, versions: [] }, s = t.children || t[T.CHILDREN];
  return s && s.length > 0 && (e.versions = s.map(((r) => fr(r)))), e.links = t._links, e;
}
function rt(t, e, s, r) {
  var n, o = arguments.length, i = o < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, s) : r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") i = Reflect.decorate(t, e, s, r);
  else for (var a = t.length - 1; a >= 0; a--) (n = t[a]) && (i = (o < 3 ? n(i) : o > 3 ? n(e, s, i) : n(e, s)) || i);
  return o > 3 && i && Object.defineProperty(e, s, i), i;
}
const dd = "0", hd = "md5";
class ld {
  constructor(e, s, r, n, o, i) {
    this.id = e, this.etag = s, this.version = r, this.md5 = n, this.length = o, this.type = i;
  }
}
class ud {
  constructor(e, s, r) {
    this.compositeId = e, this.compositeAssetId = s, this.repositoryId = r, this.records = {};
  }
  addUploadRecord(e, s) {
    E(["componentId", e, "string"], ["record", s, "object"]), this.records[e] = s;
  }
  getComponentDescriptor(e) {
    const s = this._checkRAPIComponentParams(e);
    return JSON.stringify((function(r, n, o, i) {
      try {
        _n(i, "UploadRecord", ["id", "string"], ["version", "string"], ["length", "number"], ["etag", "string"], ["type", "string"]);
      } catch (d) {
        throw new c(c.INVALID_STATE, "Invalid record data", d);
      }
      const a = { versionId: dd, componentId: i.id, cloudAssetId: r, compositeId: n, repositoryId: o, componentRevisionId: i.version, type: i.type, cloudExpiration: void 0, size: i.length, etag: i.etag, hashType: hd, hashValue: i.md5 };
      return L(a);
    })(this.compositeAssetId, this.compositeId, this.repositoryId, s));
  }
  getComponentURL(e, s) {
    const r = this._checkRAPIComponentParams(s);
    return e.getCompositeComponentUrlForDownload({ repositoryId: this.repositoryId, assetId: this.compositeAssetId }, s, r.length, r.version);
  }
  getComponent(e, s, r) {
    const n = this._checkRAPIComponentParams(s);
    return e.getCompositeComponent({ repositoryId: this.repositoryId, assetId: this.compositeAssetId }, s, n.version, r);
  }
  _checkRAPIComponentParams(e) {
    if (!this.repositoryId) throw new c(c.INVALID_STATE, "Repository ID must be defined.", void 0, void 0, { componentId: e });
    const s = this.records[e];
    if (!s) throw new c(c.INVALID_PARAMS, "UploadRecord does not exist", void 0, void 0, { componentId: e });
    return s;
  }
}
function rn(t, e, s) {
  return E(["compositeId", t, "string", !0], ["compositeAssetId", e, "string"], ["repositoryId", s, ["string", "undefined"]]), new ud(t, e, s);
}
function pd(t, e, s, r, n, o) {
  return E(["componentId", t, "string"], ["etag", e, "string"], ["version", s, "string"], ["md5", r, "string"], ["length", n, "number"], ["type", o, "string"]), new ld(t, e, s, r, n, o);
}
function _d(t, e, s) {
  E(["repoUploadResults", e, "object"], ["compositeId", s, "string", !0]), _n(e, "repoUploadResults", ["result", "object"]);
  const r = e.asset || e.compositeAsset, { result: n } = e;
  if (!(r.assetId && r.repositoryId || r.links || n.links)) throw new c(c.INVALID_PARAMS, "AdobeRepoUploadResult#asset object missing repositoryId or assetId, and links");
  const o = pd(n.id, n.etag, n.revision, n.md5, n.length, n.type);
  let i;
  if (r.assetId && r.repositoryId) i = S.resolve(rn(s, r.assetId, r.repositoryId));
  else {
    E(["session", t, "object"]);
    const a = r.links || n.links, d = Dn(a, [u.PRIMARY, u.ID, u.PATH, u.COMPONENT]), h = J(a, d, { component_id: "manifest" });
    i = t.headHTTPResource(h).then(((l) => {
      const p = l.headers["repository-id"], _ = l.headers["asset-id"];
      if (!p || !_) throw new c(c.INVALID_DATA, "Fetched data missing repositoryId or assetId");
      return rn(s, _, p);
    }));
  }
  return i.then(((a) => (a.addUploadRecord(n.id, o), a)));
}
const nn = B("dcx:repoapisession"), fd = ue.getInstance(), on = "+dcx";
let $e = class {
  constructor(t, e, s) {
    this._authenticationAllowList = ["adobe.com", "adobe.io", "adobelogin.com", "fotolia.net"], this._blockUploadThreshold = cs, E(["httpService", t, "object"], ["server", e, "string"]), this._service = t, this._service._repoAPIBaseUrl = e;
    const r = Ds(e);
    if (!r) throw new c(c.INVALID_PARAMS, "Could not determine endpoint from: " + e);
    this._endPoint = r, C(s) && Y(s.getIndexLinks) ? this._linksCache = s : this._linksCache = new Lo();
  }
  get serviceConfig() {
    return { service: this._service, cache: this._linksCache };
  }
  get blockUploadThreshold() {
    return this._blockUploadThreshold;
  }
  set blockUploadThreshold(t) {
    qe("threshold", t, "+number"), this._blockUploadThreshold = t;
  }
  get blockDownloadThreshold() {
    return Ao();
  }
  set blockDownloadThreshold(t) {
    qe("threshold", t, "+number"), Pc(t);
  }
  createAsset(t, e, s, r, n, o, i, a, d, h, l) {
    return No(this._service, t, e, s, r, n, o, i, a, d, h, l);
  }
  createAssetForGuest(t, e, s, r, n, o, i, a, d) {
    return Do(this._service, t, e, s, r, n, o, i, a, d);
  }
  createComposite(t, e, s, r, n, o, i, a, d, h) {
    if (nn("createComposite()"), E(["parentDir", t, "object"], ["relPath", e, "string"], ["contentType", s, "string"]), !s.endsWith(on)) throw new c(c.INVALID_PARAMS, `Composite contentType must end in "${on}"`);
    if (!Qt(t)) throw new c(c.INVALID_PARAMS, "parentDir must contain links or repositoryId & assetId or path");
    return this.createAsset(t, e, !0, o && s.endsWith("dcx") ? s + "ucf" : s, r, n, o, i, a, d, h).catch(((l) => {
      if (!l.response || l.response.statusCode !== 409) throw Gs("Error creating composite", l, l.response);
      if (l.response.headers.link) {
        const p = he(l.response);
        this._linksCache.setValueWithAsset(p, { assetId: l.response.headers["asset-id"] || l.response.headers["x-resource-id"], repositoryId: t.repositoryId });
      }
      throw new c(c.ALREADY_EXISTS, "Composite already exists at " + e, void 0, l.response);
    }));
  }
  copyResources(t, e, s, r, n, o) {
    return vc(this._service, t, e, s, r, n, o);
  }
  getIndexLinks(t) {
    return xn(this.serviceConfig, t);
  }
  getIndexRepository(t) {
    return Bn(this.serviceConfig, t);
  }
  getIndexDocument(t) {
    return rd(this.serviceConfig, t);
  }
  getDiscoverableAssets(t = {}, e) {
    return Qc(this.serviceConfig, t, e);
  }
  getDiscoverableRepos(t = {}, e) {
    return sd(this.serviceConfig, t, e);
  }
  headHTTPResource(t, e) {
    return or(this._service, t, e);
  }
  headCompositeManifest(t, e) {
    return this.fetchLinksIfMissing(t, [u.COMPONENT], e).then((() => Hc(this._service, t, e)));
  }
  resolveAsset(t, e = "id", s, r, n) {
    return lr(this.serviceConfig, t, e, s, r, n);
  }
  headPrimaryResource(t, e) {
    return this.fetchLinksIfMissing(t, [u.PRIMARY], e).then((() => Qn(this.serviceConfig, t, e)));
  }
  getRepoMetadata(t, e) {
    return t.assetId && pe("assetId", t.assetId), this.useLinkOrResolveResource(t, u.REPO_METADATA, "json", e).then(((s) => ({ result: se(s.response.response), response: s.response })));
  }
  updateRepoMetadata(t, e) {
    return this.fetchLinksIfMissing(t, [u.REPO_METADATA], e).then((() => so(this.serviceConfig.service, t, e)));
  }
  getEmbeddedMetadata(t, e = "json", s) {
    return E(["asset", t, "object"], ["format", e, "enum", !1, ["json", "xml"]]), this.fetchLinksIfMissing(t, [u.EMBEDDED_METADATA], s).then((() => Lc(this._service, t, e)));
  }
  putEmbeddedMetadata(t, e, s, r = "json", n) {
    return E(["asset", t, "object"], ["data", e, ["string", "object", "object[]"]], ["etag", s, "string", !0], ["format", r, "enum", !1, ["json", "xml"]]), this.fetchLinksIfMissing(t, [u.EMBEDDED_METADATA], n).then((() => wc(this._service, t, e, s, r, n)));
  }
  patchEmbeddedMetadata(t, e, s, r) {
    return E(["asset", t, "object"], ["data", e, ["string", "object", "object[]"]], ["etag", s, "string", !0]), this.fetchLinksIfMissing(t, [u.EMBEDDED_METADATA], r).then((() => Mc(this._service, t, e, s, r)));
  }
  getDirectory(t, e, s) {
    return this.fetchLinksIfMissing(t, [u.PAGE], s).then((() => So(this._service, t, e, s).then(((r) => ({ result: Co(r.paged.data)[1], paged: r.paged, response: r.response })))));
  }
  getDirectoryByURL(t) {
    return Jc(this._service, t).then(((e) => ({ response: e.response, result: se(e.result) })));
  }
  getLinksForAsset(t, e) {
    return to(this.serviceConfig, t, e);
  }
  getACLPolicy(t, e) {
    return this.fetchLinksIfMissing(t, [u.ACL_POLICY], e).then((() => ho(this._service, t, e)));
  }
  getPrimaryResource(t, e, s) {
    const r = {};
    return this._withSourcePromise(r).then((() => this.fetchLinksIfMissing(t, [u.PRIMARY], s))).then((() => Jn.call(r, this._service, t, e, s)));
  }
  updatePrimaryResource(t, e, s, r, n, o, i) {
    return this.fetchLinksIfMissing(t, [u.PRIMARY], i).then((() => xc(this._service, t, e, s, r, n, o, i)));
  }
  getRepositoryResource(t, e) {
    return this.fetchLinksIfMissing(t, [u.REPOSITORY], e).then((() => ro(this._service, t, e)));
  }
  getVersions(t, e, s) {
    return this.fetchLinksIfMissing(t, [u.PAGE], s).then((() => Vc(this._service, t, e, s).then(((r) => ({ result: cd(r.result), response: r.response, paged: r.paged })))));
  }
  getVersionResource(t, e, s) {
    return this.fetchLinksIfMissing(t, [u.PAGE], s).then((() => Ro(this._service, t, e, s).then(((r) => ({ result: fr(r.result), response: r.response })))));
  }
  blockDownloadAsset(t, e, s, r, n, o, i, a) {
    if (typeof t == "string") return Qr(this._service, t, e, s, r, n, o, i, a);
    const d = {};
    return this._withSourcePromise(d).then((() => this.fetchLinksIfMissing(t, [u.PRIMARY]))).then((() => Qr.call(d, this._service, t, e, s, r, n, o, i, a)));
  }
  fetchLinksIfMissing(t, e, s) {
    return ut(this.serviceConfig, t, e, void 0, s);
  }
  useLinkOrResolveResource(t, e, s, r) {
    return _o(this.serviceConfig, t, e, s, r).then(((n) => (t.links !== n.result.links && (t.links = de(t.links || {}, n.result.links), this._linksCache.setValueWithAsset(t.links, t)), n)));
  }
  getLinkHrefForAsset(t, e, s = "id", r) {
    return this.fetchLinksIfMissing(t, [e], r).then(((n) => H(n, e, s)));
  }
  getEffectivePrivileges(t, e) {
    return this.fetchLinksIfMissing(t, [u.EFFECTIVE_PRIVILAGES], e).then((() => co(this._service, t, e)));
  }
  checkACLPrivilege(t, e, s, r) {
    return this.fetchLinksIfMissing(t, [u.ACCESS_CHECK], r).then((() => lo(this._service, t, e, s, r)));
  }
  headAppMetadata(t, e) {
    return this.fetchLinksIfMissing(t, [u.APP_METADATA], e).then((() => no(this.serviceConfig, t, e)));
  }
  getAppMetadata(t, e, s) {
    return this.fetchLinksIfMissing(t, [u.APP_METADATA], s).then((() => oo(this._service, t, e, s)));
  }
  putAppMetadata(t, e, s, r) {
    return this.fetchLinksIfMissing(t, [u.APP_METADATA], r).then((() => io(this._service, t, e, s, r)));
  }
  patchAppMetadata(t, e, s, r) {
    return this.fetchLinksIfMissing(t, [u.APP_METADATA], r).then((() => ao(this._service, t, e, s)));
  }
  getCompositeManifestUrl(t, e, s) {
    E(["asset", t, "object"], ["version", e, "string", !0]);
    const r = this._getAsAdobeAsset(t);
    return r.version = e || r.version, this.fetchLinksIfMissing(r, [u.MANIFEST], s).then((() => hs(this._service, r, e, s)));
  }
  getCompositeManifest(t, e, s, r) {
    E(["asset", t, "object"], ["version", e, "string", !0], ["etag", s, "string", !0]);
    const n = this._getAsAdobeAsset(t);
    return n.version = e || n.version, this.fetchLinksIfMissing(n, [u.MANIFEST], r).then((() => Gc(this._service, n, e, s, r)));
  }
  getManifestAndComponentsByPath(t, e, s, r, n) {
    return Yc(this.serviceConfig.service, t, e, s, r, n);
  }
  getRendition(t, e, s, r, n) {
    return this.fetchLinksIfMissing(t, [u.RENDITION]).then((() => Uc(this._service, t, e, s, r, n)));
  }
  getCompositeComponentUrlForDownload(t, e, s, r, n) {
    var o;
    const i = this._getAsAdobeAsset(t), a = (o = this._isDCXComponentLike(t) ? t.length : s) !== null && o !== void 0 ? o : 0, { id: d, revision: h } = this._resolveComponentIdAndRevision(t, e, r);
    return a > this.blockDownloadThreshold ? Po(this.serviceConfig, i, d, h, n).then((({ response: l, result: p }) => ({ response: l, isPresignedUrl: !0, url: p }))) : this.getCompositeComponentUrl(i, d, h, n).then(((l) => ({ response: void 0, url: l, isPresignedUrl: !1 })));
  }
  getCompositeComponentUrl(t, e, s, r) {
    const n = this._getAsAdobeAsset(t), { id: o, revision: i } = this._resolveComponentIdAndRevision(t, e, s, !1);
    return this.fetchLinksIfMissing(n, [u.COMPONENT], r).then((() => (E(["asset", n, "object"], ["componentId", o, "string"], ["componentRevision", i, "string", !0]), Ir(this._service, n, o, i))));
  }
  getCompositeComponentByPath(t, e, s, r, n) {
    return Wc(this._service, this._getAsAdobeAsset(t), e, s, r, n);
  }
  getCompositeComponent(t, e, s, r, n, o) {
    const i = this._getAsAdobeAsset(t), { id: a, revision: d } = this._resolveComponentIdAndRevision(t, e, s);
    return i.assetId && pe("assetId", i.assetId), e && pe("componentId", e), o && pe("componentSize", String(o)), this.fetchLinksIfMissing(i, [u.COMPONENT], n).then((() => (E(["asset", t, "object"], ["componentId", a, "string"], ["componentRevision", d, "string"], ["responseType", r, "enum", !0, nr]), Kc(this._service, i, a, d, r, n, this._isDCXComponentLike(t) ? t.length : o))));
  }
  putCompositeComponent(t, e, s, r, n, o, i, a, d, h) {
    if (E(["asset", t, "object"], ["componentId", e, "string"], ["contentType", r, "string"], ["maybeIsNew", n, "boolean", !0], ["size", o, "number", !0], ["md5", i, "string", !0]), n && !Xt(e)) throw new c(c.INVALID_PARAMS, "Component id is not a uuid");
    Xt(e) || fd.warn("Existing component id is not a uuid");
    const l = this._getAsAdobeAsset(t);
    return (l.assetId || l.id) && pe("assetId", l.assetId || l.id), pe("componentId", e), o && pe("componentSize", String(o)), this.fetchLinksIfMissing(l, [u.COMPONENT, u.BLOCK_UPLOAD_INIT], d).then((() => Xc(this.serviceConfig, t, e, s, r, n, o, i, a, d, h)));
  }
  getCompositeComponentsUrlsForUpload(t, e, s) {
    return Zc(this._service, t, e, s);
  }
  performBulkRequest(t, e, s, r) {
    return this.fetchLinksIfMissing(t, [u.BULK_REQUEST], r).then((() => as(this._service, t, e, s, r)));
  }
  updateCompositeManifest(t, e, s, r = 1, n, o) {
    nn("updateCompositeManifest()"), E(["asset", t, "object"], ["manifest", e, ["object", "string"]], ["overwrite", s, "boolean"], ["validationLevel", r, "+number"], ["etag", n, "string", !0]);
    const i = this._getAsAdobeAsset(t);
    return this.fetchLinksIfMissing(i, [u.MANIFEST], o).then((() => Vs(this._service, i, e, s, r, n, o)));
  }
  patchVersions(t, e, s, r) {
    return E(["asset", t, "object"], ["patchDoc", e, ["string", "array"]], ["etag", s, "string", !0]), this.fetchLinksIfMissing(t, [u.VERSION_HISTORY], r).then((() => jc(this._service, t, e, s, r)));
  }
  patchACLPolicy(t, e, s, r) {
    return E(["asset", t, "object"], ["policy", e, ["string", "object"]], ["etag", s, "string", !0]), this.fetchLinksIfMissing(t, [u.VERSION_HISTORY], r).then((() => uo(this._service, t, e, s, r)));
  }
  deleteACLPolicy(t, e) {
    return E(["asset", t, "object"]), this.fetchLinksIfMissing(t, [u.ACL_POLICY], e).then((() => po(this._service, t, e)));
  }
  copyAsset(t, e, s, r, n, o, i) {
    return jn(this.serviceConfig, t, e, s, r, n, o, i);
  }
  moveAsset(t, e, s, r, n, o) {
    return pe("sourceAsset.assetId", t.assetId), pe("targetAsset.assetId", e.assetId), Vn(this.serviceConfig, t, e, s, r, n, o);
  }
  deleteAsset(t, e, s, r) {
    return Hn(this.serviceConfig, { repositoryId: t.repositoryId, path: t.path, assetId: t.assetId }, e, s, r).then(((n) => (this._linksCache.deleteWithAsset(t), n)));
  }
  discardAsset(t, e, s, r) {
    return Fn(this.serviceConfig, { repositoryId: t.repositoryId, path: t.path, assetId: t.assetId }, e, s, r);
  }
  restoreAsset(t, e, s) {
    return Gn(this.serviceConfig, t, e, s);
  }
  packageAssets(t, e, s, r, n) {
    return $n(this.serviceConfig, t, e, s, r, n);
  }
  performOperation(t, e) {
    return we(this.serviceConfig, e).then(((s) => Ve(this._service, s, t, e)));
  }
  performBatchOperation(t, e) {
    return we(this.serviceConfig).then(((s) => Qa(this._service, s, t, e)));
  }
  uploadResultsFromAdobeRepoUploadResult(t, e) {
    return _d(this, t, e);
  }
  updateCachedAssetLinks(t) {
    if (!t.assetId) throw new c(c.INVALID_PARAMS, "Asset must contain an assetId");
    this._linksCache.setValueWithAsset(t.links || t._links, t);
  }
  updateCachedIndexLinks(t) {
    if (!t) throw new c(c.INVALID_PARAMS, "Index LinkSet must not be null");
    this._linksCache.setIndexLinks(t);
  }
  getLinksCache() {
    return this._linksCache;
  }
  setLinksCache(t) {
    this._linksCache = t;
  }
  clearLinksCache() {
    this._linksCache.clear();
  }
  _resolveComponentIdAndRevision(t, e, s, r = !0) {
    var n;
    if (this._isDCXComponentLike(t)) return { revision: t.version, id: t.id };
    if (!e) throw new c(c.INVALID_PARAMS, "Missing componentId.");
    if (r === !1 || s) return { revision: s, id: e };
    if (!xs(t) || !e) throw new c(c.INVALID_PARAMS, "Could not determine component revision");
    const o = (n = t.current) === null || n === void 0 ? void 0 : n.getComponentWithId(e);
    if ((o == null ? void 0 : o.version) === void 0) throw new c(c.INVALID_PARAMS, "Could not determine component revision");
    return { revision: o.version, id: e };
  }
  _isDCXComponentLike(t) {
    return !!C(t) && t.owner != null && Wr(t.owner);
  }
  _withSourcePromise(t) {
    return S.resolve(void 0, t);
  }
  _getAsAdobeAsset(t) {
    if (typeof t != "object" || Array.isArray(t)) throw new c(c.INVALID_PARAMS, "Invalid asset-like object.");
    if (Qt(t)) return t;
    let e, s = {};
    if (("repositoryId" in t || "assetId" in t || "links" in t || "version" in t) && (s = { repositoryId: t.repositoryId, assetId: t.assetId, links: t.links, version: t.version }), Wr(t) && (e = t._core), this._isDCXComponentLike(t) || e) {
      const o = t, i = e || (o && o.owner && o.owner._core ? o.owner._core : void 0);
      if (i) {
        const a = i._getSourceAssetInfoOfComponent(s);
        a && typeof a == "object" && (s.assetId = a.compositeAssetId || s.assetId, s.repositoryId = a.compositeRepositoryId || s.repositoryId, s.links = a.links || s.links, s.version = a.version || s.version);
      }
    }
    const r = t, n = t;
    return s.assetId = s.assetId ? s.assetId : r.owner ? r.owner.compositeAssetId : n.compositeAssetId, s.repositoryId = s.repositoryId ? s.repositoryId : r.owner ? r.owner.compositeRepositoryId : n.compositeRepositoryId, s;
  }
  get authenticationAllowList() {
    return this._authenticationAllowList;
  }
  set authenticationAllowList(t) {
    if (!Array.isArray(t)) throw new c(c.INVALID_PARAMS, "Expecting an array.");
    this._authenticationAllowList = t;
  }
  _resolveUrl(t) {
    return Ds(t) ? t : dn(this._service._repoAPIBaseUrl || this._service.server, t);
  }
  registerLinks(t, e, s) {
    t = t._links || t;
    const r = { assetId: s || "urn:aaid:faux:" + Kt(), repositoryId: e || "faux-repo-id" };
    return this._linksCache.setValueWithAsset(t, r), r;
  }
};
rt([It], $e.prototype, "getRepoMetadata", null), rt([It], $e.prototype, "getAppMetadata", null), rt([It], $e.prototype, "getCompositeComponent", null), rt([It], $e.prototype, "putCompositeComponent", null), rt([It], $e.prototype, "moveAsset", null), $e = rt([Ba("AdobeRepoAPISession")], $e);
const Ed = (t, e, s) => new $e(t, e, s), gd = {
  local: "https://platform-cs-stage.adobe.io",
  stage: "https://platform-cs-stage.adobe.io",
  prod: "https://platform-cs.adobe.io"
}, Id = "AdobeExpressWeb", Td = "assets", Ad = "Upload failed. Please try again.", He = {
  UPLOAD_FAILED: {
    code: "UPLOAD_FAILED",
    message: Ad
  },
  URL_GENERATION_FAILED: {
    code: "URL_GENERATION_FAILED",
    message: "Failed to generate pre-signed URL"
  },
  REPOSITORY_REQUIRED: {
    code: "REPOSITORY_REQUIRED",
    message: "Repository is required for normal token uploads"
  },
  DIRECTORY_REQUIRED: {
    code: "DIRECTORY_REQUIRED",
    message: "Directory is required for normal token uploads"
  },
  REPOSITORY_REQUIRED_FOR_DIRECTORY: {
    code: "REPOSITORY_REQUIRED_FOR_DIRECTORY",
    message: "Repository is required for directory operations"
  },
  FAILED_TO_CREATE_ASSET: {
    code: "FAILED_TO_CREATE_ASSET",
    message: "Failed to create asset"
  }
}, md = {
  UPLOAD_STATUS: "x-express-upload-status"
};
function je(t, e, s, r) {
  return new (s || (s = Promise))((function(n, o) {
    function i(h) {
      try {
        d(r.next(h));
      } catch (l) {
        o(l);
      }
    }
    function a(h) {
      try {
        d(r.throw(h));
      } catch (l) {
        o(l);
      }
    }
    function d(h) {
      var l;
      h.done ? n(h.value) : (l = h.value, l instanceof s ? l : new s((function(p) {
        p(l);
      }))).then(i, a);
    }
    d((r = r.apply(t, [])).next());
  }));
}
const Se = B("dcx:http:auth");
class Vt {
  constructor(e, s, r) {
    this._authToken = e, this._apiKey = s, this._pendingAuth = !1, this._hasBaseRefreshCb = !1, this._authListeners = [], this._persistentListeners = [], this._authenticationAllowList = ["adobe.com", "adobe.io", "adobelogin.com", "fotolia.net"], this._authTokenScheme = "Bearer", E(["authToken", e, "string", !0], ["apiKey", s, "string", !0], ["refreshCb", r, "function", !0]), r && (this._hasBaseRefreshCb = !0, this.onChange(((n, o) => {
      n === "unauthenticated" && r.call(null, o);
    }), !0)), e && s || (Se("init unauthenticated"), this._pendingAuth = !0, setTimeout((() => {
      Se("after tick", this._pendingAuth), this._pendingAuth && this.refreshAuth();
    })));
  }
  get authenticationAllowList() {
    return this._authenticationAllowList;
  }
  set authenticationAllowList(e) {
    if (!Array.isArray(e)) throw new c(c.INVALID_PARAMS, "Expecting an array.");
    this._authenticationAllowList = e;
  }
  get isNoAuthMode() {
    return !this._hasBaseRefreshCb;
  }
  set isNoAuthMode(e) {
    this._hasBaseRefreshCb = !e;
  }
  get apiKey() {
    return this._apiKey;
  }
  get authToken() {
    return this._authToken;
  }
  get authTokenScheme() {
    return this._authTokenScheme;
  }
  set authTokenScheme(e) {
    this._authTokenScheme = e;
  }
  setAuthToken(e) {
    Se("setAuthToken"), this._authToken = e, this._pendingAuth = !1, this._authChanged("updated");
  }
  setApiKey(e) {
    this._apiKey = e;
  }
  resume() {
    Se("resume()"), this._pendingAuth = !1, this._authChanged("updated");
  }
  get pendingAuth() {
    return this._pendingAuth;
  }
  onChange(e, s = !1) {
    Se("onChange, persistent:", s);
    const r = this._authListeners.push(e) - 1;
    return s && this._persistentListeners.push(r), () => {
      try {
        s && (this._persistentListeners = this._persistentListeners.filter(((n) => n !== r))), delete this._authListeners[r];
      } catch {
      }
    };
  }
  clearListeners(e = !1) {
    if (Se("clearListeners, persistent:", e), e === !0) return this._authListeners = [], void (this._persistentListeners = []);
    this._authListeners = this._authListeners.map(((s, r) => {
      if (this._persistentListeners.includes(r)) return s;
    }));
  }
  get refreshPromise() {
    return this._refreshPromise;
  }
  _authChanged(e) {
    return je(this, void 0, void 0, (function* () {
      Se("authChanged", e), this._pendingAuth = e === "unauthenticated", queueMicrotask((() => je(this, void 0, void 0, (function* () {
        const s = [];
        this._authListeners.map(((r) => {
          if (typeof r == "function") {
            const n = r.call(null, e, this);
            n && typeof n == "object" && n.then && s.push(n);
          }
        })), yield Promise.all(s), e === "updated" && this._resolveRefresh();
      }))));
    }));
  }
  _resolveRefresh() {
    Se("_resolveRefresh"), this._refreshResolve && this._refreshResolve(this.getAuthData()), this._refreshResolve = void 0, this._refreshPromise = void 0;
  }
  refreshAuth() {
    return Se("refreshAuth"), this._refreshPromise || (this._refreshPromise = new Promise(((e) => {
      this._refreshResolve = e;
    })), this._authChanged("unauthenticated")), this._refreshPromise;
  }
  getAuthData() {
    return { authToken: this._authToken, apiKey: this._apiKey };
  }
  getAuth() {
    return je(this, void 0, void 0, (function* () {
      return Promise.resolve(this.getAuthData());
    }));
  }
  isAuthorizedURL(e) {
    const s = Xo(e);
    return this._authenticationAllowList.includes(s);
  }
  logout() {
    Se("logout"), this._apiKey = void 0, this._authToken = void 0, this._pendingAuth === !1 && (this._pendingAuth = !0, this._authChanged("unauthenticated"));
  }
  applyAuthHeaders(e, s) {
    const r = { "x-api-key": void 0, authorization: void 0 };
    return this.isAuthorizedURL(e) && (s["x-api-key"] !== null && this.apiKey && (r["x-api-key"] = this.apiKey), s.authorization !== null && this.authToken && (r.authorization = (this.authTokenScheme ? `${this.authTokenScheme} ` : "") + this.authToken)), s = L(Object.assign(Object.assign({}, s), r));
  }
}
const Fs = 12e4, Cs = 36e5, ye = B("dcx:http:xhr");
let Hs;
if (Hs = typeof window < "u" ? window.XMLHttpRequest : XMLHttpRequest, Hs == null) throw new c(c.INVALID_STATE, "XMLHttpRequest module not found.");
const te = { NO_ERROR: "", ABORTED: A.ABORTED, NETWORK: A.NETWORK_ERROR, TIMEOUT: A.TIMED_OUT, TOO_MANY_REDIRECTS: A.TOO_MANY_REDIRECTS, INSECURE_REDIRECT: A.INSECURE_REDIRECT };
class yd {
  constructor(e = {}) {
    this._autoParseJson = !1, this._bytesReported = 0, this._errorCode = te.NO_ERROR, this._isFetchRequest = !1, this._fetchAbort = () => {
    }, this._preferFetch = !1, this._sent = !1, this.headers = {}, this.responseType = "text", this._progressListeners = [];
    const { forceXhr: s, preCallback: r, postCallback: n, timeout: o, preferFetch: i } = e;
    this._preCallback = r, this._postCallback = n, this._timeout = o == null || o < 0 ? Fs : o, this._xhr = s ? new s() : new Hs(), this._xhr.timeout = Cs, this._preferFetch = i === !0, this._fetch = e.fetch ? e.fetch : typeof window < "u" && "fetch" in window && typeof window.fetch == "function" ? window.fetch.bind(window) : typeof self < "u" && "fetch" in self && typeof self.fetch == "function" ? self.fetch.bind(self) : typeof globalThis < "u" && "fetch" in globalThis && typeof globalThis.fetch == "function" ? globalThis.fetch.bind(globalThis) : void 0, this._parseFetchResponse = this._parseFetchResponse.bind(this), this.onProgress = this.onProgress.bind(this), this._autoParseJson = e.autoParseJson == null || e.autoParseJson, e.additionalNodeOptions && this._xhr.setNodeOptions && this._xhr.setNodeOptions(e.additionalNodeOptions), this._promise = new Promise(((a) => {
      this._resolve = a, this._xhr.addEventListener("abort", (() => {
        ye("aborted", this._errorCode, this._timeout), this._errorCode = this._errorCode || te.ABORTED, this._finalize();
      })), this._xhr.addEventListener("error", ((d) => {
        switch (ye("err", this._errorCode, d, this._xhr.status, this._timeout), this._underlyingError = d, d ? d.code : void 0) {
          case "ERR_FR_TOO_MANY_REDIRECTS":
            this._errorCode = te.TOO_MANY_REDIRECTS;
            break;
          case c.INSECURE_REDIRECT:
            this._errorCode = te.INSECURE_REDIRECT;
            break;
          case te.TIMEOUT:
            this._errorCode = te.TIMEOUT;
            break;
          default:
            this._errorCode = te.NETWORK;
        }
        this._finalize();
      })), this._xhr.addEventListener("load", (() => {
        ye("load"), this._estimatedTotalBytes && this._estimatedTotalBytes > this._bytesReported && this._notifyProgressListeners(this._estimatedTotalBytes, this._estimatedTotalBytes, !1), this._finalize();
      })), this._xhr.addEventListener("timeout", (() => {
        ye("timeout", Cs), this._errorCode = te.TIMEOUT, this._finalize();
      }));
    }));
  }
  get xhr() {
    return this._xhr;
  }
  _parseFetchResponse(e) {
    return je(this, void 0, void 0, (function* () {
      if (e.status === 204) return e;
      if (e.headers.get("transfer-encoding") === "chunked" || parseInt(e.headers.get("content-length") || "0") > 0) switch (this.responseType) {
        case "json":
          Cr(e.headers.get("content-type") || "") && (this._fetchBodyAsResponseType = yield e.json());
          break;
        case "arraybuffer":
          this._fetchBodyAsResponseType = yield e.arrayBuffer();
          break;
        case "blob":
          this._fetchBodyAsResponseType = yield e.blob();
          break;
        case "text":
          this._fetchBodyAsResponseType = yield e.text();
          break;
        case "void":
          break;
        case "buffer":
        case "defaultbuffer":
          this._fetchBodyAsResponseType = yield e.arrayBuffer().then(((s) => new Uint8Array(s)));
      }
      return this.responseType === "stream" && (this._fetchBodyAsResponseType = e.body), e;
    }));
  }
  _shouldAutoParseResponse() {
    const e = this._errorCode === te.NO_ERROR && this._sent && !this._isFetchRequest && this._xhr.responseType === "text" && this._autoParseJson && typeof this._xhr.response == "string" && this._xhr.response.length < 102400 && Cr(this.getResponseHeader("content-type"));
    return ye("_shouldAutoParseResponse()", e), e;
  }
  _fetchWithTimeout(e, s = {}) {
    if (typeof this._fetch != "function") throw new c(c.UNEXPECTED, "fetch method not found but was invoked");
    const { timeout: r } = s, n = (function(a, d) {
      var h = {};
      for (var l in a) Object.prototype.hasOwnProperty.call(a, l) && d.indexOf(l) < 0 && (h[l] = a[l]);
      if (a != null && typeof Object.getOwnPropertySymbols == "function") {
        var p = 0;
        for (l = Object.getOwnPropertySymbols(a); p < l.length; p++) d.indexOf(l[p]) < 0 && Object.prototype.propertyIsEnumerable.call(a, l[p]) && (h[l[p]] = a[l[p]]);
      }
      return h;
    })(s, ["timeout"]);
    this._isFetchRequest = !0;
    const o = (a) => () => {
      this._errorCode = this._errorCode || te.TIMEOUT, a(new c(c.TIMED_OUT, "request aborted due to timeout")), this._finalize();
    };
    if (typeof AbortController != "function") return new Promise(((a, d) => je(this, void 0, void 0, (function* () {
      this._timeoutTimeout = setTimeout(o(d), r);
      const h = yield this._fetch(e, n);
      return clearTimeout(this._timeoutTimeout), this._parseFetchResponse(h).then(a);
    })))).finally((() => {
      clearTimeout(this._timeoutTimeout);
    }));
    const i = new AbortController();
    return this._timeoutTimeout = setTimeout(o(i.abort.bind(i)), r), this._fetchAbort = () => {
      this._errorCode = this._errorCode || te.ABORTED, i.abort(), this._finalize();
    }, new Promise(((a, d) => {
      this._fetch(e, Object.assign({ signal: i.signal }, n)).then(((h) => (clearTimeout(this._timeoutTimeout), this._parseFetchResponse(h)))).then(a).catch(((h) => {
        clearTimeout(this._timeoutTimeout), d(h);
      }));
    }));
  }
  _finalize() {
    if (ye("_finalize", this._xhr.status, this._errorCode), this._shouldAutoParseResponse()) try {
      const e = JSON.parse(this._xhr.response);
      this._autoParsedResponse = e, this._xhr.responseType = "json";
    } catch {
    }
    this._postCallback && this._postCallback(this), this._timeoutTimeout && clearTimeout(this._timeoutTimeout), this._progressListeners = [], this._resolve(this);
  }
  _validateResponseType(e) {
    if (e === "buffer") {
      if (typeof Buffer != "function") throw new c(c.INVALID_PARAMS, "No Buffer class");
    } else if (e === "blob") {
      if (typeof Blob != "function") throw new c(c.INVALID_PARAMS, "No Blob class");
    } else if (e !== "text" && e !== "json" && e !== "arraybuffer" && e !== "stream") throw new c(c.INVALID_PARAMS, "Unsupported response type");
    return e.toLowerCase();
  }
  inactivityTimer() {
    this._timeoutTimeout && clearTimeout(this._timeoutTimeout), this._timeoutTimeout = setTimeout((() => {
      this.timedOut();
    }), this._timeout);
  }
  send(e, s, r, n = {}, o = "text", i = {}) {
    if (ye("send"), this._sent) throw new Error("Xhr already sent");
    this.href = e, this.method = s.toUpperCase(), this.body = r, this.body ? this._estimatedTotalBytes = this.body.byteLength || this.body.length || this.body.size : this._estimatedTotalBytes = Number.MAX_SAFE_INTEGER;
    const a = (h) => {
      var l;
      ye(`progress ${h.loaded}/${h.total}`), this._bytesReported = h.loaded, this.inactivityTimer(), h.lengthComputable ? (this._estimatedTotalBytes = h.total, this._notifyProgressListeners(this._bytesReported, (l = this._estimatedTotalBytes) !== null && l !== void 0 ? l : 1 / 0, !1)) : this._estimatedTotalBytes && this._estimatedTotalBytes > this._bytesReported && this._notifyProgressListeners(this._bytesReported, this._estimatedTotalBytes || h.total, !0);
    };
    ["POST", "PUT", "PATCH"].includes(this.method) && this._xhr.upload ? this._xhr.upload.onprogress = a : this._xhr.addEventListener("progress", a), this._timeout = i.timeout || this._timeout || Fs, ye("setting timeout", this._timeout), this._xhr.timeout = Cs, o && (o = this._validateResponseType(o), ye("responseType: ", o), this.responseType = o === "buffer" ? "arraybuffer" : o === "stream" ? "stream" : o === "void" ? "text" : o);
    const d = Pt(n);
    if (this.headers = d, this.href.startsWith("http:") && this.headers.authorization !== null) throw new c(c.INVALID_PARAMS, "Must not send auth token over unsecured connection");
    if (this._preCallback && this._preCallback(this), (this._preferFetch || o === "stream") && typeof this._fetch == "function") return this._xhr.responseType = this.responseType, this._promise = new Promise(((h, l) => {
      this._resolve = h, this._fetchWithTimeout(this.href, { body: ["GET", "HEAD"].includes(this.method.toUpperCase()) ? void 0 : r, credentials: i.withCredentials ? "include" : void 0, headers: d, method: this.method, timeout: this._timeout }).then(((p) => {
        this._fetchResponse = p, this._finalize();
      })).catch(((p) => {
        l(p);
      })), this._sent = !0;
    })), this._promise;
    this._xhr.open(this.method, this.href, !0), this._xhr.responseType = this.responseType;
    for (const [h, l] of Object.entries(d)) this._xhr.setRequestHeader(h, l);
    return i.withCredentials != null && (this._xhr.withCredentials = i.withCredentials), this.inactivityTimer(), r != null ? this._xhr.send(r) : this._xhr.send(), this._sent = !0, this._promise;
  }
  abort() {
    if (ye("abort()"), !this._sent) throw new Error("Cannot abort before sending.");
    this._isFetchRequest ? this._fetchAbort() : this._xhr.abort();
  }
  timedOut() {
    if (ye("timedOut()"), !this._sent) throw new Error("Cannot timed out before sending.");
    this._isFetchRequest || (this._xhr.abort(), this._errorCode = te.TIMEOUT, this._finalize());
  }
  getResponseHeader(e) {
    if (!this._sent) throw new Error("Cannot getResponseHeader before sending.");
    const s = e.toLowerCase(), r = this.getAllResponseHeaders();
    if (s in r) return r[s];
  }
  getAllResponseHeaders() {
    var e, s;
    if (!this._sent) throw new Error("Cannot getAllResponseHeaders before sending.");
    if (this._parsedResponseHeaders) return this._parsedResponseHeaders;
    const r = this._isFetchRequest ? ti((s = (e = this._fetchResponse) === null || e === void 0 ? void 0 : e.headers.entries()) !== null && s !== void 0 ? s : []) : this._xhr.getAllResponseHeaders();
    return this._parsedResponseHeaders = typeof r == "string" ? Ws(r) : Pt(r), this._parsedResponseHeaders;
  }
  isError() {
    if (!this._sent) throw new Error("Cannot check isError before sending.");
    return this._errorCode !== te.NO_ERROR;
  }
  isAborted() {
    if (!this._sent) throw new Error("Cannot check isAborted before sending.");
    return this._errorCode === te.ABORTED;
  }
  isTimedOut() {
    if (!this._sent) throw new Error("Cannot check isTimedOut before sending.");
    return this._errorCode === te.TIMEOUT;
  }
  isSent() {
    return this._sent;
  }
  getErrorCode() {
    return this._errorCode;
  }
  getStatus() {
    if (!this._sent) throw new Error("Cannot getStatus before sending.");
    return this._fetchResponse ? this._fetchResponse.status : this._xhr.status;
  }
  getResponse() {
    var e;
    if (!this._sent) throw new Error("Cannot getResponse before sending.");
    return this._response || (this._response = { statusCode: this.getStatus(), headers: this.getAllResponseHeaders(), responseType: this._autoParsedResponse ? "json" : this.responseType, response: this.getResponseData(), message: this._isFetchRequest ? ((e = this._fetchResponse) === null || e === void 0 ? void 0 : e.statusText) || "" : this._xhr.statusText, xhr: this }, this._autoParsedResponse && (this._response.originalResponseData = this._xhr.response)), this._response;
  }
  toJSON() {
    return { statusCode: this.getStatus(), headers: this.getAllResponseHeaders(), responseType: this._autoParsedResponse ? "json" : this.responseType, response: this.getResponseData(), message: this._xhr.statusText };
  }
  getResponseDataAsJSON() {
    return je(this, void 0, void 0, (function* () {
      try {
        if (this._fetchResponse) return yield this._fetchResponse.json();
        if (this._autoParsedResponse) return this._autoParsedResponse;
        if (this._xhr.responseType === "json") {
          if (typeof this._xhr.response == "string") return JSON.parse(this._xhr.response);
          if (this.xhr.response === null && ["application/problem+json", "application/json"].includes(this.xhr.getResponseHeader("content-type"))) throw new c(c.UNEXPECTED, "Unexpected response type");
          return this.xhr.response;
        }
        let e = this._xhr.response;
        if (this._xhr.responseType === "text" && this._xhr.responseText !== null) e = this._xhr.responseText;
        else if (this._xhr.responseType === "arraybuffer") e = ve(this._xhr.response);
        else {
          if (this._xhr.responseType === "blob" && (e instanceof Blob || Y(e.text))) return JSON.parse(yield e.text());
          this.responseType === "stream" ? yield new Promise(((s, r) => {
            if (e = "", typeof this.xhr.response.on == "function") return this.xhr.response.on("data", ((n) => {
              e += n;
            })), this.xhr.response.on("end", s), void this.xhr.response.on("error", r);
            if (typeof this.xhr.response == "string") return s(e = this.xhr.response);
            throw new c(c.UNEXPECTED, "Unexpected response type");
          })) : e = this._xhr.responseText ? this._xhr.responseText : e;
        }
        return typeof e == "string" ? JSON.parse(e) : e;
      } catch (e) {
        throw new c(c.INVALID_JSON, "Could not parse response as JSON", e, this.toJSON());
      }
    }));
  }
  getResponseData() {
    if (!this._sent) throw new Error("Cannot getResponseData before sending.");
    return this._isFetchRequest && this._fetchBodyAsResponseType ? this._fetchBodyAsResponseType : this._autoParsedResponse || this._xhr.response;
  }
  onProgress(e) {
    const s = this._progressListeners.push(e) - 1;
    return () => {
      try {
        delete this._progressListeners[s];
      } catch {
      }
    };
  }
  _notifyProgressListeners(e, s, r) {
    this._progressListeners.map(((n) => n && n.call && n.call(null, e, s, r)));
  }
}
const Ge = B("dcx:http:backoff");
function vd(t, e, s, r = {}, n, o = {}, i = !1) {
  const { disableRetry: a = !1, retryNetworkError: d = !0, responseType: h = "text", authCallback: l = null, progressListeners: p = [], initialWait: _ = 2e3, maxWait: f = 32e3, preCallback: m, postCallback: y, preScheduleCallback: P, postScheduleCallback: I, preferRetryAfterHeader: R = !0, pollCodes: D = [], pollHeader: O, pollMethod: N = "get", problemWithCode: M = { problemType: "", code: null, url: "" }, modifyHeadersCallback: Q = null, skipPollingTimeout: X = !1 } = o;
  let { retryCodes: le = [], timeoutAfter: be = 72e3 } = o;
  le = i ? [...D, ...le] : a || Yo(s) ? [] : o.retryCodes || pn, Ge("retry codes", le);
  const Oe = o.increase || ((W, ee, U) => W === 1 ? U : ee * ee > f ? f : ee * ee);
  let q = 0, Me = 0, Ee = !1;
  const Lt = ae();
  let re, ge, Pe, me, pt = ae(), We = 0, wt = !1, ps = !1;
  const Ar = [];
  let mr;
  function Mt() {
    Ge("getSnapshot()", Ee, q, ae(), pt, We);
    const W = Ee || re != null ? 0 : q - (ae() - pt);
    let ee = We;
    ee += Ee ? ae() - pt : 0;
    const U = (re || ae()) - Lt;
    return { count: Me, canceled: wt, timedOut: ps, requests: Ar, duration: U, totalWaited: ee, requestPending: Ee, waitingFor: W };
  }
  function yr() {
    const W = Oe(Me, q, _);
    return Math.min(W, f);
  }
  function vr(W) {
    if (W) return (ee) => W(ee, Mt());
  }
  function br(W) {
    const ee = W.getResponseHeader("retry-after");
    if (R && ee) {
      if (isNaN(ee)) {
        const U = Date.parse(ee) - Date.now();
        return Ge("nextWait from retry-after", U), U < 0 ? yr() : U;
      }
      return 1e3 * parseInt(W.getResponseHeader("retry-after"));
    }
  }
  function st(W = q) {
    return je(this, void 0, void 0, (function* () {
      if (We >= be) {
        if (Ge("timed out", We, be), !ot(me.getStatus(), D)) return ps = !0, ge(me);
        if (!X) return ps = !0, Pe(new c(c.TIMED_OUT, "DCX backoff timed out", void 0, me.getResponse()));
      }
      pt = ae(), P && (yield P(Mt())), Ge("retry in ", W), mr = setTimeout((() => {
        var ee;
        try {
          Ge("retry start"), Fr(`Request: ${e.toUpperCase()} ${t} ${(ee = r == null ? void 0 : r["x-request-id"]) !== null && ee !== void 0 ? ee : ""}`), Ee = !0, We += W, me = new yd(Object.assign(Object.assign({}, o), { timeout: n, preCallback: vr(m), postCallback: vr(y) })), Ar.push(me), Me++;
          for (const U of p) me.onProgress(U);
          me.send(t, e, s, r, h).then(((U) => je(this, void 0, void 0, (function* () {
            var _s, fs, Es;
            if (Fr(`Response: ${e.toUpperCase()} ${t} ${(_s = U.headers) === null || _s === void 0 ? void 0 : _s["x-request-id"]} ${U.getStatus()}`), Ee = !1, !U.isError() && !ot(U.getStatus(), le) && (U.getStatus() !== 401 || l == null) && (typeof O != "string" || D == null || !ot(U.getStatus(), D)) || (M == null ? void 0 : M.code) === U.getStatus() && U.getResponseData() && (M == null ? void 0 : M.problemType) !== ((fs = yield U.getResponseDataAsJSON()) === null || fs === void 0 ? void 0 : fs.type)) return re = ae(), ge(U);
            if (U.isAborted() || wt) return re = ae(), wt = !0, ge(U);
            if (!i && typeof O == "string" && D != null && ot(U.getStatus(), D)) {
              const _t = U.getResponseHeader(O.toLowerCase()), ft = M.url, Rr = ft && M.code === U.getStatus() && M.problemType === ((Es = U.getResponseData()) === null || Es === void 0 ? void 0 : Es.type);
              if (_t || Rr) {
                i = !0, t = Rr ? ft : _t, e = N, s = void 0, Q && (r = Q(r)), le = [...le, ...D], We = 0, be *= 20;
                const xo = U.getResponseHeader("retry-after");
                if (R && xo) {
                  const Or = br(U);
                  if (Or != null) return q = Or, st(q);
                }
                return st(0);
              }
            }
            if (U.getStatus() === 401) {
              if (l) {
                try {
                  r = yield l(t, r);
                } catch {
                  return Pe(new c(c.UNAUTHORIZED, "Authentication Failed", U));
                }
                return We += ae() - pt, st(0);
              }
              return re = ae(), Pe(new c(c.UNAUTHORIZED, "Authentication Failed", U));
            }
            if (ot(U.getStatus(), le) || d && U.getErrorCode() === A.NETWORK_ERROR) {
              const _t = U.getResponseHeader("retry-after");
              if (R && _t) {
                const ft = br(U);
                if (ft != null) return q = ft, st(q);
              }
              return q = yr(), st(q);
            }
            return re = ae(), ge(U);
          })))).catch(((U) => {
            Pe(U);
          }));
        } catch (U) {
          Pe(U);
        }
      }), W), I && (yield I(Mt()));
    }));
  }
  const Uo = new Promise(((W, ee) => {
    ge = W, Pe = ee, st(0);
  }));
  return { getPromise: () => Uo, cancel: function() {
    Ge("cancel()"), wt = !0, me != null && me.abort(), Ee || (Ge("abort"), clearTimeout(mr), ge({ getErrorCode: () => te.ABORTED }));
  }, onProgress: function(W) {
    if (!p.includes(W)) return p.push(W), me != null ? me.onProgress && me.onProgress(W) : void 0;
  }, getSnapshot: Mt };
}
class bd {
  constructor(e, s, r, n, o = "text", i, a, d = {}) {
    const { descriptor: h } = d;
    delete d.descriptor;
    const { cancel: l, getPromise: p, onProgress: _, getSnapshot: f } = vd(e, s, r, n, d.timeout, Object.assign(Object.assign(Object.assign(Object.assign({}, d), { responseType: o, authCallback: a }), d.retryOptions), { descriptor: h, forceXhr: d.forceXhr, autoParseJson: d.autoParseJson }));
    this.onProgress = _, typeof i == "function" && _(((m, y) => i("progress", { total: y, sentOrReceived: m }))), this._cancel = l, this._promise = p(), this._getSnapshot = f;
  }
  getSnapshot() {
    return this._getSnapshot();
  }
  getPromise() {
    return this._promise;
  }
  cancel(e) {
    this._cancel(e);
  }
}
const Ss = B("dcx:http:req");
class us {
  constructor(e) {
    var s;
    if (this._pausable = !1, this._listeners = { progress: [], cancel: [] }, this._isStatusValid = e.isStatusValid || zt, this._isExternalRequest = e.isExternalRequest, this._authProvider = e.authProvider, this._id = e.id, this._descriptor = e.descriptor, e.descriptor && e.descriptor.progress) {
      const n = e.descriptor.progress;
      this.on("progress", (({ sentOrReceived: o, total: i }) => {
        n.call(void 0, o, i);
      }));
    }
    const r = this._authProvider.applyAuthHeaders(e.url, Pt(e.headers || {}));
    this._isExternalRequest && us._internalOnlyHeaders.forEach(((n) => delete r[n])), this._networkRequest = new bd(e.url, e.method, e.body, r, e.responseType, !((s = e.descriptor) === null || s === void 0) && s.progress ? this._emit.bind(this) : void 0, this._getAuthCb(), e), this._promise = this._networkRequest.getPromise().then(((n) => {
      const o = n.getErrorCode(), i = o || this._isStatusValid(n.getStatus(), n.getResponse());
      if (o || i !== !0)
        throw o === te.ABORTED ? new c(c.ABORTED, "Aborted") : o === te.NETWORK ? new c(c.NETWORK_ERROR, "Network error", void 0, n.getResponse()) : o === te.TIMEOUT ? new c(c.TIMED_OUT, "Timeout", void 0, n.getResponse()) : i instanceof c || i instanceof Error ? new c(i.code || c.UNEXPECTED_RESPONSE, i._message || i.message, i.underlyingError, n.getResponse()) : new c(c.UNEXPECTED_RESPONSE, "Unexpected response", void 0, n.getResponse());
      const a = this._networkRequest.getSnapshot().requests;
      return Ss("resolve", e.id), Object.assign(Object.assign({}, n.getResponse()), { xhr: a[a.length - 1] });
    })).catch(((n) => {
      throw Ss("reject", e.id), n;
    }));
  }
  get id() {
    return this._id;
  }
  get descriptor() {
    return this._descriptor;
  }
  _getAuthCb() {
    if (!this._authProvider.isNoAuthMode) return this._authCb.bind(this);
  }
  _authCb(e, s) {
    return Ss("_authCb()"), this._authProvider.isAuthorizedURL(e) ? this._authProvider.refreshAuth().then((() => this._authProvider.applyAuthHeaders(e, s))) : Promise.reject(new c(c.UNAUTHORIZED, "URL is not part of authenticationAllowList.", void 0, void 0, { url: e }));
  }
  _emit(e, s) {
    this._listeners[e].map(((r) => r.call(null, s)));
  }
  getPromise() {
    return this._promise;
  }
  cancel(e) {
    return this._networkRequest.cancel(e);
  }
  on(e, s) {
    var r;
    e === "progress" && this._listeners[e].length === 0 && ((r = this._networkRequest) === null || r === void 0 || r.onProgress(((n, o) => this._emit(e, { total: o, sentOrReceived: n })))), this._listeners[e].push(s);
  }
}
us._internalOnlyHeaders = ["x-request-id", "x-api-key", "authorization"];
const Rd = (t) => new us(t), Ns = B("dcx:http:map");
class Od {
  constructor() {
    this._map = /* @__PURE__ */ new Map();
  }
  addRequest(e, s) {
    return Ns("addRequest()", e), this._map.set(e, s), s.getPromise().then(((r) => {
      Ns("then", e), this._map.delete(e);
    })).catch(((r) => {
      Ns("catch", e, r), this._map.delete(e);
    })), e;
  }
  get(e) {
    return this._map.get(e);
  }
  get length() {
    return this._map.size;
  }
  has(e) {
    return this._map.has(e);
  }
  removeById(e) {
    const s = this._map.get(e);
    s && this.remove(s);
  }
  remove(e, s) {
    return e && e.cancel && e.cancel(s);
  }
  clear(e) {
    this._map.forEach(((s) => {
      this.remove(s, e);
    })), this._map.clear();
  }
  removeAllWithToken(e) {
    this._map.forEach(((s) => {
      s.descriptor.token === e && this.remove(s);
    }));
  }
}
const Ft = B("dcx:http:q"), Pd = (t) => t.method.toLowerCase() === "head";
class Cd {
  constructor() {
    this._queue = [], this._later = {}, this._headEndPtr = 0, this._isPriority = Pd, this._usePriority = !1;
  }
  push(e, s, r) {
    return je(this, void 0, void 0, (function* () {
      let n;
      const o = new Promise(((h) => {
        n = h;
      }));
      if (typeof s != "number" || s <= 0) {
        const h = { descriptor: e, notifySent: (l) => n(l), notifyCanceled: this._notifyCanceled(n) };
        return this._push(h), o;
      }
      const { id: i } = e, a = setTimeout((() => {
        this._ready(i);
      }), s), d = (h) => n(h);
      return this._later[i] = { readyTimeout: a, wait: s, descriptor: e, notifySent: d, notifyCanceled: this._notifyCanceled(n), notifyReady: () => {
        r && r.call(null, { wait: s, descriptor: e, notifySent: d });
      } }, o;
    }));
  }
  _notifyCanceled(e) {
    return (s) => {
      if (!s) return e({ canceled: !0 });
      e({ canceled: !0, error: s });
    };
  }
  _push(e) {
    this._usePriority && this._isPriority(e.descriptor) ? this._queue.splice(this._headEndPtr++, 0, e) : this._queue.push(e);
  }
  remove(e) {
    if (e.id in this._later) return Ft("remove from later", e.id), this._remove(e.id);
    const s = this._indexOf(e);
    return Ft("remove from q", s), s >= 0 ? this._remove(s) : void 0;
  }
  _remove(e, s) {
    if (Ft("_remove", e), typeof e == "string") {
      const r = this._later[e];
      return r.notifyCanceled.call(null, s), r.readyTimeout && clearTimeout(r.readyTimeout), void delete this._later[e];
    }
    this._queue[e].notifyCanceled.call(null, s), this._queue.splice(e, 1), e < this._headEndPtr && this._headEndPtr--;
  }
  _indexOf(e) {
    const s = !!e.method, r = s && this._usePriority && this._isPriority(e), n = r ? this._headEndPtr : this._queue.length, o = r || !s ? 0 : this._headEndPtr;
    for (let i = o; i < o + n; i++) if (e.id === this._queue[i].descriptor.id) return i;
    return -1;
  }
  exists(e) {
    return e.id in this._later || this._indexOf(e) >= 0;
  }
  _ready(e) {
    const s = this._later[e], r = s.notifyReady;
    delete this._later[e], delete s.notifyReady, delete s.readyTimeout, delete s.wait, this._push(s), typeof r == "function" && r.call(null);
  }
  pop() {
    const e = this._queue.shift();
    return this._headEndPtr > 0 && this._headEndPtr--, e;
  }
  get length() {
    return Ft("length: ", this._queue.length, Object.keys(this._later).length), this._queue.length + Object.keys(this._later).length;
  }
  clear(e) {
    for (let r = this._queue.length - 1; r >= 0; r--) this._remove(r, e);
    this._queue = [];
    const s = Object.keys(this._later);
    for (const r in s) {
      const n = s[r];
      this._remove(n, e);
    }
    this._later = {};
  }
  removeAllWithToken(e) {
    for (let r = this._queue.length - 1; r >= 0; r--) this._queue[r].descriptor.token === e && this._remove(r);
    const s = Object.keys(this._later);
    for (const r in s) {
      const n = s[r];
      this._later[n].descriptor.token === e && this._remove(n);
    }
  }
}
const K = B("dcx:http:service"), an = 3e5;
class Sd {
  constructor(e, s = {}) {
    this.name = "AdobeHTTPService", this._requestQueue = new Cd(), this._requestsOutstanding = new Od(), this._authProvider = void 0, this._isActive = !0, this._preferFetch = !1, this._handlesRedirects = !0, this._withCredentials = !1, this._additionalNodeOptions = {}, this._retryOptions = {}, this._serviceGuid = Kt(), this._reqNum = 0, this.featureFlags = {}, e instanceof Vt || C(e) && Y(e.onChange) ? this._authProvider = e : Y(e) && (s.useAuthProvider ? (this._authProvider = new Vt(void 0, void 0, e), this._waitingForAuthentication = !0) : (this._authProvider = new Vt(void 0, void 0, (() => e.call(null, this))), this._waitingForAuthentication = !0)), this._authProvider ? this._authProvider.onChange(this._onAuthChange.bind(this)) : (this._authProvider = new Vt(), this._authProvider.resume()), this._maxOutstanding = s.maxOutstanding || 5, this._withCredentials = s.crossOriginCredentials || !1, this._timeout = s.timeout == null ? Fs : s.timeout, this._preferFetch = s.preferFetch === !0, this._requestIdPrefix = s.requestIdPrefix, s.server && (this.server = s.server);
  }
  get isActive() {
    return this._isActive;
  }
  set isActive(e) {
    this._isActive !== e && (this._isActive = e, e || this._authProvider.logout(), this._checkQueue());
  }
  get crossOriginCredentials() {
    return this._withCredentials;
  }
  set crossOriginCredentials(e) {
    this._withCredentials = e;
  }
  get maxOutstanding() {
    return this._maxOutstanding;
  }
  set maxOutstanding(e) {
    this._maxOutstanding = e, this._checkQueue();
  }
  get handlesRedirects() {
    return this._handlesRedirects;
  }
  get server() {
    return this._server;
  }
  set server(e) {
    this._server = e && e.endsWith("/") ? e.substr(0, e.length - 1) : e;
  }
  _forceXhr(e, s = !1) {
    this._forcedXhr = e, this._handlesRedirects = !s;
  }
  _useFetchApi(e) {
    this._fetch = e;
  }
  setAdditionalHeaders(e) {
    this._additionalHeaders = e || {};
  }
  setValidateStatus(e) {
    this._isStatusValid = e;
  }
  setAdditionalNodeOptions(e) {
    this._additionalNodeOptions = e, Wt() && e && e.maxRedirects === 0 && (this._handlesRedirects = !1);
  }
  setRetryOptions(e) {
    this._retryOptions = e;
  }
  set authenticationAllowList(e) {
    this._authProvider.authenticationAllowList = e;
  }
  get authenticationAllowList() {
    return this._authProvider.authenticationAllowList;
  }
  get authProvider() {
    return this._authProvider;
  }
  setApiKey(e) {
    this._authProvider.setApiKey(e);
  }
  setTimeout(e) {
    this._timeout = e;
  }
  setAuthToken(e) {
    e ? this._authProvider.setAuthToken(e) : this._authProvider.logout();
  }
  _onAuthChange(e, s) {
    K("_oAC", e);
    const r = this._waitingForAuthentication;
    e === "unauthenticated" ? this._waitingForAuthentication = !0 : (this._waitingForAuthentication = !1, r !== !1 && this._checkQueue());
  }
  resume() {
    this._waitingForAuthentication = !1, this._authProvider.resume(), this._checkQueue();
  }
  setRequestHooks(e, s) {
    this._beforeHook = e, this._afterHook = s;
  }
  invoke(e = "GET", s, r = {}, n, o = {}, i) {
    var a;
    K("invoke", e, s, o);
    let d = (o = o || {}).autoParseJson || !1, h = o.responseType;
    if (h != null && h !== "void" || (d = o.autoParseJson == null || o.autoParseJson, h = o.responseType = "text"), h === "defaultbuffer" && (h = Wt() ? o.responseType = "buffer" : o.responseType = "arraybuffer"), h === "buffer") {
      if (typeof Buffer != "function") throw new c(c.INVALID_PARAMS, "No Buffer class");
    } else if (h === "blob") {
      if (typeof Blob != "function") throw new c(c.INVALID_PARAMS, "No Blob class");
    } else if (h && h !== "text" && h !== "json" && h !== "arraybuffer" && h !== "stream") throw new c(c.INVALID_PARAMS, "Unsupported response type: " + h);
    !Ds(s) && this.server && (s = `${this.server}/${s.startsWith("/") ? s.substr(1, s.length) : s}`), K("invoke href", s);
    const l = de({}, r, this._additionalHeaders);
    K("invoke headers", r), l["x-request-id"] = [this._requestIdPrefix, this._serviceGuid, l["x-request-id"], "" + this._reqNum++].filter(((m) => m)).join("."), o.additionalNodeOptions = Object.assign({}, this._additionalNodeOptions || {}, o.additionalNodeOptions || {}), o.isStatusValid = o.isStatusValid || this._isStatusValid, o.retryOptions = Object.assign({}, this._retryOptions || {}, o.retryOptions || {});
    let p = { method: e, href: s, headers: l, token: void 0, body: n, options: o, progress: (a = o.reuseRequestDesc) === null || a === void 0 ? void 0 : a.progress, autoParseJson: d }, _ = o.reuseRequestDesc;
    _ && _ instanceof S && "props" in _ && (_ = _.props), _ && ((this._requestQueue.exists(_) || _.id && this._requestsOutstanding.get(_.id) != null) && K("requestDesc still in use"), p = de(_, p)), p.id = p.id || Kt(), i && ("maxRedirects" in o.additionalNodeOptions && (o.additionalNodeOptions.maxRedirects = 0), o.retryOptions && Object.keys(o.retryOptions).length !== 0 || (o.retryOptions = { disableRetry: !0 }));
    const f = this._getRequestPromise(p);
    return f.getPromise().then(this._checkQueue.bind(this)).catch(this._checkQueue.bind(this)), Y(i) && (K("invoke - cb"), f.then(((m) => {
      K("invoke - cb - resolve ", m.statusCode);
      try {
        i(void 0, m, m.response);
      } catch (y) {
        console.error("[dcx:http] error in success callback", y, y.stack);
      }
    })).catch(((m) => {
      K("invoke - cb - reject: ", m);
      try {
        i(m, m.response);
      } catch (y) {
        console.error("[dcx:http] error in failure callback", y, y.stack);
      }
    }))), this._checkQueue(), f;
  }
  _makeRequest(e) {
    K("_makeRequest(): ", e.id);
    const s = e.options || {}, r = Rd(L(Object.assign(Object.assign({ url: e.href, autoParseJson: e.autoParseJson, descriptor: e }, e), { timeout: s.timeout || this._timeout, authProvider: this._authProvider, forceXhr: this._forcedXhr, fetch: this._fetch, responseType: s.responseType, preCallback: this._beforeHook, postCallback: this._afterHook, isStatusValid: s.isStatusValid, additionalNodeOptions: s.additionalNodeOptions, retryOptions: s.retryOptions, isExternalRequest: s.isExternalRequest, preferFetch: this._preferFetch })));
    return this._requestsOutstanding.addRequest(e.id, r), e.startTime = (/* @__PURE__ */ new Date()).valueOf(), r;
  }
  _checkQueue() {
    queueMicrotask(this._checkQueueLoop.bind(this));
  }
  _checkQueueLoop() {
    if (K("_checkQueueLoop()", this._waitingForAuthentication, this.isActive, this._requestsOutstanding.length, "<?", this.maxOutstanding), !this._isActive) {
      K("_cQL inactive");
      const s = new c(c.SERVICE_IS_INACTIVE, "Network request in inactive state");
      this._requestsOutstanding.clear(s), this._requestQueue.clear(s);
    }
    let e = !0;
    for (; e && !this._waitingForAuthentication && this._requestsOutstanding.length < this.maxOutstanding && (e = this._requestQueue.pop(), e != null); ) {
      const s = this._makeRequest(e.descriptor);
      e.notifySent(s);
    }
    K("_cQL done");
  }
  _getRequestPromise(e) {
    return K("_getRequestPromise()"), new S(((s, r, n) => {
      if (!this._isActive) return K("_gRP inactive"), r(new c(c.SERVICE_IS_INACTIVE, "Network request in inactive state"));
      n((() => {
        K("_gRP cancel 1", e.id), this._requestQueue.remove(e);
      }));
      let o = e.noSoonerThen || null;
      return o && (o -= ae(), o = o < 0 ? 0 : o > an ? an : o), delete e.noSoonerThen, this._requestQueue.push(e, o, this._checkQueue.bind(this)).then(((i) => (K("_gRP sent", e.id), i.canceled ? (K("_gRP reject 1: ", e.id), r(new c(c.ABORTED, "Request aborted", i.error))) : (n(((a) => {
        K("_gRP cancel 2", e.id, a), i.cancel(new c(c.ABORTED, "Request aborted", a));
      })), i.getPromise().then(((a) => (K("_gRP resolve 1", e.id, a), s(a)))).catch(((a) => (K("_gRP reject 2: ", e.id, a), r(a)))))))).catch(r);
    }), e);
  }
  abort(e) {
    e && e.cancel ? e.cancel() : this._requestQueue.exists(e) ? this._requestQueue.remove(e) : this._requestsOutstanding.removeById(e.id);
  }
  abortAllWithToken(e) {
    K("abortAllWithToken()"), this._requestsOutstanding.removeAllWithToken(e), this._requestQueue.removeAllWithToken(e);
  }
}
const Nd = (t, e) => new Sd(t, {}), wo = class Mo extends CustomEvent {
  constructor(e) {
    super(Mo.EVENT_NAME, { bubbles: !0, composed: !0, detail: e });
  }
};
wo.EVENT_NAME = md.UPLOAD_STATUS;
let Dd = wo;
class kd {
  /**
   * Create a new UploadService instance
   * @param config - Configuration for the upload service
   */
  constructor(e) {
    this._uploadStatus = nt.IDLE, this._uploadBytesCompleted = !1, this._uploadProgressPercentage = 0, this.config = e, this.httpService = Nd(), this.authConfig = e.authConfig, this.session = this.prepareSession();
  }
  /**
   * Initialize logging service
   */
  async initializeLogging() {
    const { LogService: e } = await import("./Logging-VoBCga4r.min.js");
    this.logService = new e(), await this.logService.initialize(this.config.environment);
  }
  /**
   * Initialize repository for user token type
   */
  async initializeUserRepository() {
    try {
      const e = await this.setupUserRepository();
      e && (this.config.repository = e);
    } catch (e) {
      throw this.handleError(
        He.REPOSITORY_REQUIRED.code,
        e
      );
    }
  }
  /**
   * Sets up the user repository for the upload service
   * This function does a couple of things:
   * 1. Gets the index document for the user
   * 2. Gets the children of the index document
   * 3. If there is only one child, that is the repository
   * 4. If there are multiple children, it finds the temp folder. If there is no temp folder, it uses the first child as the repository
   * 5. Returns the repository ID and path
   * @returns Promise resolving to the repository
   */
  async setupUserRepository() {
    var i, a;
    const e = await this.session.getIndexDocument(), { assignedDirectories: s } = e.result, r = (i = s == null ? void 0 : s[0]) == null ? void 0 : i.repositoryId, n = (a = s == null ? void 0 : s[0]) == null ? void 0 : a.assetId;
    this.config.directory = new Tr({ repositoryId: r, assetId: n }, this.httpService);
    const o = await this.config.directory.getPagedChildren();
    if (o != null && o.result) {
      const d = o.result.children;
      if (d.length === 1) {
        const h = d[0];
        return {
          repositoryId: h["repo:repositoryId"],
          path: h["repo:path"]
        };
      } else {
        let h = d.find((l) => l["repo:name"] === "temp");
        return h || (h = d[0]), {
          repositoryId: h["repo:repositoryId"],
          path: h["repo:path"]
        };
      }
    }
    return null;
  }
  /**
   * Get the current upload status
   * @returns The current upload status
   */
  get uploadStatus() {
    return this._uploadStatus;
  }
  /**
   * Set the upload status
   * @param status - The status to set
   */
  set uploadStatus(e) {
    this._uploadStatus = e, this.dispatchStatusEvent(e);
  }
  /**
   * Initialize the upload service
   */
  async setIndexRepository() {
    this.authConfig.tokenType === "user" && await this.initializeUserRepository();
  }
  /**
   * Upload an asset to storage
   * @param options - Upload options including file, path, and metadata
   * @returns Promise resolving to upload result
   */
  async uploadAsset(e) {
    this.uploadStatus = nt.IDLE;
    try {
      const {
        file: s,
        fileName: r,
        path: n = this.config.basePath,
        onProgress: o = this.getUploadProgress()
      } = e, i = this.convertToSliceableData(s), a = this.getFileSize(s), d = this.buildPath(n, this.generateFileName(r)), h = { ...e, onProgress: o };
      let l;
      switch (this.authConfig.tokenType) {
        case "guest": {
          l = (await this.createAssetForGuest(
            h,
            i,
            a,
            d
          )).result;
          break;
        }
        case "user":
        default: {
          l = (await this.createAssetForUser(
            h,
            i,
            a,
            d
          )).result;
          break;
        }
      }
      return this._uploadBytesCompleted && (this.uploadStatus = nt.COMPLETED), {
        asset: l.result
      };
    } catch (s) {
      throw this.handleError(
        He.UPLOAD_FAILED.code,
        s
      );
    }
  }
  /**
   * Create asset for guest users
   * @param options - Upload options
   * @param fileData - Processed file data
   * @param fileSize - Size of the file
   * @param fullPath - Full path for the asset
   * @returns Promise resolving to asset creation result and optionlally pre-signed URL
   */
  async createAssetForGuest(e, s, r, n) {
    var l, p, _, f;
    const {
      contentType: o,
      resourceDesignator: i,
      additionalHeaders: a = {},
      repoMetaPatch: d,
      onProgress: h
    } = e;
    (l = this.logService) == null || l.log("LOG_UPLOAD_START", "guest", {
      fullPath: n,
      contentType: o,
      fileSize: r,
      hasResourceDesignator: !!i,
      hasRepoMetaPatch: !!d
    });
    try {
      const m = await this.session.createAssetForGuest(
        n,
        o,
        i,
        a,
        s,
        r,
        d,
        h
      );
      return (p = this.logService) == null || p.log("LOG_UPLOAD_RESPONSE", "createAssetForGuest", m, n, r), (_ = this.logService) == null || _.log("LOG_UPLOAD_STATUS", m.response.statusCode, m.response, "guest"), { result: m };
    } catch (m) {
      throw (f = this.logService) == null || f.log("LOG_UPLOAD_ERROR", "guest", {
        fullPath: n,
        contentType: o,
        fileSize: r
      }, m), m;
    }
  }
  /**
   * Create asset for authenticated users
   * @param options - Upload options
   * @param fileData - Processed file data
   * @param fileSize - Size of the file
   * @param fullPath - Full path for the asset
   * @returns Promise resolving to asset creation result
   */
  async createAssetForUser(e, s, r, n) {
    var _, f, m, y, P, I;
    const {
      contentType: o,
      resourceDesignator: i,
      additionalHeaders: a = {},
      repoMetaPatch: d,
      createIntermediates: h,
      onProgress: l
    } = e;
    let p;
    this.validateRequiredConfig([
      { field: "directory", errorCode: He.DIRECTORY_REQUIRED },
      { field: "repository", errorCode: He.REPOSITORY_REQUIRED }
    ]), (f = this.logService) == null || f.log("LOG_UPLOAD_START", "user", {
      fullPath: n,
      contentType: o,
      fileSize: r,
      createIntermediates: h || !0,
      hasResourceDesignator: !!i,
      hasRepoMetaPatch: !!d,
      repository: ((_ = this.config.repository) == null ? void 0 : _.name) || "unknown"
    });
    try {
      p = await this.config.directory.createAsset(
        n,
        h || !0,
        o,
        i,
        a,
        s,
        r,
        d,
        l
      ), (m = this.logService) == null || m.log("LOG_UPLOAD_RESPONSE", "createAssetForUser", p, n, r), (y = this.logService) == null || y.log("LOG_UPLOAD_STATUS", p.response.statusCode, p.response, "user");
    } catch (R) {
      throw (I = this.logService) == null || I.log("LOG_UPLOAD_ERROR", "user", {
        fullPath: n,
        contentType: o,
        fileSize: r,
        repository: ((P = this.config.repository) == null ? void 0 : P.name) || "unknown"
      }, R), this.handleError(
        He.UPLOAD_FAILED.code,
        R
      );
    }
    return { result: p };
  }
  /**
   * Generate a pre-signed URL for downloading an asset
   * @param options - Options for URL generation
   * @returns Promise resolving to pre-signed URL result
   */
  async generatePreSignedUrl(e) {
    try {
      const {
        asset: s
      } = e, { result: r } = await Oo(this.httpService, s);
      return r;
    } catch (s) {
      throw this.handleError(
        He.URL_GENERATION_FAILED.code,
        s
      );
    }
  }
  /**
   * Generate a shareable pre-signed URL by base64 encoding the URL
   * This is useful for passing the URL via URL params
   * @param url - The pre-signed URL to share
   * @returns The shareable pre-signed URL
   */
  generateShareablePreSignedUrl(e) {
    return e ? btoa(e) : "";
  }
  /**
   * Generate a unique file name for the uploaded file
   * @param fileName - The original file name
   * @returns The unique file name
   */
  generateFileName(e) {
    const [s, r] = e.split("."), n = Date.now();
    return `${s}-${n}.${r}`;
  }
  /**
   * Dispatch a status event
   * @param status - The status to dispatch
   */
  dispatchStatusEvent(e) {
    window.dispatchEvent(new Dd({ status: e, progress: this._uploadProgressPercentage }));
  }
  /**
   * Get upload progress for an ongoing upload
   * @returns Promise resolving to upload progress information
   */
  getUploadProgress() {
    return (e, s) => {
      this._uploadProgressPercentage = Math.round(e / s * 100), e === s && (this._uploadBytesCompleted = !0), this.uploadStatus = nt.UPLOADING;
    };
  }
  /**
   * Prepare the RAPI session for the upload service.
   */
  prepareSession() {
    this.httpService.setAuthToken(this.authConfig.token), this.httpService.setApiKey(this.authConfig.apiKey);
    const e = Ed(this.httpService, this.config.endpoint);
    return e.setLinksCache(new Lo()), e;
  }
  /**
   * Convert a file to a sliceable data object
   * @param file - The file to convert
   * @returns The sliceable data object
   */
  convertToSliceableData(e) {
    return e instanceof ArrayBuffer ? new Uint8Array(e) : e;
  }
  /**
   * Get the size of a file
   * @param file - The file to get the size of
   * @returns The size of the file
   */
  getFileSize(e) {
    return e instanceof ArrayBuffer ? e.byteLength : "size" in e ? e.size : 0;
  }
  /**
   * Build a path for an asset for uploading.
   * @param path - The path to the asset
   * @param fileName - The name of the asset
   * @returns The full path to the asset
   */
  buildPath(e, s) {
    const r = [e, s].filter(Boolean).join("/").replace(/\/+/g, "/");
    return r.startsWith("/") ? r.substring(1) : r;
  }
  /**
   * Validate required configuration fields
   * @param validations - Array of field validations to perform
   * @throws Error if any required field is missing
   */
  validateRequiredConfig(e) {
    for (const { field: s, errorCode: r } of e)
      if (!this.config[s])
        throw this.handleError(
          r.code,
          new Error(r.message)
        );
  }
  /**
   * Handle an error
   * @param code - The error code
   * @param originalError - The original error
   * @param message - The error message
   * @returns The error
   */
  handleError(e, s, r) {
    let n = He[e];
    this.uploadStatus = nt.FAILED;
    const o = r || n.message;
    return this.config.environment === "local" || this.config.environment === "stage" ? (window == null || window.lana.log(`UploadService Error [${n.code}]: ${o}`), window == null || window.lana.log(s)) : n = He.UPLOAD_FAILED, new class extends Error {
      constructor(a, d, h) {
        super(a), this.code = d, this.originalError = h, this.name = "UploadServiceError";
      }
    }(o, n.code, s);
  }
  /**
   * Update the service configuration
   * @param newConfig - New configuration to apply
   */
  updateConfig(e) {
    this.config = { ...this.config, ...e }, (e.authConfig || e.endpoint) && (this.session = this.prepareSession());
  }
  /**
   * Get the current configuration
   * @returns Current service configuration
   */
  getConfig() {
    return { ...this.config };
  }
}
const Ud = async (t) => {
  var n, o, i;
  const s = {
    tokenType: ((n = window == null ? void 0 : window.adobeIMS) == null ? void 0 : n.isSignedInUser()) || !1 ? "user" : "guest",
    token: (i = (o = window == null ? void 0 : window.adobeIMS) == null ? void 0 : o.getAccessToken()) == null ? void 0 : i.token,
    apiKey: Id
  }, r = new kd({
    authConfig: s,
    endpoint: gd[t.environment],
    basePath: Td,
    environment: t.environment
  });
  return await r.setIndexRepository(), await r.initializeLogging(), r;
};
export {
  Ld as E,
  md as U,
  Ud as i
};
//# sourceMappingURL=index-CBsgbXDI.min.js.map
