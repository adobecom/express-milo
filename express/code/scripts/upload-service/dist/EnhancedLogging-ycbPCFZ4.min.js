const S = {
  GUEST: "guest"
}, i = {
  GUEST_START: "Creating asset for guest user",
  USER_START: "Creating asset for authenticated user",
  GUEST_ERROR: "Error creating asset for guest",
  USER_ERROR: "Error creating asset for authenticated user",
  UPLOAD_SUCCESSFUL: "Upload successful",
  UPLOAD_REDIRECT: "Upload redirect",
  UPLOAD_FAILED: "Upload failed",
  UNKNOWN_STATUS: "Unknown status code"
}, u = {
  200: { icon: "✅", message: "Upload successful" },
  201: { icon: "✅", message: "Upload successful" },
  202: { icon: "✅", message: "Upload accepted - processing asynchronously" },
  400: { icon: "❌", message: "Bad Request" },
  401: { icon: "❌", message: "Unauthorized" },
  403: { icon: "❌", message: "Forbidden" },
  404: { icon: "❌", message: "Not Found" },
  409: { icon: "⚠️", message: "Conflict" },
  412: { icon: "⚠️", message: "Precondition Failed" },
  413: { icon: "❌", message: "Payload Too Large" },
  429: { icon: "❌", message: "Rate Limited" },
  500: { icon: "❌", message: "Internal Server Error" },
  502: { icon: "❌", message: "Bad Gateway" },
  503: { icon: "❌", message: "Service Unavailable" },
  504: { icon: "❌", message: "Gateway Timeout" }
}, d = {
  401: "Invalid or expired authentication token",
  403: "Insufficient permissions or resource access denied",
  404: "Repository, directory, or resource not found",
  409: "Asset already exists or version conflict",
  412: "Version mismatch or etag validation failed",
  413: "File size exceeds maximum allowed limit",
  429: "Too many requests - rate limit exceeded",
  500: "Server encountered an internal error",
  502: "Server acting as gateway received invalid response",
  503: "Service temporarily unavailable",
  504: "Gateway timeout while waiting for response"
};
class f {
  constructor() {
    this.log = console;
  }
  /**
   * Get operation display name
   */
  getOperationName(e, s = !1) {
    return s ? e === S.GUEST ? i.GUEST_ERROR : i.USER_ERROR : e === S.GUEST ? i.GUEST_START : i.USER_START;
  }
  /**
   * Extract response headers for logging
   */
  extractResponseHeaders(e = {}) {
    return {
      contentLength: e["content-length"] || "unknown",
      retryAfter: e["retry-after"] || null,
      rateLimitRemaining: e["x-ratelimit-remaining"] || null,
      rateLimitReset: e["x-ratelimit-reset"] || null
    };
  }
  /**
   * Create log data for upload response
   */
  createUploadResponseLogData(e, s, a, t) {
    var n, g;
    const { response: o } = s, r = this.extractResponseHeaders(o.headers);
    return {
      operation: e,
      fullPath: a,
      fileSize: t,
      statusCode: o.statusCode,
      statusMessage: o.message,
      responseCode: o.code,
      hasAsset: !!s.result,
      assetId: (n = s.result) == null ? void 0 : n.assetId,
      assetName: (g = s.result) == null ? void 0 : g.name,
      ...r
    };
  }
  /**
   * Log based on response status code range
   */
  logByStatusRange(e, s) {
    e >= 200 && e < 300 ? this.log.log(i.UPLOAD_SUCCESSFUL, s) : e >= 300 && e < 400 ? this.log.log(i.UPLOAD_REDIRECT, s) : this.log.log(i.UPLOAD_FAILED, s);
  }
  /**
   * Create status log message with icon and user type
   */
  createStatusLogMessage(e, s) {
    const a = u[e];
    return a ? `${a.icon} ${a.message} (${e}) for ${s} user` : `ℹ️ ${i.UNKNOWN_STATUS} (${e}) for ${s} user`;
  }
  /**
   * Handle success status codes (200-299)
   */
  handleSuccessStatus(e, s) {
    const a = this.createStatusLogMessage(e, s);
    this.log.log(a);
  }
  /**
   * Handle client error status codes (400-499)
   */
  handleClientErrorStatus(e, s, a) {
    var n, g, l, c, m;
    const t = this.createStatusLogMessage(e, a), r = {
      message: s.message || d[e],
      code: s.code,
      authType: a
    };
    e === 413 ? r.maxSize = ((n = s.headers) == null ? void 0 : n["x-max-upload-size"]) || "unknown" : e === 429 ? (r.retryAfter = ((g = s.headers) == null ? void 0 : g["retry-after"]) || "unknown", r.rateLimitReset = ((l = s.headers) == null ? void 0 : l["x-ratelimit-reset"]) || "unknown", r.rateLimitRemaining = ((c = s.headers) == null ? void 0 : c["x-ratelimit-remaining"]) || "0") : e === 503 && (r.retryAfter = ((m = s.headers) == null ? void 0 : m["retry-after"]) || "unknown"), e === 409 || e === 412 ? this.log.log(t, r) : this.log.log(t, r);
  }
  /**
   * Handle server error status codes (500-599)
   */
  handleServerErrorStatus(e, s, a) {
    var n;
    const t = this.createStatusLogMessage(e, a), r = {
      message: s.message || d[e],
      authType: a
    };
    e === 503 && (r.retryAfter = ((n = s.headers) == null ? void 0 : n["retry-after"]) || "unknown"), this.log.log(t, r);
  }
  /**
   * Format error object for logging
   */
  formatError(e) {
    var s;
    return e instanceof Error ? {
      message: e.message,
      name: e.name,
      code: e.code,
      statusCode: (s = e.response) == null ? void 0 : s.statusCode
    } : e;
  }
  /**
   * Log detailed upload response information
   */
  logUploadResponse(e, s, a, t) {
    const o = this.createUploadResponseLogData(e, s, a, t);
    this.logByStatusRange(s.response.statusCode, o);
  }
  /**
   * Handle specific status codes with appropriate logging and actions
   */
  handleUploadStatusCode(e, s, a) {
    if (e >= 200 && e < 300)
      this.handleSuccessStatus(e, a);
    else if (e >= 400 && e < 500)
      this.handleClientErrorStatus(e, s, a);
    else if (e >= 500)
      this.handleServerErrorStatus(e, s, a);
    else {
      const t = this.createStatusLogMessage(e, a);
      this.log.log(t, { message: s.message, authType: a });
    }
  }
  /**
   * Log upload operation start with context
   */
  logUploadStart(e, s) {
    const a = this.getOperationName(e);
    this.log.log(`${a}:`, s);
  }
  /**
   * Log upload operation error with detailed context
   */
  logUploadError(e, s, a) {
    const t = this.getOperationName(e, !0);
    this.log.log(`${t}:`, {
      ...s,
      error: this.formatError(a)
    });
  }
}
export {
  f as EnhancedLogging
};
//# sourceMappingURL=EnhancedLogging-ycbPCFZ4.min.js.map
