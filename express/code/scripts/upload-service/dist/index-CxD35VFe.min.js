const Nd = {
  LOCAL: "local"
};
var nt = /* @__PURE__ */ ((t) => (t.IDLE = "idle", t.UPLOADING = "uploading", t.COMPLETED = "completed", t.FAILED = "failed", t))(nt || {}), X;
(function(t) {
  t.ACCESS_DENIED = "http://ns.adobe.com/adobecloud/problem/accessdenied", t.ASSET_LOCKED = "http://ns.adobe.com/adobecloud/problem/assetlocked", t.ASSET_MOVED = "http://ns.adobe.com/adobecloud/problem/assetmoved", t.ASSET_NAME_CONFLICT = "http://ns.adobe.com/adobecloud/problem/assetnameconflict", t.ASSET_NAME_INVALID = "http://ns.adobe.com/adobecloud/problem/assetnamenotvalid", t.ASSET_NOT_FOUND = "http://ns.adobe.com/adobecloud/problem/assetnotfound", t.ASSET_STATE_NOT_ALLOWED = "http://ns.adobe.com/adobecloud/problem/assetstatenotallowed", t.BAD_REQUEST = "http://ns.adobe.com/adobecloud/problem/badrequest", t.BULK_REQUEST_NOT_ATTEMPTED = "http://ns.adobe.com/adobecloud/problem/bulkrequestnotattempted", t.COMPOSITE_INTEGRITY = "http://ns.adobe.com/adobecloud/problem/compositeintegrity", t.DCX_VALIDATION = "http://ns.adobe.com/adobecloud/problem/dcxvalidation", t.DIRECTORY_NOT_EMPTY = "http://ns.adobe.com/adobecloud/problem/directorynotempty", t.EMBED_INVALID = "http://ns.adobe.com/adobecloud/problem/embedinvalid", t.EMBED_TOO_LARGE = "http://ns.adobe.com/adobecloud/problem/embedtoolarge", t.ENCRYPTION_KEY_INACCESSIBLE = "http://ns.adobe.com/adobecloud/problem/encryptionkeyinaccessible", t.INVALID_FRAGMENT = "http://ns.adobe.com/adobecloud/problem/invalidfragment", t.LIMIT_CHILDREN_COUNT = "http://ns.adobe.com/adobecloud/problem/limit/childrencount", t.LIMIT_COMPONENT_COUNT = "http://ns.adobe.com/adobecloud/problem/limit/componentcount", t.LIMIT_EMBED_SELECTOR_COUNT = "http://ns.adobe.com/adobecloud/problem/limit/embedspecifierselectorcount", t.LIMIT_MILESTONE_COUNT = "http://ns.adobe.com/adobecloud/problem/limit/milestonecount", t.LIMIT_MILESTONE_LABEL_LENGTH = "http://ns.adobe.com/adobecloud/problem/limit/milestonelabellength", t.LIMIT_NAME_LENGTH = "http://ns.adobe.com/adobecloud/problem/limit/namelength", t.LIMIT_OPERATION_COUNT = "http://ns.adobe.com/adobecloud/problem/limit/operationcount", t.LIMIT_PATH_SEGMENT_COUNT = "http://ns.adobe.com/adobecloud/problem/limit/pathsegmentcount", t.LIMIT_RESOURCE_COUNT = "http://ns.adobe.com/adobecloud/problem/limit/resourcecount", t.LIMIT_RESOURCE_SIZE = "http://ns.adobe.com/adobecloud/problem/limit/resourcesize", t.NOT_ENTITLED = "http://ns.adobe.com/adobecloud/problem/notentitled", t.OPERATION_FAILED = "http://ns.adobe.com/adobecloud/problem/operationfailed", t.OPERATION_TARGET_CONFLICT = "http://ns.adobe.com/adobecloud/problem/operation/targetconflict", t.QUOTA_EXCEEDED = "http://ns.adobe.com/adobecloud/problem/quotaexceeded", t.REPOSITORY_NOT_FOUND = "http://ns.adobe.com/adobecloud/problem/repositorynotfound", t.RESOURCE_BLOCKED = "http://ns.adobe.com/adobecloud/problem/resourceblocked", t.RESOURCE_NOT_ALLOWED = "http://ns.adobe.com/adobecloud/problem/resourcenotallowed", t.RESOURCE_NOT_FOUND = "http://ns.adobe.com/adobecloud/problem/resourcenotfound", t.RESOURCE_NOT_READY = "http://ns.adobe.com/adobecloud/problem/resourcenotready", t.RESPONSE_TOO_LARGE = "http://ns.adobe.com/adobecloud/problem/responsetoolarge", t.USER_BLOCKED = "http://ns.adobe.com/adobecloud/problem/userblocked", t.VERSION_NOT_FOUND = "http://ns.adobe.com/adobecloud/problem/versionnotfound", t.PARTIAL_ASSET = "http://ns.adobe.com/adobecloud/problem/partialasset";
})(X || (X = {}));
const I = { ASSET_MOVED: "ASSET_MOVED", INVALID_JSON: "INVALID_JSON", READ_ONLY: "READ_ONLY", INVALID_PARAMS: "", INVALID_LINKS: "INVALID_LINKS", PRECONDITION_FAILED: "PRECONDITION_FAILED", INVALID_DATA: "INVALID_DATA", DUPLICATE_VALUE: "DUPLICATE_VALUE", NO_BASE_BRANCH_DATA: "NO_BASE_BRANCH_DATA", INVALID_STATE: "INVALID_STATE", DELETED_COMPOSITE: "DELETED_COMPOSITE", INCOMPLETE_COMPOSITE: "INCOMPLETE_COMPOSITE", UNEXPECTED_RESPONSE: "UNEXPECTED_RESPONSE", NETWORK_ERROR: "NETWORK_ERROR", COMPONENT_DOWNLOAD_ERROR: "COMPONENT_DOWNLOAD_ERROR", COMPONENT_UPLOAD_ERROR: "COMPONENT_UPLOAD_ERROR", COMPONENT_MODIFIED_ERROR: "COMPONENT_MODIFIED_ERROR", UPDATE_CONFLICT: "UPDATE_CONFLICT", NO_COMPOSITE: "NO_COMPOSITE", ALREADY_EXISTS: "ALREADY_EXISTS", SERVICE_IS_INACTIVE: "SERVICE_IS_INACTIVE", EXCEEDS_QUOTA: "EXCEEDS_QUOTA", NOT_IMPLEMENTED: "NOT_IMPLEMENTED", RETRYABLE_SERVER_ERROR: "RETRYABLE_SERVER_ERROR", TIMED_OUT: "TIMED_OUT", UNEXPECTED: "UNEXPECTED", TERMINATED_INPUTSTREAM: "TERMINATED_INPUTSTREAM", WRONG_ENDPOINT: "WRONG_ENDPOINT", OUT_OF_SPACE: "ENOSPC", FILE_EXISTS_IN_CLOUD: "FILE_EXISTS_IN_CLOUD", ASSET_NOT_FOUND: "ASSET_NOT_FOUND", COMPOSITE_NOT_FOUND: "COMPOSITE_NOT_FOUND", NOT_FOUND: "NOT_FOUND", UNAUTHORIZED: "UNAUTHORIZED", FORBIDDEN: "FORBIDDEN", METHOD_NOT_ALLOWED: "METHOD_NOT_ALLOWED", NOT_ACCEPTABLE: "NOT_ACCEPTABLE", BANDWIDTH_LIMIT_EXCEEDED: "BANDWIDTH_LIMIT_EXCEEDED", ABORTED: "ABORTED", TOO_MANY_REDIRECTS: "TOO_MANY_REDIRECTS", INSECURE_REDIRECT: "INSECURE_REDIRECT", RESOURCE_NOT_READY: "RESOURCE_NOT_READY", ASSET_LOCKED: "ASSET_LOCKED" }, Uo = { [I.SERVICE_IS_INACTIVE]: !0, [I.ABORTED]: !0, [I.INSECURE_REDIRECT]: !0, [I.TOO_MANY_REDIRECTS]: !0, [I.NOT_IMPLEMENTED]: !0, [I.EXCEEDS_QUOTA]: !0, [I.RETRYABLE_SERVER_ERROR]: !0, [I.TIMED_OUT]: !0, [I.TERMINATED_INPUTSTREAM]: !0, [I.WRONG_ENDPOINT]: !0, [I.OUT_OF_SPACE]: !0, [I.INVALID_PARAMS]: !0, [I.INVALID_STATE]: !0 };
let c = class Xe extends Error {
  constructor(e, s, r, n, o) {
    var i;
    if (super(), this.code = e, this.name = "AdobeDCXError", this._additionalData = {}, ((i = n == null ? void 0 : n.headers) === null || i === void 0 ? void 0 : i["content-type"]) === "application/problem+json" && n.response && typeof n.response == "object" && typeof n.response.slice == "function") try {
      const a = JSON.parse(new TextDecoder("utf-8").decode(n.response));
      n.response = a;
    } catch (a) {
      const d = n.response;
      n.response = { originalBody: d, message: "Failed to parse JSON problem type response body.", parseError: a };
    }
    if (r instanceof Error && (this._underlyingError = r), this._response = n || (it(r) ? r.response : void 0), this._additionalData = o, this._message = s, this.message = (typeof e == "string" && e !== "" ? "[" + e + "] " : "") + (this._message || ""), Object.setPrototypeOf(this, Xe.prototype), Error.captureStackTrace) Error.captureStackTrace(this, Xe);
    else try {
      const a = new Error();
      if (a.name = this.name, a.stack) {
        const d = a.stack.split(`
`);
        d.length > 0 && d.splice(1, 1), this.stack = d.join(`
`);
      }
    } catch {
    }
  }
  get response() {
    return this._response;
  }
  get problemType() {
    var e;
    if (((e = this._response) === null || e === void 0 ? void 0 : e.headers["content-type"]) === "application/problem+json") return this._response.response.type;
  }
  get underlyingError() {
    return this._underlyingError;
  }
  get additionalData() {
    return this._additionalData;
  }
  set additionalData(e) {
    this._additionalData = e;
  }
  get failedComponents() {
    return this._additionalData.failedComponents;
  }
  static wrapError(e, s, r, n) {
    var o, i, a, d;
    if (r && Uo[r.code]) return r;
    if (n && typeof n == "object") {
      const h = n.statusCode, l = h === 403 && (((a = (i = (o = n.response) === null || o === void 0 ? void 0 : o.message) === null || i === void 0 ? void 0 : i.match(/code=(\d+.\d+)/)) === null || a === void 0 ? void 0 : a[1]) === "403.1" || ((d = n.response) === null || d === void 0 ? void 0 : d.type) === X.QUOTA_EXCEEDED);
      if (h >= 500 && h < 600 || l) h === 501 ? (e = I.NOT_IMPLEMENTED, s = "Unimplemented request") : h === 507 || l ? (e = I.EXCEEDS_QUOTA, s = "Quota exceeded") : (e = I.RETRYABLE_SERVER_ERROR, s = "Server error");
      else if (r instanceof Xe && e === r.code && r.code === this.UNEXPECTED_RESPONSE) return r;
    }
    return new Xe(e, s, r, n);
  }
  toString() {
    return `${this.name}: ${this.message}`;
  }
  static networkError(e, s, r) {
    return Xe.wrapError(I.NETWORK_ERROR, e, s, r);
  }
  static unexpectedResponse(e, s, r) {
    return Xe.wrapError(I.UNEXPECTED_RESPONSE, e, s, r);
  }
};
function Vs(t, e, s) {
  return c.unexpectedResponse(t, e, s);
}
function it(t) {
  return !(!t || typeof t != "object") && t.name === "AdobeDCXError";
}
function xo(t) {
  const e = Array.isArray(t.response) ? t.response.reduce((n, o) => n || o.error, void 0) : t.response.error;
  if (!e) return t;
  const s = Yt(t.statusCode, t);
  if (s instanceof c) throw s;
  const r = Bo(e, t);
  throw r || new c(e.type || c.UNEXPECTED_RESPONSE, e.title || "Unexpected Error", e, t);
}
c.ABORTED = I.ABORTED, c.INSECURE_REDIRECT = I.INSECURE_REDIRECT, c.TOO_MANY_REDIRECTS = I.TOO_MANY_REDIRECTS, c.INVALID_JSON = I.INVALID_JSON, c.READ_ONLY = I.READ_ONLY, c.INVALID_PARAMS = I.INVALID_PARAMS, c.INVALID_DATA = I.INVALID_DATA, c.DUPLICATE_VALUE = I.DUPLICATE_VALUE, c.NO_BASE_BRANCH_DATA = I.NO_BASE_BRANCH_DATA, c.INVALID_STATE = I.INVALID_STATE, c.DELETED_COMPOSITE = I.DELETED_COMPOSITE, c.INCOMPLETE_COMPOSITE = I.INCOMPLETE_COMPOSITE, c.UNEXPECTED_RESPONSE = I.UNEXPECTED_RESPONSE, c.NETWORK_ERROR = I.NETWORK_ERROR, c.COMPONENT_DOWNLOAD_ERROR = I.COMPONENT_DOWNLOAD_ERROR, c.COMPONENT_UPLOAD_ERROR = I.COMPONENT_UPLOAD_ERROR, c.COMPONENT_MODIFIED_ERROR = I.COMPONENT_MODIFIED_ERROR, c.UPDATE_CONFLICT = I.UPDATE_CONFLICT, c.NO_COMPOSITE = I.NO_COMPOSITE, c.ALREADY_EXISTS = I.ALREADY_EXISTS, c.SERVICE_IS_INACTIVE = I.SERVICE_IS_INACTIVE, c.EXCEEDS_QUOTA = I.EXCEEDS_QUOTA, c.NOT_IMPLEMENTED = I.NOT_IMPLEMENTED, c.RETRYABLE_SERVER_ERROR = I.RETRYABLE_SERVER_ERROR, c.TIMED_OUT = I.TIMED_OUT, c.UNEXPECTED = I.UNEXPECTED, c.TERMINATED_INPUTSTREAM = I.TERMINATED_INPUTSTREAM, c.WRONG_ENDPOINT = I.WRONG_ENDPOINT, c.OUT_OF_SPACE = I.OUT_OF_SPACE, c.FILE_EXISTS_IN_CLOUD = I.FILE_EXISTS_IN_CLOUD, c.ASSET_NOT_FOUND = I.ASSET_NOT_FOUND, c.COMPOSITE_NOT_FOUND = I.COMPOSITE_NOT_FOUND, c.NOT_FOUND = I.NOT_FOUND, c.UNAUTHORIZED = I.UNAUTHORIZED, c.FORBIDDEN = I.FORBIDDEN, c.PRECONDITION_FAILED = I.PRECONDITION_FAILED, c.RESOURCE_NOT_READY = I.RESOURCE_NOT_READY, c.ASSET_LOCKED = I.ASSET_LOCKED;
const $t = /* @__PURE__ */ new Map([[400, { code: I.UNEXPECTED_RESPONSE, message: "Bad request" }], [401, { code: I.UNAUTHORIZED, message: "Unauthorized" }], [403, { code: I.FORBIDDEN, message: "Forbidden" }], [404, { code: I.NOT_FOUND, message: "Not found" }], [405, { code: I.METHOD_NOT_ALLOWED, message: "The user is authorized to act on this resource, but cannot use the specified method." }], [406, { code: I.NOT_ACCEPTABLE, message: "Unable to obtain resource in a content type matching the Accept header or rendition type parameter." }], [409, { code: I.ALREADY_EXISTS, message: "Already exists" }], [412, { code: I.PRECONDITION_FAILED, message: "Precondition failed" }], [501, { code: I.NOT_IMPLEMENTED, message: "Not implemented" }], [507, { code: I.EXCEEDS_QUOTA, message: "Exceeds quota" }], [509, { code: I.BANDWIDTH_LIMIT_EXCEEDED, message: "Bandwidth limit exceeded" }]]), on = new Map(Object.entries({ [X.ASSET_MOVED]: { code: I.ASSET_MOVED, message: "Asset moved to a different region while operation was in progress" }, [X.COMPOSITE_INTEGRITY]: { code: I.INCOMPLETE_COMPOSITE, message: "Incomplete composite. invoke missingComponentsFromError with this error for more information." }, [X.PARTIAL_ASSET]: { code: I.NO_COMPOSITE, message: "Asset is partially created. No Manifest found" }, [X.LIMIT_RESOURCE_COUNT]: { code: I.UNEXPECTED_RESPONSE, message: "Resource count limit exceed" }, [X.QUOTA_EXCEEDED]: { code: I.EXCEEDS_QUOTA, message: "Quota exceeded" }, [X.ASSET_LOCKED]: { code: I.ASSET_LOCKED, message: "Asset is locked and cannot be modified" } })), Bo = (t, e) => {
  var s;
  const r = on.get((s = t.type) !== null && s !== void 0 ? s : "") || (typeof t.status == "number" ? $t.get(t.status) : void 0);
  return r ? new c(r.code, r.message, t, e) : void 0;
}, Tt = (t) => {
  var e, s;
  const r = on.get((s = (e = t.response) === null || e === void 0 ? void 0 : e.type) !== null && s !== void 0 ? s : "") || $t.get(t.statusCode);
  return r ? new c(r.code, r.message, void 0, t, t.response) : void 0;
}, Yt = (t, e) => t && e ? t < 300 && t > 199 || Tt(e) || !1 : new c(I.NETWORK_ERROR, "Invalid or missing status code or response", void 0, e);
let wt;
const jo = new Uint8Array(16);
function Vo() {
  if (!wt && (wt = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !wt)) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return wt(jo);
}
var Fo = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
const oe = [];
for (let t = 0; t < 256; ++t) oe.push((t + 256).toString(16).slice(1));
var Rr = { randomUUID: typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto) };
function Ho(t, e, s) {
  if (Rr.randomUUID && !e && !t) return Rr.randomUUID();
  const r = (t = t || {}).random || (t.rng || Vo)();
  return r[6] = 15 & r[6] | 64, r[8] = 63 & r[8] | 128, function(n, o = 0) {
    return oe[n[o + 0]] + oe[n[o + 1]] + oe[n[o + 2]] + oe[n[o + 3]] + "-" + oe[n[o + 4]] + oe[n[o + 5]] + "-" + oe[n[o + 6]] + oe[n[o + 7]] + "-" + oe[n[o + 8]] + oe[n[o + 9]] + "-" + oe[n[o + 10]] + oe[n[o + 11]] + oe[n[o + 12]] + oe[n[o + 13]] + oe[n[o + 14]] + oe[n[o + 15]];
  }(r);
}
const Go = (t) => S(t) && (q(t.pipe) || q(t.pipeTo)), S = (t) => t != null && typeof t == "object", q = (t) => typeof t == "function", fe = (t) => Array.isArray(t), $o = (t) => S(t) && q(t.constructor) && t.constructor.name === "ArrayBuffer" && q(t.slice), Or = (t) => {
  if (typeof t != "string") return !1;
  const e = t.toLowerCase().split("application/");
  if (e.length < 2) return !1;
  const s = e[1].split(";")[0].trim();
  return s === "json" || s.endsWith("+json");
}, qt = () => {
  try {
    return Object.prototype.toString.call(globalThis.process) === "[object process]";
  } catch {
    return !1;
  }
}, Yo = () => typeof self == "object" && self.self === self, zt = () => Ho(), Wt = (t) => {
  return typeof (e = t) == "string" && Fo.test(e);
  var e;
}, he = (...t) => !t || !Array.isArray(t) || t.length < 1 ? {} : t.reduce((e, s) => {
  const r = S(e) ? e : {};
  if (S(s)) for (const n in s) Object.prototype.hasOwnProperty.call(s, n) && (r[n] = s[n]);
  return r;
}), Ue = (t, ...e) => {
  if (!e.length) return t;
  const s = e.shift();
  if (S(t) && S(s)) for (const r in s) S(s[r]) && !fe(s[r]) ? (t[r] || Object.assign(t, { [r]: {} }), Ue(t[r], s[r])) : fe(t[r]) && fe(s[r]) ? Object.assign(t, { [r]: s[r] }) : Object.assign(t, { [r]: s[r] });
  return Ue(t, ...e);
}, an = (...t) => {
  if (!t || !Array.isArray(t)) return "";
  const e = [], s = t.length;
  for (let r = 0; r < s; r++) {
    let n = t[r];
    typeof n == "string" && n !== "" && (r === 0 && n.length !== 1 || n.charAt(0) === "/" && (n = n.slice(1)), r !== s - 1 && n.charAt(n.length - 1) === "/" && (n = n.slice(0, n.length - 1)), e.push(n));
  }
  return e.join("/");
}, qo = new RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?"), zo = (t) => {
  const e = t.match(qo) || [];
  return { scheme: e[2], authority: e[4], path: e[5], query: e[7], fragment: e[9] };
}, Ss = (t) => {
  const e = zo(t), s = e.scheme, r = e.authority, n = s === "https" ? 443 : s === "http" ? 80 : -1;
  let o;
  return s && r && (o = (s + "://" + r).toLowerCase(), n >= 0 && r.indexOf(":") < 0 && (o = o + ":" + n)), o;
}, Wo = (t) => {
  if (!t || typeof t != "string") return t;
  const e = (t = (t = (t = (t = t.indexOf("//") > -1 ? t.split("/")[2] : t.split("/")[0]).split("?")[0]).split("/")[0]).split(":")[0]).split(".");
  return t = e.slice(Math.max(e.length - 2, 0)).join(".");
}, Rt = 48, Ko = 49, Kt = 57, Cs = 97, Ns = 65, cn = 102, dn = 70, Pr = (t) => {
  const e = t.charCodeAt(0);
  return e >= Rt && e <= Kt || e >= Cs && e <= cn || e >= Ns && e <= dn;
}, Vt = (t) => t.length >= 3 && t.charAt(0) === "%" && Pr(t.charAt(1)) && Pr(t.charAt(2)), Mt = (t) => {
  const e = t.charCodeAt(0);
  return e >= Rt && e <= Kt ? e - Rt : e >= Cs && e <= cn ? 10 + e - Cs : e >= Ns && e <= dn ? 10 + e - Ns : 0;
}, Fs = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_.~", Sr = "0123456789ABCDEF", Hs = (t) => {
  const e = [];
  for (let s = 0; s < 128; ++s) e.push(t.indexOf(String.fromCharCode(s)) !== -1);
  return e;
}, hn = Hs(Fs + ":/?#[]@!$&'()*+,;="), Xo = Hs(Fs);
Hs(Fs + "/");
const Zo = (t, e) => {
  if (t < 128 && e[t]) return String.fromCharCode(t);
  let s = "%";
  return s += Sr.charAt(t >> 4 & 15), s += Sr.charAt(15 & t), s;
}, Jo = (t) => {
  const e = [];
  for (let s = 0; s < t.length; s++) {
    let r = t.charCodeAt(s);
    r < 128 ? e.push(r) : r < 2048 ? e.push(192 | r >> 6, 128 | 63 & r) : r < 55296 || r >= 57344 ? e.push(224 | r >> 12, 128 | r >> 6 & 63, 128 | 63 & r) : ++s < t.length && (r = 65536 + ((1023 & r) << 10 | 1023 & t.charCodeAt(s)), e.push(240 | r >> 18, 128 | r >> 12 & 63, 128 | r >> 6 & 63, 128 | 63 & r));
  }
  return e;
}, Gs = (t, e) => {
  const s = Jo(t);
  let r = "";
  for (let n = 0; n < s.length; n++) r += Zo(s[n], e);
  return r;
}, pt = (t) => (t = t.normalize("NFC"), Gs(t, Xo)), _s = (t) => {
  t = t.normalize("NFC");
  let e = 0, s = "";
  for (; e < t.length; ) Vt(t.substr(e)) ? (s += t.substr(e, 3), e += 3) : s += Gs(t.charAt(e++), hn);
  return s;
}, Ve = (t, e) => {
  let s = 0, r = "", n = !1, o = !1, i = !1, a = !0, d = !0, h = !1, l = "", p = "", _ = ",", f = -1;
  const A = (v) => {
    if (r += a ? p : h || d ? _ : ",", o && l && (a || h || d) && (r += pt(l), (!i || v.length > 0) && (r += "=")), v) {
      let P;
      P = n ? _s(v) : pt(v), f > 0 && (P = ((m, D) => {
        let k = 0;
        for (; k < m.length && D > 0; ) {
          if (Vt(m.substr(k))) {
            let j = (Mt(m.substr(k + 1)) << 4) + Mt(m.substr(k + 2));
            if (k += 3, !(192 & ~j)) for (; k < m.length && Vt(m.substr(k)) && (j = (Mt(m.substr(k + 1)) << 4) + Mt(m.substr(k + 2)), k += 3, (192 & j) == 128); ) ;
          } else ++k;
          --D;
        }
        return m.substr(0, k);
      })(P, f)), r += P;
    }
    a = !1, d = !1;
  };
  for (; s < t.length; ) if (t.charAt(s) === "{") {
    if (++s < t.length) {
      switch (n = !1, o = !1, p = "", _ = ",", i = !1, t.charAt(s++)) {
        case "+":
          n = !0;
          break;
        case "#":
          p = "#", n = !0;
          break;
        case ".":
          p = ".", _ = ".";
          break;
        case "/":
          p = "/", _ = "/";
          break;
        case ";":
          p = ";", _ = ";", o = i = !0;
          break;
        case "?":
          p = "?", _ = "&", o = !0;
          break;
        case "&":
          p = "&", _ = "&", o = !0;
          break;
        default:
          --s;
      }
      for (l = "", a = !0, d = !0; s < t.length; ) if (t.charAt(s) === "}" || t.charAt(s) === "," || t.charAt(s) === "*" || t.charAt(s) === ":") {
        if (h = !1, f = -1, t.charAt(s) === "*") {
          if (h = !0, ++s >= t.length) break;
        } else if (t.charAt(s) === ":") {
          if (++s >= t.length) break;
          for (t.charCodeAt(s) >= Ko && t.charCodeAt(s) <= Kt && (f = 0); s < t.length && t.charCodeAt(s) >= Rt && t.charCodeAt(s) <= Kt && f < 1e4; ) f = 10 * f + (t.charCodeAt(s++) - Rt);
          if (s >= t.length) break;
        }
        for (; s < t.length && t.charAt(s) !== "}" && t.charAt(s) !== ","; ) ++s;
        if (l.length > 0 && l.charAt(l.length - 1) === "*" && (h = !0, l = l.substr(0, l.length - 1)), l.length > 0) {
          const v = e ? e[l] : void 0;
          if (v || v === "") if (Array.isArray(v)) {
            f = -1;
            for (let P = 0; P < v.length; P++) A(String(v[P]));
          } else if (typeof v == "object" && v !== null) for (const P in v) Object.prototype.hasOwnProperty.call(v, P) && (y = P, b = String(v[P]), r += a ? p : h || d ? _ : ",", o && l && a && !h && (r += pt(l), (!i || b.length > 0) && (r += "=")), y && (r += n ? _s(y) : pt(y), r += h ? "=" : ",", b && (r += n ? _s(b) : pt(b))), a = !1, d = !1);
          else A(String(v));
        }
        if (t.charAt(s++) === "}") break;
        l = "", d = !0;
      } else l += t.charAt(s++);
    }
  } else Vt(t.substr(s)) ? (r += t.substr(s, 3), s += 3) : r += Gs(t.charAt(s++), hn);
  var y, b;
  return r;
}, Cr = (t, e) => {
  if (!t || typeof t != "string" || !e) return "";
  let s;
  return s = typeof e == "string" ? t.match(e) : e.exec(t), s ? s[1] : "";
};
function Ds(t, e, s, r) {
  return new (s || (s = Promise))(function(n, o) {
    function i(h) {
      try {
        d(r.next(h));
      } catch (l) {
        o(l);
      }
    }
    function a(h) {
      try {
        d(r.throw(h));
      } catch (l) {
        o(l);
      }
    }
    function d(h) {
      var l;
      h.done ? n(h.value) : (l = h.value, l instanceof s ? l : new s(function(p) {
        p(l);
      })).then(i, a);
    }
    d((r = r.apply(t, [])).next());
  });
}
function ye(t, e) {
  return t ? new TextDecoder().decode(t) : "";
}
function Ie(t) {
  return new TextEncoder().encode(t);
}
function we(t, e) {
  const s = new Uint8Array(t.length + e.length);
  return s.set(t, 0), s.set(e, t.length), s;
}
function Qo(t) {
  const e = {};
  for (const [s, r] of t) e[s] = r;
  return e;
}
function ei(t, e) {
  return t.reduce((s, r, n) => (n % e == 0 ? s.unshift([r]) : s[0].push(r), s), []).reverse();
}
let $s = class {
  constructor(e) {
    this._handlers = {}, e.forEach((s) => {
      this._handlers[s] = [];
    });
  }
  on(e, s) {
    return this._handlers[e].push(s) - 1;
  }
  emit(e, s) {
    this._handlers[e].forEach((r) => {
      q(r) && r(...s);
    });
  }
  removeHandler(e, s) {
    delete this._handlers[e][s];
  }
  removeAllHandlers(e) {
    e ? this._handlers[e] = [] : this._handlers = {};
  }
};
const ln = [/^(?!^501$|^507$)^(5\d{2})$|429|423$/], Nr = (t, e) => {
  return typeof (s = t) == "object" && typeof s.test == "function" ? t.test(e.toString()) : e === t;
  var s;
};
function gt(t, e = ln) {
  return !!t && (Array.isArray(e) ? e.some((s) => Nr(s, t)) : Nr(e, t));
}
const ti = /^([^:]+):(.*)$/, Dr = /^\s+|\s+$/g, Ys = (t) => {
  const e = {}, s = t.split(/\r?\n/);
  let r, n;
  for (let o = 0; o < s.length; ++o) {
    const i = s[o];
    if (i.length > 0) {
      const a = i.charCodeAt(0);
      if (!r || a !== 9 && a !== 32) {
        const d = ti.exec(i);
        d && d.length > 1 && (r = d[1].toLowerCase(), n = d[2] || "", n = n.replace(Dr, ""), e[r] ? e[r] = e[r] + "," + n : e[r] = n);
      } else e[r] = e[r] + " " + i.replace(Dr, "");
    }
  }
  return e;
}, Ot = (t) => {
  if (t === null || typeof t != "object") return {};
  const e = {};
  for (const [s, r] of Object.entries(t)) e[s.toLowerCase()] = fe(r) ? r.join(";") : r;
  return e;
}, Oe = (t, e, s) => fe(e) ? new c(c.INVALID_PARAMS, `Param '${t}' type must be one of: [${e.join(",")}].${s && s.length > 0 ? " Possible values: " + s.join(", ") + "." : ""}`) : new c(c.INVALID_PARAMS, `Param '${t}' must be of type '${e}'.${s && s.length > 0 ? " Possible values: " + s.join(", ") + "." : ""}`), Ye = (t, e, s, r = !1, n = []) => {
  if (r && e == null) return !0;
  if (fe(s)) {
    for (const i in s) {
      const a = s[i];
      try {
        return Ye(t, e, a, r, n), !0;
      } catch {
      }
    }
    throw Oe(t, s, n);
  }
  if (s === "null" && e !== null || s === "undefined" && e !== void 0 || s === "nullish" && e != null) throw Oe(t, s, n);
  if (s === "null" || s === "undefined" || s === "nullish") return !0;
  if (!r && e == null) throw Oe(t, s, n);
  if (s.endsWith("[]")) {
    if (!fe(e)) throw Oe(t, s, n);
    return e.forEach((i, a) => {
      Ye(`${t}[${a}]`, i, s.substr(0, s.length - 2));
    }), !0;
  }
  let o = s.toLowerCase();
  switch (s) {
    case "integer":
    case "+number":
    case "-number":
      o = "number";
  }
  if (o === "array") {
    if (!fe(e)) throw Oe(t, s, n);
  } else if (o !== "enum" && (typeof e !== o || s === "integer" && (typeof e != "number" || !Number.isInteger(e)) || s === "+number" && (typeof e != "number" || e < 0) || s === "-number" && (typeof e != "number" || e > 0)))
    throw Oe(t, s, n);
  if (n.length > 0) {
    const i = n.length;
    let a = !1;
    for (let d = 0; d < i; d++) if (n[d] === e) {
      a = !0;
      break;
    }
    if (!a) throw Oe(t, s, n);
  }
  return !0;
};
function E(...t) {
  return t.map((e) => Ye(...e));
}
function un(t, e, ...s) {
  if (e = e ? " " + e + " " : " ", !t || typeof t != "object") throw new c(c.INVALID_PARAMS, `Object${e}is invalid.`);
  try {
    s.forEach((r) => {
      Ye(r[0], t[r[0]], r[1], r[2] || !1, r[3] || []);
    });
  } catch (r) {
    throw new c(c.INVALID_PARAMS, `Object${e}is invalid. ${r.message.replace("Param", "Property")}`, r);
  }
}
const pn = (t, e) => {
  if (t() === !1) throw new c(c.INVALID_PARAMS, e);
};
function si(t, e = {}, s) {
  const r = typeof e.selector == "function" ? e.selector : ri, n = Array.isArray(t) ? r(t, s) : t;
  if (!n) throw new c(c.INVALID_PARAMS, "Could not select appropriate link for usage");
  return n.templated ? typeof e.expander == "function" ? e.expander(n.href, s) : Ve(n.href, s) : n.href;
}
function ri(t, e = { mode: "id" }) {
  let s = t[0], r = 0;
  for (const n of t) {
    let o = 0;
    for (const i in n) i in e && n[i] === e[i] && o++;
    o > r && (r = o, s = n);
  }
  return s;
}
function w(t) {
  if (!S(t)) throw new Error("Expecting object");
  const e = {};
  for (const s in t) t[s] != null && (e[s] = t[s]);
  return e;
}
const ni = /^utf-?8|ascii|utf-?16-?le|ucs-?2|base-?64|latin-?1$/i, oi = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ii = /\s|\uFEFF|\xA0/, ai = /\r?\n[\x20\x09]+/g, ci = /[;,"]/, di = /[;,"]|\s/, Ut = 1, kr = 2, fs = 4;
function Lr(t) {
  return t.replace(oi, "");
}
function Ft(t) {
  return ii.test(t);
}
function hi(t, e) {
  for (; Ft(t[e]); ) e++;
  return e;
}
function wr(t) {
  return di.test(t);
}
class li {
  constructor(e) {
    this.refs = [], e && this.parse(e);
  }
  rel(e) {
    const s = [];
    for (let r = 0; r < this.refs.length; r++) this.refs[r].rel === e && s.push(this.refs[r]);
    return s;
  }
  get(e, s) {
    e = e.toLowerCase();
    const r = [];
    for (let n = 0; n < this.refs.length; n++) this.refs[n][e] === s && r.push(this.refs[n]);
    return r;
  }
  set(e) {
    return this.refs.push(e), this;
  }
  has(e, s) {
    e = e.toLowerCase();
    for (let r = 0; r < this.refs.length; r++) if (this.refs[r][e] === s) return !0;
    return !1;
  }
  parse(e, s = 0) {
    let r = s ? e.slice(s) : e;
    r = Lr(r).replace(ai, "");
    let n = Ut;
    const o = r.length;
    let i = 0, a = null;
    for (; i < o; ) if (n === Ut) {
      if (Ft(r[i])) {
        i++;
        continue;
      }
      if (r[i] !== "<") throw new Error('Unexpected character "' + r[i] + '" at offset ' + i);
      {
        const d = r.indexOf(">", i);
        if (d === -1) throw new Error("Expected end of URI delimiter at offset " + i);
        a = { uri: r.slice(i + 1, d) }, this.refs.push(a), i = d, n = kr;
      }
      i++;
    } else if (n === kr) {
      if (Ft(r[i])) {
        i++;
        continue;
      }
      if (r[i] === ";") n = fs, i++;
      else {
        if (r[i] !== ",") throw new Error('Unexpected character "' + r[i] + '" at offset ' + i);
        n = Ut, i++;
      }
    } else {
      if (n !== fs) throw new Error('Unknown parser state "' + n + '"');
      {
        if (r[i] === ";" || Ft(r[i])) {
          i++;
          continue;
        }
        const d = r.indexOf("=", i);
        if (d === -1) throw new Error("Expected attribute delimiter at offset " + i);
        const h = Lr(r.slice(i, d)).toLowerCase();
        let l = "";
        if (i = d + 1, i = hi(r, i), r[i] === '"') for (i++; i < o; ) {
          if (r[i] === '"') {
            i++;
            break;
          }
          r[i] === "\\" && i++, l += r[i], i++;
        }
        else {
          let p = i + 1;
          for (; !ci.test(r[p]) && p < o; ) p++;
          l = r.slice(i, p), i = p;
        }
        if (!(a && a[h] && ui(h))) if (a && h[h.length - 1] === "*") a[h] = pi(l);
        else if (l = h === "rel" || h === "type" ? l.toLowerCase() : l, a && a[h] != null) {
          const p = a[h];
          fe(p) ? p.push(l) : a[h] = [a[h], l];
        } else {
          if (!a) throw new Error("Unexpected null ref");
          a[h] = l;
        }
        switch (r[i]) {
          case ",":
            n = Ut;
            break;
          case ";":
            n = fs;
        }
        i++;
      }
    }
    return a = null, this;
  }
  toString() {
    const e = [];
    let s, r = "";
    for (let n = 0; n < this.refs.length; n++) s = this.refs[n], r = Object.keys(this.refs[n]).reduce(function(o, i) {
      return i === "uri" ? o : o + "; " + _n(i, s[i]);
    }, "<" + s.uri + ">"), e.push(r);
    return e.join(", ");
  }
}
const ks = (t) => ni.test(t), ui = (t) => t === "rel" || t === "type" || t === "media" || t === "title" || t === "title*", Mr = (t) => t.replace(/"/g, '\\"'), pi = (t) => {
  const e = /([^']+)?(?:'([^']+)')?(.+)/.exec(t) || [];
  return { language: e[2].toLowerCase(), encoding: ks(e[1]) ? null : e[1].toLowerCase(), value: ks(e[1]) ? decodeURIComponent(e[3]) : e[3] };
}, _n = (t, e) => Array.isArray(e) ? e.map((s) => _n(t, s)).join("; ") : t[t.length - 1] === "*" || typeof e != "string" ? ((s, r) => {
  const n = (r.encoding || "utf-8").toUpperCase(), o = r.language || "en";
  let i = "";
  return i = Buffer.isBuffer(r.value) && ks(n) ? r.value.toString(n) : Buffer.isBuffer(r.value) ? r.value.toString("hex").replace(/[0-9a-f]{2}/gi, "%$1") : encodeURIComponent(r.value), s + "=" + n + "'" + o + "'" + i;
})(t, e) : (/* @__PURE__ */ ((s) => s === "rel" || s === "type" || s === "anchor")(t) ? e = wr(e) ? '"' + Mr(e) + '"' : Mr(e) : wr(e) && (e = '"' + (e = (e = encodeURIComponent(e)).replace(/%20/g, " ").replace(/%2C/g, ",").replace(/%3B/g, ";")) + '"'), t + "=" + e);
function Qt(t, e, s, r = "id") {
  const n = qs(t)[e];
  if (n) {
    if (Array.isArray(n)) {
      const o = n.filter((i) => i.mode === r);
      return o.length > 0 ? o[0][s] : n.length > 0 ? n[0][s] : void 0;
    }
    return n[s];
  }
}
function H(t, e, s = "id") {
  const r = qs(t), n = r[e];
  let o;
  if (S(n) && typeof n.href == "string" ? o = n.href : Array.isArray(n) && (o = Qt(r, e, "href", s)), typeof o != "string") throw new c(c.INVALID_PARAMS, "Missing or invalid link href.");
  return o;
}
function Z(t, e, s, r = "id") {
  const n = H(qs(t), e, r);
  return Ve(n, w(s));
}
const _i = (t, e = 0) => new li().parse(t, e);
function qs(t) {
  return S(t) ? "_links" in t ? t._links : "links" in t ? t.links : t : {};
}
let xt;
const fi = () => {
  if (xt) return xt;
  const t = qt();
  return xt = t && S(globalThis.performance) && q(globalThis.performance.now) ? globalThis.performance : t && S(globalThis.perf_hooks) && S(globalThis.perf_hooks.performance) && q(globalThis.perf_hooks.performance.now) ? globalThis.perf_hooks.performance : Yo() && S(self.performance) && q(self.performance.now) ? self.performance : Date, xt;
}, ie = () => fi().now(), Ei = (t) => Ds(void 0, void 0, void 0, function* () {
  return new Promise((e) => setTimeout(e, t));
});
function fn(t, e, s, r, n) {
  return Ds(this, void 0, void 0, function* () {
    return t().catch((o) => Ds(this, void 0, void 0, function* () {
      var i, a, d;
      if (ie() - s.startTime >= s.timeoutAfter) throw new c(c.TIMED_OUT, "request aborted due to timeout");
      r || (r = (i = o.response) === null || i === void 0 ? void 0 : i.response.type);
      const h = 1e3 * parseInt((a = o.response) === null || a === void 0 ? void 0 : a.headers["retry-after"], 10) || 2e3;
      if (((d = o.response) === null || d === void 0 ? void 0 : d.statusCode) === e && o.response.response.type === r) return yield Ei(h), fn(t, e, s, r);
      throw o;
    }));
  });
}
var Ur, xr, Br, Se, z;
(function(t) {
  t[t.Success = 0] = "Success", t[t.Error = 1] = "Error";
})(Ur || (Ur = {})), function(t) {
  t[t.CompositeXfer = 0] = "CompositeXfer";
}(xr || (xr = {})), function(t) {
  t[t.Push = 0] = "Push", t[t.MinPull = 1] = "MinPull", t[t.VersionPull = 2] = "VersionPull", t[t.Upload = 3] = "Upload", t[t.Download = 4] = "Download", t[t.Create = 5] = "Create", t[t.Unknown = 6] = "Unknown";
}(Br || (Br = {})), function(t) {
  t.PushComposite = "analyticsPush", t.CreateComposite = "analyticsCreate", t.PullComposite = "analyticsPull", t.PullCompositeVersion = "analyticsPullVersion", t.UploadComponent = "analyticsUpload", t.DownloadComponent = "analyticsDownload", t.All = "*";
}(Se || (Se = {})), function(t) {
  t[t.Deprecated = 0] = "Deprecated", t[t.Error = 1] = "Error", t[t.Warn = 2] = "Warn", t[t.Log = 3] = "Log", t[t.Debug = 4] = "Debug";
}(z || (z = {}));
const gi = { [z.Deprecated]: "error", [z.Error]: "error", [z.Log]: "log", [z.Warn]: "warn", [z.Debug]: "debug" };
class de extends $s {
  constructor(e) {
    super([Se.CreateComposite, Se.UploadComponent, Se.PushComposite, Se.PullComposite, Se.PullCompositeVersion, Se.DownloadComponent]), this._logLevel = z.Warn, this._prevDebugTime = ie(), this._debugFormatter = (s, r, n, o) => `[${s} (+${(1e3 * (r - n)).toFixed(0)})] ${o.map((i) => typeof i == "string" ? i : JSON.stringify(i)).join(" ")}`, this._debugNamespaces = [], this._debugSkips = [], this.suppressDeprecationWarnings = !1, e && (this._logCallback = e), this._initNamespaces();
  }
  get debugNamespaces() {
    return this._debugNamespaces;
  }
  get debugSkips() {
    return this._debugSkips;
  }
  set logLevel(e) {
    if (!Object.values(z).includes(e)) throw new Error(`Invalid LogLevel, must be one of: ${Object.values(z).join(", ")}.`);
    this._logLevel = e;
  }
  get logLevel() {
    return this._logLevel;
  }
  on(e, s) {
    if (e !== Se.All) return super.on(e, s);
    const r = Object.values(Se);
    let n;
    for (let o = 0, i = r.length; o < i; o++) {
      const a = r[o];
      n = super.on(a, s);
    }
    return n;
  }
  static getInstance() {
    return de._instance == null && (de._instance = new de()), de._instance;
  }
  static newLogger(e) {
    return new de(e);
  }
  set logCallback(e) {
    this._logCallback = e;
  }
  get logCallback() {
    return this._logCallback;
  }
  _initNamespaces() {
    qt() ? this.setDebugNamespaces(process.env.DCX_DEBUG || "") : S(globalThis) && S(globalThis.dcxjs) && this.setDebugNamespaces(globalThis.dcxjs.debug || ""), this._debugNamespaces.length > 0 && (this._logLevel = z.Debug);
  }
  _log(e, s, r) {
    try {
      if (e === de.LEVEL_DEPRECATED) !this.suppressDeprecationWarnings && this._logLevel >= e && console.warn(...r);
      else if (typeof this._logCallback == "function" && this._logLevel >= e) this._logCallback.call(void 0, ...r);
      else if (this._logLevel >= e) if (e === z.Debug) {
        if (this._debugEnabled(s)) {
          const n = this._prevDebugTime;
          this._prevDebugTime = ie(), (console.debug || console.log)(this._debugFormatter(s, this._prevDebugTime, n, r));
        }
      } else console[gi[e]](...r.slice(0, -2));
    } catch {
    }
  }
  log(...e) {
    this._log(z.Log, void 0, e);
  }
  warn(...e) {
    this._log(z.Warn, void 0, e);
  }
  error(...e) {
    this._log(z.Error, void 0, e);
  }
  deprecated(...e) {
    this._log(z.Deprecated, void 0, e);
  }
  _debugEnabled(e) {
    if (e[e.length - 1] === "*") return !0;
    let s, r;
    for (s = 0, r = this._debugSkips.length; s < r; s++) if (this._debugSkips[s].test(e)) return !1;
    for (s = 0, r = this._debugNamespaces.length; s < r; s++) if (this._debugNamespaces[s].test(e)) return !0;
    return !1;
  }
  setDebugFormatter(e) {
    this._debugFormatter = e;
  }
  setDebugNamespaces(e) {
    let s;
    this._debugNamespaces = [], this._debugSkips = [];
    const r = (typeof e == "string" ? e : "").split(/[\s,]+/), n = r.length;
    for (s = 0; s < n; s++) r[s] && ((e = r[s].replace(/\*/g, ".*?"))[0] === "-" ? this._debugSkips.push(new RegExp("^" + e.substr(1) + "$")) : this._debugNamespaces.push(new RegExp("^" + e + "$")));
  }
  Debug(e) {
    return (...s) => {
      this._log(z.Debug, e, s);
    };
  }
}
de.LEVEL_DEBUG = z.Debug, de.LEVEL_LOG = z.Log, de.LEVEL_WARN = z.Warn, de.LEVEL_ERROR = z.Error, de.LEVEL_DEPRECATED = z.Deprecated;
const zs = () => {
  const t = En();
  return t._logCallback !== void 0 ? t : de.getInstance();
}, En = () => {
  if (typeof globalThis == "object" && typeof globalThis.dcxjs == "object" && globalThis.dcxjs.logger && globalThis.dcxjs.logger.getInstance) return globalThis.dcxjs.logger.getInstance();
  const t = () => {
  };
  return { log: t, warn: t, error: t, deprecated: t, debug: t, newLogger: En };
}, jr = (...t) => {
  const e = zs();
  t.forEach(e.log.bind(e));
}, x = (t) => zs().Debug(t);
zs();
const Vr = (t) => toString.call(t) === "[object Function]";
let Ii = class {
  constructor(e, s) {
    return this._promise = null, this._props = {}, this._registeredProps = [], this._handlers = { cancel: [] }, this._done = !1, this._canceled = !1, this._internalKeys = [], this.name = "AdobePromise", this._internalKeys = [...Object.keys(this), ...Object.keys(Object.getOwnPropertyDescriptors(Object.getPrototypeOf(this))), "_cancelReason"], s && typeof s == "object" && this._setProps(s), this._promise = new Promise((r, n) => e.call(this, (o) => {
      this._done || (this._done = !0, r(o));
    }, (o) => {
      this._done || (this._done = !0, n(o));
    }, this._registerCancelHandler.bind(this))), new Proxy(this, { set: function(r, n, o) {
      if (r._internalKeys.includes(n)) {
        if (!["_promise", "_canceled", "_cancelReason", "_props", "_registeredProps"].includes(n)) throw new Error("Cannot overwrite internal AdobePromise property.");
        r[n] = o;
      } else r._registeredProps.includes(n) || r._registeredProps.push(n), r.props[n] = o;
      return !0;
    }, get: function(r, n) {
      return typeof n == "symbol" || r._internalKeys.includes(n) ? r[n] : r.props[n];
    } });
  }
  get [Symbol.toStringTag]() {
    return this.name;
  }
  static reject(e, s) {
    return new C((r, n) => Promise.reject(e).catch((o) => {
      n && n(o);
    }), s);
  }
  static resolve(e, s) {
    return new C((r) => {
      S(e) && Vr(e.then) ? e.then((n) => {
        r(n);
      }) : r(e);
    }, s);
  }
  static allSettled(e, s) {
    return e.length === 0 ? C.resolve([], s) : new C((r) => {
      const n = [];
      e.map((o, i) => {
        o.then((a) => {
          n[i] = { status: "fulfilled", value: a };
        }).catch((a) => {
          n[i] = { status: "rejected", reason: a };
        }).then(() => {
          n.filter((a) => !!a).length === e.length && r(n);
        });
      });
    }, s);
  }
  get canceled() {
    return this._canceled;
  }
  getPromise() {
    return this._promise;
  }
  _resolveOrReject(e, s) {
    return this._promise.then((r) => this._canceled ? s && s(this._cancelReason) : e(r)).catch((r) => s && s(this._cancelReason || r));
  }
  then(e, s) {
    if (e == null && s == null) return this;
    const r = new C((n, o, i) => (i && i((a) => {
      this.cancel.call(this, a), o && o(a);
    }), this._resolveOrReject.call(this, n, o)), this._props);
    return r._promise = r.getPromise().then((n) => {
      const o = e && e(n);
      if (o instanceof C) {
        const i = o;
        this.onCancel((a) => i.cancel(a));
        for (const a in this.props) i.props[a] == null && (i.props[a] = this.props[a]);
        i._setProps(i.props), this._setProps(i.props), r._setProps(i.props);
      }
      return o;
    }).catch(s), r;
  }
  parallel(e, s) {
    return this._promise.then(e, s);
  }
  catch(e) {
    return this._promise = this._promise.catch(e), this;
  }
  finally(e) {
    return this._promise = this._promise.finally(e), this;
  }
  cancel(e) {
    this._canceled || (this._canceled = !0, this._cancelReason = e, this._callHandlers("cancel", e || new Error("Aborted")));
  }
  abort(e) {
    this.cancel(e);
  }
  onCancel(e) {
    Vr(e) && this._registerCancelHandler(e);
  }
  get props() {
    return this._props;
  }
  _setProps(e) {
    if (this._props === e) return;
    this._props = e;
    const s = [], r = Object.getOwnPropertyDescriptors(C), n = Object.getOwnPropertyDescriptors(Object.getPrototypeOf(e));
    if (n.constructor.value !== Object) for (const o in n) {
      if (o in r || o in this && !this._registeredProps.includes(o)) continue;
      s.push(o);
      const i = n[o], a = Object.assign({}, i);
      delete a.get, delete a.set, (i.get || i.set) && (delete a.value, delete a.writable, i.get && (a.get = i.get.bind(e)), i.set && (a.set = i.set.bind(e))), Object.defineProperty(this, o, a);
    }
    for (const o of Object.keys(e)) s.push(o), o in r || o in this && !this._registeredProps.includes(o) || Object.defineProperty(this, o, { get: () => this._props[o], set: (i) => {
      this._props[o] = i;
    }, configurable: !0 });
    return this._registeredProps = s, this;
  }
  _registerCancelHandler(e) {
    this._handlers.cancel.push(e);
  }
  _callHandlers(e, s) {
    this._handlers[e].map((r) => r && r(s));
  }
  _destroy() {
    this._handlers.cancel = [];
  }
};
const C = Ii;
var Ti = typeof globalThis == "object" ? globalThis : typeof self == "object" ? self : typeof window == "object" ? window : typeof globalThis == "object" ? globalThis : {}, Ze = "1.9.0", Fr = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
function Ai(t) {
  var e = /* @__PURE__ */ new Set([t]), s = /* @__PURE__ */ new Set(), r = t.match(Fr);
  if (!r)
    return function() {
      return !1;
    };
  var n = {
    major: +r[1],
    minor: +r[2],
    patch: +r[3],
    prerelease: r[4]
  };
  if (n.prerelease != null)
    return function(d) {
      return d === t;
    };
  function o(a) {
    return s.add(a), !1;
  }
  function i(a) {
    return e.add(a), !0;
  }
  return function(d) {
    if (e.has(d))
      return !0;
    if (s.has(d))
      return !1;
    var h = d.match(Fr);
    if (!h)
      return o(d);
    var l = {
      major: +h[1],
      minor: +h[2],
      patch: +h[3],
      prerelease: h[4]
    };
    return l.prerelease != null || n.major !== l.major ? o(d) : n.major === 0 ? n.minor === l.minor && n.patch <= l.patch ? i(d) : o(d) : n.minor <= l.minor ? i(d) : o(d);
  };
}
var mi = Ai(Ze), yi = Ze.split(".")[0], Pt = Symbol.for("opentelemetry.js.api." + yi), St = Ti;
function Ct(t, e, s, r) {
  var n;
  r === void 0 && (r = !1);
  var o = St[Pt] = (n = St[Pt]) !== null && n !== void 0 ? n : {
    version: Ze
  };
  if (!r && o[t]) {
    var i = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + t);
    return s.error(i.stack || i.message), !1;
  }
  if (o.version !== Ze) {
    var i = new Error("@opentelemetry/api: Registration of version v" + o.version + " for " + t + " does not match previously registered API v" + Ze);
    return s.error(i.stack || i.message), !1;
  }
  return o[t] = e, s.debug("@opentelemetry/api: Registered a global for " + t + " v" + Ze + "."), !0;
}
function Qe(t) {
  var e, s, r = (e = St[Pt]) === null || e === void 0 ? void 0 : e.version;
  if (!(!r || !mi(r)))
    return (s = St[Pt]) === null || s === void 0 ? void 0 : s[t];
}
function Nt(t, e) {
  e.debug("@opentelemetry/api: Unregistering a global for " + t + " v" + Ze + ".");
  var s = St[Pt];
  s && delete s[t];
}
var vi = function(t, e) {
  var s = typeof Symbol == "function" && t[Symbol.iterator];
  if (!s) return t;
  var r = s.call(t), n, o = [], i;
  try {
    for (; (e === void 0 || e-- > 0) && !(n = r.next()).done; ) o.push(n.value);
  } catch (a) {
    i = { error: a };
  } finally {
    try {
      n && !n.done && (s = r.return) && s.call(r);
    } finally {
      if (i) throw i.error;
    }
  }
  return o;
}, bi = function(t, e, s) {
  if (arguments.length === 2) for (var r = 0, n = e.length, o; r < n; r++)
    (o || !(r in e)) && (o || (o = Array.prototype.slice.call(e, 0, r)), o[r] = e[r]);
  return t.concat(o || Array.prototype.slice.call(e));
}, Ri = (
  /** @class */
  function() {
    function t(e) {
      this._namespace = e.namespace || "DiagComponentLogger";
    }
    return t.prototype.debug = function() {
      for (var e = [], s = 0; s < arguments.length; s++)
        e[s] = arguments[s];
      return _t("debug", this._namespace, e);
    }, t.prototype.error = function() {
      for (var e = [], s = 0; s < arguments.length; s++)
        e[s] = arguments[s];
      return _t("error", this._namespace, e);
    }, t.prototype.info = function() {
      for (var e = [], s = 0; s < arguments.length; s++)
        e[s] = arguments[s];
      return _t("info", this._namespace, e);
    }, t.prototype.warn = function() {
      for (var e = [], s = 0; s < arguments.length; s++)
        e[s] = arguments[s];
      return _t("warn", this._namespace, e);
    }, t.prototype.verbose = function() {
      for (var e = [], s = 0; s < arguments.length; s++)
        e[s] = arguments[s];
      return _t("verbose", this._namespace, e);
    }, t;
  }()
);
function _t(t, e, s) {
  var r = Qe("diag");
  if (r)
    return s.unshift(e), r[t].apply(r, bi([], vi(s), !1));
}
var ge;
(function(t) {
  t[t.NONE = 0] = "NONE", t[t.ERROR = 30] = "ERROR", t[t.WARN = 50] = "WARN", t[t.INFO = 60] = "INFO", t[t.DEBUG = 70] = "DEBUG", t[t.VERBOSE = 80] = "VERBOSE", t[t.ALL = 9999] = "ALL";
})(ge || (ge = {}));
function Oi(t, e) {
  t < ge.NONE ? t = ge.NONE : t > ge.ALL && (t = ge.ALL), e = e || {};
  function s(r, n) {
    var o = e[r];
    return typeof o == "function" && t >= n ? o.bind(e) : function() {
    };
  }
  return {
    error: s("error", ge.ERROR),
    warn: s("warn", ge.WARN),
    info: s("info", ge.INFO),
    debug: s("debug", ge.DEBUG),
    verbose: s("verbose", ge.VERBOSE)
  };
}
var Pi = function(t, e) {
  var s = typeof Symbol == "function" && t[Symbol.iterator];
  if (!s) return t;
  var r = s.call(t), n, o = [], i;
  try {
    for (; (e === void 0 || e-- > 0) && !(n = r.next()).done; ) o.push(n.value);
  } catch (a) {
    i = { error: a };
  } finally {
    try {
      n && !n.done && (s = r.return) && s.call(r);
    } finally {
      if (i) throw i.error;
    }
  }
  return o;
}, Si = function(t, e, s) {
  if (arguments.length === 2) for (var r = 0, n = e.length, o; r < n; r++)
    (o || !(r in e)) && (o || (o = Array.prototype.slice.call(e, 0, r)), o[r] = e[r]);
  return t.concat(o || Array.prototype.slice.call(e));
}, Ci = "diag", Ce = (
  /** @class */
  function() {
    function t() {
      function e(n) {
        return function() {
          for (var o = [], i = 0; i < arguments.length; i++)
            o[i] = arguments[i];
          var a = Qe("diag");
          if (a)
            return a[n].apply(a, Si([], Pi(o), !1));
        };
      }
      var s = this, r = function(n, o) {
        var i, a, d;
        if (o === void 0 && (o = { logLevel: ge.INFO }), n === s) {
          var h = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
          return s.error((i = h.stack) !== null && i !== void 0 ? i : h.message), !1;
        }
        typeof o == "number" && (o = {
          logLevel: o
        });
        var l = Qe("diag"), p = Oi((a = o.logLevel) !== null && a !== void 0 ? a : ge.INFO, n);
        if (l && !o.suppressOverrideMessage) {
          var _ = (d = new Error().stack) !== null && d !== void 0 ? d : "<failed to generate stacktrace>";
          l.warn("Current logger will be overwritten from " + _), p.warn("Current logger will overwrite one already registered from " + _);
        }
        return Ct("diag", p, s, !0);
      };
      s.setLogger = r, s.disable = function() {
        Nt(Ci, s);
      }, s.createComponentLogger = function(n) {
        return new Ri(n);
      }, s.verbose = e("verbose"), s.debug = e("debug"), s.info = e("info"), s.warn = e("warn"), s.error = e("error");
    }
    return t.instance = function() {
      return this._instance || (this._instance = new t()), this._instance;
    }, t;
  }()
), Ni = function(t, e) {
  var s = typeof Symbol == "function" && t[Symbol.iterator];
  if (!s) return t;
  var r = s.call(t), n, o = [], i;
  try {
    for (; (e === void 0 || e-- > 0) && !(n = r.next()).done; ) o.push(n.value);
  } catch (a) {
    i = { error: a };
  } finally {
    try {
      n && !n.done && (s = r.return) && s.call(r);
    } finally {
      if (i) throw i.error;
    }
  }
  return o;
}, Di = function(t) {
  var e = typeof Symbol == "function" && Symbol.iterator, s = e && t[e], r = 0;
  if (s) return s.call(t);
  if (t && typeof t.length == "number") return {
    next: function() {
      return t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t };
    }
  };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, ki = (
  /** @class */
  function() {
    function t(e) {
      this._entries = e ? new Map(e) : /* @__PURE__ */ new Map();
    }
    return t.prototype.getEntry = function(e) {
      var s = this._entries.get(e);
      if (s)
        return Object.assign({}, s);
    }, t.prototype.getAllEntries = function() {
      return Array.from(this._entries.entries()).map(function(e) {
        var s = Ni(e, 2), r = s[0], n = s[1];
        return [r, n];
      });
    }, t.prototype.setEntry = function(e, s) {
      var r = new t(this._entries);
      return r._entries.set(e, s), r;
    }, t.prototype.removeEntry = function(e) {
      var s = new t(this._entries);
      return s._entries.delete(e), s;
    }, t.prototype.removeEntries = function() {
      for (var e, s, r = [], n = 0; n < arguments.length; n++)
        r[n] = arguments[n];
      var o = new t(this._entries);
      try {
        for (var i = Di(r), a = i.next(); !a.done; a = i.next()) {
          var d = a.value;
          o._entries.delete(d);
        }
      } catch (h) {
        e = { error: h };
      } finally {
        try {
          a && !a.done && (s = i.return) && s.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return o;
    }, t.prototype.clear = function() {
      return new t();
    }, t;
  }()
);
Ce.instance();
function Li(t) {
  return t === void 0 && (t = {}), new ki(new Map(Object.entries(t)));
}
function gn(t) {
  return Symbol.for(t);
}
var wi = (
  /** @class */
  /* @__PURE__ */ function() {
    function t(e) {
      var s = this;
      s._currentContext = e ? new Map(e) : /* @__PURE__ */ new Map(), s.getValue = function(r) {
        return s._currentContext.get(r);
      }, s.setValue = function(r, n) {
        var o = new t(s._currentContext);
        return o._currentContext.set(r, n), o;
      }, s.deleteValue = function(r) {
        var n = new t(s._currentContext);
        return n._currentContext.delete(r), n;
      };
    }
    return t;
  }()
), Mi = new wi(), tt = /* @__PURE__ */ function() {
  var t = function(e, s) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, n) {
      r.__proto__ = n;
    } || function(r, n) {
      for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (r[o] = n[o]);
    }, t(e, s);
  };
  return function(e, s) {
    if (typeof s != "function" && s !== null)
      throw new TypeError("Class extends value " + String(s) + " is not a constructor or null");
    t(e, s);
    function r() {
      this.constructor = e;
    }
    e.prototype = s === null ? Object.create(s) : (r.prototype = s.prototype, new r());
  };
}(), Ui = (
  /** @class */
  function() {
    function t() {
    }
    return t.prototype.createGauge = function(e, s) {
      return qi;
    }, t.prototype.createHistogram = function(e, s) {
      return zi;
    }, t.prototype.createCounter = function(e, s) {
      return Yi;
    }, t.prototype.createUpDownCounter = function(e, s) {
      return Wi;
    }, t.prototype.createObservableGauge = function(e, s) {
      return Xi;
    }, t.prototype.createObservableCounter = function(e, s) {
      return Ki;
    }, t.prototype.createObservableUpDownCounter = function(e, s) {
      return Zi;
    }, t.prototype.addBatchObservableCallback = function(e, s) {
    }, t.prototype.removeBatchObservableCallback = function(e) {
    }, t;
  }()
), es = (
  /** @class */
  /* @__PURE__ */ function() {
    function t() {
    }
    return t;
  }()
), xi = (
  /** @class */
  function(t) {
    tt(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e.prototype.add = function(s, r) {
    }, e;
  }(es)
), Bi = (
  /** @class */
  function(t) {
    tt(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e.prototype.add = function(s, r) {
    }, e;
  }(es)
), ji = (
  /** @class */
  function(t) {
    tt(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e.prototype.record = function(s, r) {
    }, e;
  }(es)
), Vi = (
  /** @class */
  function(t) {
    tt(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e.prototype.record = function(s, r) {
    }, e;
  }(es)
), Ws = (
  /** @class */
  function() {
    function t() {
    }
    return t.prototype.addCallback = function(e) {
    }, t.prototype.removeCallback = function(e) {
    }, t;
  }()
), Fi = (
  /** @class */
  function(t) {
    tt(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e;
  }(Ws)
), Hi = (
  /** @class */
  function(t) {
    tt(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e;
  }(Ws)
), Gi = (
  /** @class */
  function(t) {
    tt(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e;
  }(Ws)
), $i = new Ui(), Yi = new xi(), qi = new ji(), zi = new Vi(), Wi = new Bi(), Ki = new Fi(), Xi = new Hi(), Zi = new Gi(), Ji = {
  get: function(t, e) {
    if (t != null)
      return t[e];
  },
  keys: function(t) {
    return t == null ? [] : Object.keys(t);
  }
}, Qi = {
  set: function(t, e, s) {
    t != null && (t[e] = s);
  }
}, ea = function(t, e) {
  var s = typeof Symbol == "function" && t[Symbol.iterator];
  if (!s) return t;
  var r = s.call(t), n, o = [], i;
  try {
    for (; (e === void 0 || e-- > 0) && !(n = r.next()).done; ) o.push(n.value);
  } catch (a) {
    i = { error: a };
  } finally {
    try {
      n && !n.done && (s = r.return) && s.call(r);
    } finally {
      if (i) throw i.error;
    }
  }
  return o;
}, ta = function(t, e, s) {
  if (s || arguments.length === 2) for (var r = 0, n = e.length, o; r < n; r++)
    (o || !(r in e)) && (o || (o = Array.prototype.slice.call(e, 0, r)), o[r] = e[r]);
  return t.concat(o || Array.prototype.slice.call(e));
}, sa = (
  /** @class */
  function() {
    function t() {
    }
    return t.prototype.active = function() {
      return Mi;
    }, t.prototype.with = function(e, s, r) {
      for (var n = [], o = 3; o < arguments.length; o++)
        n[o - 3] = arguments[o];
      return s.call.apply(s, ta([r], ea(n), !1));
    }, t.prototype.bind = function(e, s) {
      return s;
    }, t.prototype.enable = function() {
      return this;
    }, t.prototype.disable = function() {
      return this;
    }, t;
  }()
), ra = function(t, e) {
  var s = typeof Symbol == "function" && t[Symbol.iterator];
  if (!s) return t;
  var r = s.call(t), n, o = [], i;
  try {
    for (; (e === void 0 || e-- > 0) && !(n = r.next()).done; ) o.push(n.value);
  } catch (a) {
    i = { error: a };
  } finally {
    try {
      n && !n.done && (s = r.return) && s.call(r);
    } finally {
      if (i) throw i.error;
    }
  }
  return o;
}, na = function(t, e, s) {
  if (arguments.length === 2) for (var r = 0, n = e.length, o; r < n; r++)
    (o || !(r in e)) && (o || (o = Array.prototype.slice.call(e, 0, r)), o[r] = e[r]);
  return t.concat(o || Array.prototype.slice.call(e));
}, Es = "context", oa = new sa(), ts = (
  /** @class */
  function() {
    function t() {
    }
    return t.getInstance = function() {
      return this._instance || (this._instance = new t()), this._instance;
    }, t.prototype.setGlobalContextManager = function(e) {
      return Ct(Es, e, Ce.instance());
    }, t.prototype.active = function() {
      return this._getContextManager().active();
    }, t.prototype.with = function(e, s, r) {
      for (var n, o = [], i = 3; i < arguments.length; i++)
        o[i - 3] = arguments[i];
      return (n = this._getContextManager()).with.apply(n, na([e, s, r], ra(o), !1));
    }, t.prototype.bind = function(e, s) {
      return this._getContextManager().bind(e, s);
    }, t.prototype._getContextManager = function() {
      return Qe(Es) || oa;
    }, t.prototype.disable = function() {
      this._getContextManager().disable(), Nt(Es, Ce.instance());
    }, t;
  }()
), Ls;
(function(t) {
  t[t.NONE = 0] = "NONE", t[t.SAMPLED = 1] = "SAMPLED";
})(Ls || (Ls = {}));
var In = "0000000000000000", Tn = "00000000000000000000000000000000", ia = {
  traceId: Tn,
  spanId: In,
  traceFlags: Ls.NONE
}, At = (
  /** @class */
  function() {
    function t(e) {
      e === void 0 && (e = ia), this._spanContext = e;
    }
    return t.prototype.spanContext = function() {
      return this._spanContext;
    }, t.prototype.setAttribute = function(e, s) {
      return this;
    }, t.prototype.setAttributes = function(e) {
      return this;
    }, t.prototype.addEvent = function(e, s) {
      return this;
    }, t.prototype.addLink = function(e) {
      return this;
    }, t.prototype.addLinks = function(e) {
      return this;
    }, t.prototype.setStatus = function(e) {
      return this;
    }, t.prototype.updateName = function(e) {
      return this;
    }, t.prototype.end = function(e) {
    }, t.prototype.isRecording = function() {
      return !1;
    }, t.prototype.recordException = function(e, s) {
    }, t;
  }()
), Ks = gn("OpenTelemetry Context Key SPAN");
function Xs(t) {
  return t.getValue(Ks) || void 0;
}
function aa() {
  return Xs(ts.getInstance().active());
}
function Zs(t, e) {
  return t.setValue(Ks, e);
}
function ca(t) {
  return t.deleteValue(Ks);
}
function da(t, e) {
  return Zs(t, new At(e));
}
function An(t) {
  var e;
  return (e = Xs(t)) === null || e === void 0 ? void 0 : e.spanContext();
}
var ha = /^([0-9a-f]{32})$/i, la = /^[0-9a-f]{16}$/i;
function ua(t) {
  return ha.test(t) && t !== Tn;
}
function pa(t) {
  return la.test(t) && t !== In;
}
function mn(t) {
  return ua(t.traceId) && pa(t.spanId);
}
function _a(t) {
  return new At(t);
}
var gs = ts.getInstance(), yn = (
  /** @class */
  function() {
    function t() {
    }
    return t.prototype.startSpan = function(e, s, r) {
      r === void 0 && (r = gs.active());
      var n = !!(s != null && s.root);
      if (n)
        return new At();
      var o = r && An(r);
      return fa(o) && mn(o) ? new At(o) : new At();
    }, t.prototype.startActiveSpan = function(e, s, r, n) {
      var o, i, a;
      if (!(arguments.length < 2)) {
        arguments.length === 2 ? a = s : arguments.length === 3 ? (o = s, a = r) : (o = s, i = r, a = n);
        var d = i ?? gs.active(), h = this.startSpan(e, o, d), l = Zs(d, h);
        return gs.with(l, a, void 0, h);
      }
    }, t;
  }()
);
function fa(t) {
  return typeof t == "object" && typeof t.spanId == "string" && typeof t.traceId == "string" && typeof t.traceFlags == "number";
}
var Ea = new yn(), ga = (
  /** @class */
  function() {
    function t(e, s, r, n) {
      this._provider = e, this.name = s, this.version = r, this.options = n;
    }
    return t.prototype.startSpan = function(e, s, r) {
      return this._getTracer().startSpan(e, s, r);
    }, t.prototype.startActiveSpan = function(e, s, r, n) {
      var o = this._getTracer();
      return Reflect.apply(o.startActiveSpan, o, arguments);
    }, t.prototype._getTracer = function() {
      if (this._delegate)
        return this._delegate;
      var e = this._provider.getDelegateTracer(this.name, this.version, this.options);
      return e ? (this._delegate = e, this._delegate) : Ea;
    }, t;
  }()
), Ia = (
  /** @class */
  function() {
    function t() {
    }
    return t.prototype.getTracer = function(e, s, r) {
      return new yn();
    }, t;
  }()
), Ta = new Ia(), Hr = (
  /** @class */
  function() {
    function t() {
    }
    return t.prototype.getTracer = function(e, s, r) {
      var n;
      return (n = this.getDelegateTracer(e, s, r)) !== null && n !== void 0 ? n : new ga(this, e, s, r);
    }, t.prototype.getDelegate = function() {
      var e;
      return (e = this._delegate) !== null && e !== void 0 ? e : Ta;
    }, t.prototype.setDelegate = function(e) {
      this._delegate = e;
    }, t.prototype.getDelegateTracer = function(e, s, r) {
      var n;
      return (n = this._delegate) === null || n === void 0 ? void 0 : n.getTracer(e, s, r);
    }, t;
  }()
), mt;
(function(t) {
  t[t.UNSET = 0] = "UNSET", t[t.OK = 1] = "OK", t[t.ERROR = 2] = "ERROR";
})(mt || (mt = {}));
var Aa = ts.getInstance(), ma = Ce.instance(), ya = (
  /** @class */
  function() {
    function t() {
    }
    return t.prototype.getMeter = function(e, s, r) {
      return $i;
    }, t;
  }()
), va = new ya(), Is = "metrics", ba = (
  /** @class */
  function() {
    function t() {
    }
    return t.getInstance = function() {
      return this._instance || (this._instance = new t()), this._instance;
    }, t.prototype.setGlobalMeterProvider = function(e) {
      return Ct(Is, e, Ce.instance());
    }, t.prototype.getMeterProvider = function() {
      return Qe(Is) || va;
    }, t.prototype.getMeter = function(e, s, r) {
      return this.getMeterProvider().getMeter(e, s, r);
    }, t.prototype.disable = function() {
      Nt(Is, Ce.instance());
    }, t;
  }()
), Ra = ba.getInstance(), Oa = (
  /** @class */
  function() {
    function t() {
    }
    return t.prototype.inject = function(e, s) {
    }, t.prototype.extract = function(e, s) {
      return e;
    }, t.prototype.fields = function() {
      return [];
    }, t;
  }()
), Js = gn("OpenTelemetry Baggage Key");
function vn(t) {
  return t.getValue(Js) || void 0;
}
function Pa() {
  return vn(ts.getInstance().active());
}
function Sa(t, e) {
  return t.setValue(Js, e);
}
function Ca(t) {
  return t.deleteValue(Js);
}
var Ts = "propagation", Na = new Oa(), Da = (
  /** @class */
  function() {
    function t() {
      this.createBaggage = Li, this.getBaggage = vn, this.getActiveBaggage = Pa, this.setBaggage = Sa, this.deleteBaggage = Ca;
    }
    return t.getInstance = function() {
      return this._instance || (this._instance = new t()), this._instance;
    }, t.prototype.setGlobalPropagator = function(e) {
      return Ct(Ts, e, Ce.instance());
    }, t.prototype.inject = function(e, s, r) {
      return r === void 0 && (r = Qi), this._getGlobalPropagator().inject(e, s, r);
    }, t.prototype.extract = function(e, s, r) {
      return r === void 0 && (r = Ji), this._getGlobalPropagator().extract(e, s, r);
    }, t.prototype.fields = function() {
      return this._getGlobalPropagator().fields();
    }, t.prototype.disable = function() {
      Nt(Ts, Ce.instance());
    }, t.prototype._getGlobalPropagator = function() {
      return Qe(Ts) || Na;
    }, t;
  }()
), ka = Da.getInstance(), As = "trace", La = (
  /** @class */
  function() {
    function t() {
      this._proxyTracerProvider = new Hr(), this.wrapSpanContext = _a, this.isSpanContextValid = mn, this.deleteSpan = ca, this.getSpan = Xs, this.getActiveSpan = aa, this.getSpanContext = An, this.setSpan = Zs, this.setSpanContext = da;
    }
    return t.getInstance = function() {
      return this._instance || (this._instance = new t()), this._instance;
    }, t.prototype.setGlobalTracerProvider = function(e) {
      var s = Ct(As, this._proxyTracerProvider, Ce.instance());
      return s && this._proxyTracerProvider.setDelegate(e), s;
    }, t.prototype.getTracerProvider = function() {
      return Qe(As) || this._proxyTracerProvider;
    }, t.prototype.getTracer = function(e, s) {
      return this.getTracerProvider().getTracer(e, s);
    }, t.prototype.disable = function() {
      Nt(As, Ce.instance()), this._proxyTracerProvider = new Hr();
    }, t;
  }()
), wa = La.getInstance();
const It = {
  context: Aa,
  diag: ma,
  metrics: Ra,
  propagation: ka,
  trace: wa
}, Ma = "9.10.0";
function Ua(t) {
  return function(e) {
    e.traceableAs = () => t;
  };
}
function ss(t, e, s) {
  const r = function(...n) {
    const o = It.trace.getTracer("dcx-js", Ma).startSpan(t), i = It.trace.setSpan(It.context.active(), o);
    try {
      const a = It.context.with(i, () => e.apply(this, n));
      return o.setStatus({ code: mt.OK }), a && a instanceof Promise ? a.catch((d) => {
        throw d instanceof Error && (o.recordException(d), o.setStatus({ code: mt.ERROR, message: d.message })), d;
      }).finally(() => {
        o.end();
      }) : (o.end(), a);
    } catch (a) {
      throw a instanceof Error && (o.recordException(a), o.setStatus({ code: mt.ERROR, message: a.message })), o.end(), a;
    }
  };
  return Object.defineProperties(r, { name: { value: e.name }, length: { value: e.length } }), r;
}
function ft(t, e, s) {
  var r;
  let n;
  q(t) && (!((r = t.prototype) === null || r === void 0) && r.constructor) ? n = t.prototype.constructor : typeof t == "object" && t.constructor && (n = t.constructor);
  const o = s.value;
  return s.value = function(...i) {
    let a = e;
    if (n) {
      let d;
      d = q(n.traceableAs) ? n.traceableAs() : n.name, a = d + "." + a;
    }
    return ss(a, o).apply(this, i);
  }, s;
}
function pe(t, e) {
  var s;
  (s = It.trace.getActiveSpan()) === null || s === void 0 || s.setAttribute(t, e || "");
}
const u = { ACCESS_CHECK: "http://ns.adobe.com/adobecloud/rel/ac/check", ACL_POLICY: "http://ns.adobe.com/adobecloud/rel/ac/policy", ANNOTATIONS: "http://ns.adobe.com/adobecloud/rel/annotations", APP_METADATA: "http://ns.adobe.com/adobecloud/rel/metadata/application", BASE_DIRECTORY: "http://ns.adobe.com/adobecloud/rel/directory/base", BLOCK_DOWNLOAD: "http://ns.adobe.com/adobecloud/rel/download", BLOCK_EXTEND: "http://ns.adobe.com/adobecloud/rel/block/extend", BLOCK_FINALIZE: "http://ns.adobe.com/adobecloud/rel/block/finalize", BLOCK_TRANSFER: "http://ns.adobe.com/adobecloud/rel/block/transfer", BLOCK_UPLOAD_INIT: "http://ns.adobe.com/adobecloud/rel/block/init", BULK_REQUEST: "http://ns.adobe.com/adobecloud/rel/bulk", COMPONENT: "http://ns.adobe.com/adobecloud/rel/component", CREATE: "http://ns.adobe.com/adobecloud/rel/create", DESCRIBED_BY: "describedBy", DIRECTORY: "http://ns.adobe.com/adobecloud/rel/directory", DISCARD: "http://ns.adobe.com/adobecloud/rel/discard", EFFECTIVE_PRIVILAGES: "http://ns.adobe.com/adobecloud/rel/ac/effective", EMBEDDED_METADATA: "http://ns.adobe.com/adobecloud/rel/metadata/embedded", ID: "http://ns.adobe.com/adobecloud/rel/id", MANIFEST: "http://ns.adobe.com/adobecloud/rel/manifest", PAGE: "http://ns.adobe.com/adobecloud/rel/page", PATH: "http://ns.adobe.com/adobecloud/rel/path", PRIMARY: "http://ns.adobe.com/adobecloud/rel/primary", RENDITION: "http://ns.adobe.com/adobecloud/rel/rendition", REPO_METADATA: "http://ns.adobe.com/adobecloud/rel/metadata/repository", REPO_OPS: "http://ns.adobe.com/adobecloud/rel/ops", REPOSITORY: "http://ns.adobe.com/adobecloud/rel/repository", RESOLVE_BY_ID: "http://ns.adobe.com/adobecloud/rel/resolve/id", RESOLVE_BY_PATH: "http://ns.adobe.com/adobecloud/rel/resolve/path", RESTORE: "http://ns.adobe.com/adobecloud/rel/restore", VERSION_HISTORY: "version-history" };
var T, Me, Gr, $r, Yr, Xt, B, yt;
function xa(t) {
  return S(t) && ["headers", "responseType", "statusCode", "xhr"].every((e) => e in t);
}
function Ba(t) {
  return S(t) && xa(t.response);
}
function bn(t) {
  return S(t) && Ba(t) && "result" in t;
}
function Rn(t) {
  return S(t) && q(t.slice);
}
function ws(t) {
  return S(t) && "resolvePullWithBranch" in t;
}
function qr(t) {
  return S(t) && (["compositeId", "compositeAssetId", "compositeRepositoryId"].some((e) => e in t) || S(t._core));
}
function Zt(t) {
  return S(t) && (S(t.links) || typeof t.repositoryId == "string" && (typeof t.path == "string" || typeof t.assetId == "string"));
}
function ja(t) {
  return typeof Blob < "u" && t instanceof Blob;
}
function Qs(t) {
  return S(t) && (typeof t.repositoryId == "string" && typeof t.path == "string" || typeof t.assetId == "string");
}
function Va(t) {
  return S(t) && (t.name === "AdobeHTTPService" || q(t.invoke));
}
function er(t) {
  return S(t) && Va(t.service);
}
function Fa(t) {
  if (!S(t)) return !1;
  const e = t[T.LINKS];
  return S(e) ? !!(e[u.BLOCK_TRANSFER] && e[u.BLOCK_EXTEND] && e[u.BLOCK_FINALIZE]) : !1;
}
function On(t) {
  return (e) => {
    const s = {};
    for (const r in e) s[r.toLowerCase()] = e[r];
    for (const r of t) s.hasOwnProperty(r.toLowerCase()) && delete s[r.toLowerCase()];
    return s;
  };
}
(function(t) {
  t.DC_FORMAT = "dc:format", t.DC_TITLE = "dc:title", t.LINKS = "_links", t.PAGE = "_page", t.CHILDREN = "children", t.EMBEDDED = "_embedded", t.REPO_REPRESENTATIONS = "repo:representations", t.REPO_ASSET_ID = "repo:assetId", t.REPO_REPOSITORY_ID = "repo:repositoryId", t.REPO_REPOSITORY_TYPE = "repo:repositoryType", t.REPO_BASE_ASSET_ID = "repo:baseAssetId", t.REPO_SIZE = "repo:size", t.REPO_NAME = "repo:name", t.REPO_PATH = "repo:path", t.REPO_ASSET_CLASS = "repo:assetClass", t.REPO_CREATE_DATE = "repo:createDate", t.REPO_MODIFY_DATE = "repo:modifyDate", t.REPO_DISCARD_DATE = "repo:discardDate", t.REPO_ETAG = "repo:etag", t.REPO_CREATED_BY = "repo:createdBy", t.REPO_MODIFIED_BY = "repo:modifiedBy", t.REPO_DISCARDED_BY = "repo:discardedBy", t.REPO_DEVICE_CREATE_DATE = "storage:deviceCreateDate", t.REPO_DEVICE_MODIFY_DATE = "storage:deviceModifyDate", t.REPO_DEFAULT_SCHEDULED_DELETION_DURATION = "repo:defaultScheduledDeletionDuration", t.REPO_ASSET_TYPE = "repo:assetType", t.REPO_ASSET_SUB_TYPE = "repo:assetSubType", t.STORAGE_LES = "storage:les", t.REPO_SCHEDULED_DELETION_DATE = "repo:scheduledDeletionDate", t.REPO_VERSION = "repo:version", t.REPO_STATE = "repo:state", t.REPO_AVAILABLE_REGIONS = "repo:availableRegions", t.REPO_REGIONS = "repo:regions", t.REPO_OWNER = "repo:owner", t.REPO_OWNER_ID = "id", t.REPO_OWNER_TYPE = "type", t.REPO_CONTRIBUTORS = "repo:contributors", t.REPO_MODIFIED_BY_CLIENT_ID = "repo:modifiedByClientId", t.REPO_MODIFIED_BY_CLIENT_AGENT = "repo:modifiedByClientAgent", t.REPO_MODIFIED_BY_IP_ADDRESS = "repo:modifiedByIpAddress", t.STORAGE_ASSIGNEE = "storage:assignee", t.STORAGE_ASSIGNEE_ID = "id", t.STORAGE_ASSIGNEE_TYPE = "type", t.IMAGE_LENGTH = "tiff:imageLength", t.IMAGE_WIDTH = "tiff:imageWidth", t.NUM_OF_PAGES = "xmpTPg:NPages", t.PAGE_START = "start", t.PAGE_ORDER_BY = "orderBy", t.PAGE_NEXT = "next", t.PAGE_COUNT = "count", t.PAGE_LIMIT = "limit";
})(T || (T = {})), function(t) {
  t.REPO_ID = "repo:id", t.CREATED = "created", t.CREATED_BY = "created_by", t.MILESTONE = "milestone", t.VERSION = "version", t.TOTAL_CHILDREN = "total_children";
}(Me || (Me = {})), function(t) {
  t.REPO_ACL = "repo:acl", t.REPO_PRINCIPLE = "repo:principal", t.REPO_MODIFIER = "repo:modifier", t.REPO_PRIVILEGES = "repo:privileges", t.REPO_RELATIONS = "repo:relations", t.REPO_INHERITANCE = "repo:inheritance";
}(Gr || (Gr = {})), function(t) {
  t.XDM_PROVIDER = "xdm:provider", t.ID = "@id", t.TYPE = "@type";
}($r || ($r = {})), function(t) {
  t.ID = "@id";
}(Yr || (Yr = {})), function(t) {
  t.XML = "application/rdf+xml", t.JSON = "application/ld+json";
}(Xt || (Xt = {})), function(t) {
  t.REPO_SIZE = "repo:size", t.REPO_BLOCK_SIZE = "repo:blocksize", t.REPO_REL_TYPE = "repo:reltype", t.COMPONENT_ID = "component_id", t.DC_FORMAT = "dc:format", t.REPO_MD5 = "repo:md5", t.REPO_EXPIRES = "repo:expires", t.REPO_IF_MATCH = "repo:if-match", t.MAX_SINGLE_TRANSFER_SIZE = "repo:maxSingleTransferSize", t.REPO_MIN_BLOCK_TRANSFER_SIZE = "repo:minBlockTransferSize";
}(B || (B = {})), function(t) {
  t.DEVICE_MODIFY_DATE = "deviceModifyDate", t.REPO_META_PATCH = "repoMetaPatch", t.RESPOND_WITH = "respondWith";
}(yt || (yt = {}));
const zr = x("dcx:assets:service"), U = (t) => er(t) ? t.service : t, ne = (t) => er(t) ? t.cache : void 0;
function qe(t, e) {
  zr("constructServiceEndpoint()", t);
  const s = e._repoAPIBaseUrl;
  return s && (t = `${s.endsWith("/") ? s.substr(0, s.length - 1) : s}${t}`), zr("cSE()", t), t;
}
const $e = { Asset: "asset", Directory: "directory" };
var R, O;
(function(t) {
  t.CONTENT_ID = "content-id", t.CONTENT_LENGTH = "content-length", t.CONTENT_RANGE = "content-range", t.CONTENT_TYPE = "content-type", t.IF_MATCH = "if-match", t.IF_NONE_MATCH = "if-none-match", t.AUTHORIZATION = "authorization", t.X_API_KEY = "x-api-key", t.X_CONTRIBUTORS = "x-contributors", t.LES_SEQUENCE_NUMBER = "les-sequence-number", t.PREFER = "prefer", t.DIRECTIVE = "directive";
})(R || (R = {})), function(t) {
  t.GET = "GET", t.PUT = "PUT", t.PATCH = "PATCH", t.HEAD = "HEAD", t.POST = "POST", t.DELETE = "DELETE";
}(O || (O = {}));
const Ha = "application/vnd.adobecloud.directory+json", Ga = "application/vnd.adobe.dcx-manifest+json", $a = "application/json", Ms = "application/problem+json", ct = "application/json-patch+json", Pn = "application/vnd.adobecloud.bulk-transfer+json", Ya = "application/vnd.adobe.asset-operation+json", tr = ["buffer", "arraybuffer", "string", "text", "blob", "json", "stream", "defaultbuffer"];
function Sn(t, e) {
  var s = {};
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (s[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function") {
    var n = 0;
    for (r = Object.getOwnPropertySymbols(t); n < r.length; n++) e.indexOf(r[n]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[n]) && (s[r[n]] = t[r[n]]);
  }
  return s;
}
function re(t, e, s, r) {
  return new (s || (s = Promise))(function(n, o) {
    function i(h) {
      try {
        d(r.next(h));
      } catch (l) {
        o(l);
      }
    }
    function a(h) {
      try {
        d(r.throw(h));
      } catch (l) {
        o(l);
      }
    }
    function d(h) {
      var l;
      h.done ? n(h.value) : (l = h.value, l instanceof s ? l : new s(function(p) {
        p(l);
      })).then(i, a);
    }
    d((r = r.apply(t, [])).next());
  });
}
function ot(t) {
  return this instanceof ot ? (this.v = t, this) : new ot(t);
}
function qa(t, e, s) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var r, n = s.apply(t, e || []), o = [];
  return r = {}, i("next"), i("throw"), i("return"), r[Symbol.asyncIterator] = function() {
    return this;
  }, r;
  function i(p) {
    n[p] && (r[p] = function(_) {
      return new Promise(function(f, A) {
        o.push([p, _, f, A]) > 1 || a(p, _);
      });
    });
  }
  function a(p, _) {
    try {
      (f = n[p](_)).value instanceof ot ? Promise.resolve(f.value.v).then(d, h) : l(o[0][2], f);
    } catch (A) {
      l(o[0][3], A);
    }
    var f;
  }
  function d(p) {
    a("next", p);
  }
  function h(p) {
    a("throw", p);
  }
  function l(p, _) {
    p(_), o.shift(), o.length && a(o[0][0], o[0][1]);
  }
}
const N = (t, e, s) => {
  if (t == null) return Yt;
  const r = {}, n = {}, o = t || [];
  return (i, a) => {
    var d, h;
    if (!i || !a) return new c(I.NETWORK_ERROR, "Invalid or missing status code", void 0, a);
    if (o.includes(i)) return !0;
    const l = n[i] || ((d = $t.get(i)) === null || d === void 0 ? void 0 : d.message) || "Unexpected response", p = r[i] || ((h = $t.get(i)) === null || h === void 0 ? void 0 : h.code), _ = Yt(i, a);
    return _ === !0 && p == null || (it(_) ? _ : !!p && new c(p, l, void 0, a));
  };
}, F = (t, e = [], s, r) => {
  if (!S(t)) throw new c(s || c.INVALID_PARAMS, r || "Missing or invalid links on Asset");
  e.map((n) => {
    if (!(n in t) || !S(t[n])) throw new c(s || c.INVALID_PARAMS, r || `Missing required link: ${n}`);
  });
}, Cn = (t = {}, e = []) => {
  if (e.length !== 0) {
    for (let s = 0; s < e.length; s++) {
      const r = e[s];
      if (r in t && S(t[r])) return r;
    }
    throw new c(c.INVALID_PARAMS, `Missing links, one required: ${e.join(", ")}`);
  }
}, Nn = (t, e, s, r) => {
  const n = Qt(t, e, s);
  if (!n) throw new c(c.INVALID_DATA, `Missing ${s} param on Link`);
  if (n !== r) throw new c(c.INVALID_DATA, `Invalid ${s} param on Link, expected ${r}`);
}, at = (t, e = []) => {
  try {
    F(t, e);
  } catch {
    return !1;
  }
  return !0;
}, za = (t, e = []) => !!S(t) && at(t.links || t._links, e);
function Dn(t) {
  if (!Qs(t)) throw new c(c.INVALID_PARAMS, "Asset must contain links or repositoryId + path or assetId to be resolved.");
}
function kn(t, e, s) {
  if (!S(t)) throw new c(c.INVALID_PARAMS, `Invalid parameter. Expected object, encountered "${t === null ? "null" : typeof t}".`);
  if (!(e in t)) throw new c(c.INVALID_PARAMS, `Invalid parameter object. Expected object containing key "${String(e)}".`);
  if (s) try {
    Ye(e, t[e], s);
  } catch {
    throw new c(c.INVALID_PARAMS, `Invalid parameter object. Expected object containing key "${String(e)}" with type "${s}", encountered type "${typeof t[e]}".`);
  }
}
function Ne(t, e, s) {
  if (!(e.length < 1)) {
    for (const r of e) try {
      return void kn(t, r, s);
    } catch {
    }
    throw new c(c.INVALID_PARAMS, `Invalid parameter object. Expected object containing one of [${e.join(", ")}]` + (s ? ` with type ${s}, encountered types [${e.map((r) => typeof t[r]).join(", ")}].` : "."));
  }
}
const Wa = x("dcx:assets:util:http");
function sr(t, e, s) {
  return Wa("headHTTPResource()"), U(t).invoke(O.HEAD, e, s, void 0, { isStatusValid: N() });
}
function Ka(t, e, s, r) {
  return U(t).invoke(O.GET, e, s, void 0, { isStatusValid: N(), responseType: r });
}
const Ln = x("dcx:assets:util:serialization");
function se(t, e) {
  Ln("deserializeAsset()");
  const s = {};
  s.repositoryId = t.repositoryId || t[T.REPO_REPOSITORY_ID], s.assetId = t.assetId || t[T.REPO_ASSET_ID], s.name = t.name || t[T.REPO_NAME], s.size = t.size != null ? t.size : t[T.REPO_SIZE], s.path = t.path || t[T.REPO_PATH], s.assetClass = t.etag || t[T.REPO_ASSET_CLASS], s.etag = t.etag || t[T.REPO_ETAG], s.version = t.version || t[T.REPO_VERSION], s.format = t.format || t[T.DC_FORMAT], s.md5 = t.md5, s.createDate = t.createDate || t[T.REPO_CREATE_DATE], s.modifyDate = t.modifyDate || t.modifiedDate || t[T.REPO_MODIFY_DATE], s.discardDate = t.discardDate || t[T.REPO_DISCARD_DATE], s.createdBy = t.createdBy || t[T.REPO_CREATED_BY], s.modifiedBy = t.modifiedBy || t[T.REPO_MODIFIED_BY], s.discardedBy = t.discardedBy || t[T.REPO_DISCARDED_BY], s.deviceCreateDate = t.deviceCreateDate || t[T.REPO_DEVICE_CREATE_DATE], s.deviceModifyDate = t.deviceModifyDate || t[T.REPO_DEVICE_MODIFY_DATE], s.defaultScheduledDeletionDuration = t.defaultScheduledDeletionDuration || t[T.REPO_DEFAULT_SCHEDULED_DELETION_DURATION], s.scheduledDeletionDate = t.scheduledDeletionDate || t[T.REPO_SCHEDULED_DELETION_DATE], s.assetType = t.assetType || t[T.REPO_ASSET_TYPE], s.assetSubType = t.assetSubType || t[T.REPO_ASSET_SUB_TYPE], s.les = t.les || t[T.STORAGE_LES], s.baseAssetId = t.baseAssetId || t[T.REPO_BASE_ASSET_ID], s.state = t.state || t[T.REPO_STATE], s.links = t.links || t[T.LINKS], s.representations = t.representations || t[T.REPO_REPRESENTATIONS], s.contributors = t.contributors || t[T.REPO_CONTRIBUTORS], s.width = t.width || t[T.IMAGE_WIDTH], s.length = t.length || t[T.IMAGE_LENGTH];
  const r = [e, t._embedded].flat();
  return s.embedded = Object.entries({ EffectivePrivileges: u.EFFECTIVE_PRIVILAGES, RepositoryResource: u.REPOSITORY, AppMetadata: u.APP_METADATA }).reduce((n, [o, i]) => (r.filter((a) => a && i in a).forEach((a) => he(n, { [o]: i === u.REPOSITORY ? rr(a) : a })), n), {}), w(s);
}
function rr(t = {}) {
  Ln("deserializeRepository()");
  const e = t[u.REPOSITORY] ? t[u.REPOSITORY] : t;
  return { repositoryId: e[T.REPO_REPOSITORY_ID], repositoryType: e[T.REPO_REPOSITORY_TYPE], owner: e[T.REPO_OWNER], createDate: e[T.REPO_CREATE_DATE], title: e[T.DC_TITLE], availableRegions: e[T.REPO_AVAILABLE_REGIONS] };
}
function Xa(t) {
  const e = [];
  return t.assetType && e.push({ op: "add", path: `/${[T.REPO_ASSET_TYPE]}`, value: t.assetType }), t.assetSubType && e.push({ op: "add", path: `/${[T.REPO_ASSET_SUB_TYPE]}`, value: t.assetSubType }), e;
}
const wn = x("dcx:assets:util:link");
function Mn(t, e) {
  wn("getIndexLinks()");
  const s = U(t), r = ne(t);
  if (r) {
    const n = r.getIndexLinks();
    if (n) return C.resolve(n);
    r.setPending("INDEX");
  }
  return sr(s, qe("/", s), e).then((n) => Ee(n)).then((n) => (r && r.setIndexLinks(n), n)).catch((n) => {
    throw r && r.delete("INDEX"), n;
  });
}
function Un(t, e) {
  wn("getIndexDocument()");
  const s = U(t), r = ne(t);
  if (r) {
    const o = r.getIndexRepository();
    if (o) return C.resolve(o);
  }
  const n = qe("/", s);
  return s.invoke(O.GET, n, e, void 0, { responseType: "json", isStatusValid: N() }).then((o) => {
    const i = Ee(o), a = o.response, d = {};
    for (const h in a.children) {
      const l = a.children[h], p = l[T.LINKS];
      switch (l[T.REPO_PATH]) {
        case "/Index.json":
          d.indexLinks = p;
          break;
        case "/Assets.json":
          d.assetLinks = p;
          break;
        case "/Repositories.json":
          d.repositoryLinks = p;
      }
    }
    return r && (r.setIndexLinks(i), r.setIndexRepository(d)), d;
  });
}
function Ee(t) {
  if (!t.headers || !t.headers.link) throw new c(c.INVALID_DATA, "Failed to parse, missing link header");
  return nr(t.headers.link);
}
function nr(t) {
  try {
    const e = _i(t), s = {};
    for (const r in e.refs) {
      const n = e.refs[r], { rel: o, uri: i, templated: a, type: d, width: h, height: l } = n, p = Sn(n, ["rel", "uri", "templated", "type", "width", "height"]), _ = w({ href: i, templated: a ? a === "true" : void 0, type: d, width: h, height: l, [B.MAX_SINGLE_TRANSFER_SIZE]: p[B.MAX_SINGLE_TRANSFER_SIZE.toLowerCase()], [B.REPO_MIN_BLOCK_TRANSFER_SIZE]: p[B.REPO_MIN_BLOCK_TRANSFER_SIZE.toLowerCase()] });
      ["width", "height"].filter((A) => A in _).forEach((A) => {
        const y = parseInt(_[A], 10);
        isNaN(y) || (_[A] = y);
      });
      const f = s[o];
      Array.isArray(f) ? f.push(_) : s[o] = f ? [f, _] : _;
    }
    return Object.assign({}, s);
  } catch (e) {
    throw new c(c.INVALID_DATA, "Failed to parse, invalid link header", e);
  }
}
function De(t, e) {
  if (S(this)) {
    if (typeof this.opsHref == "string") return C.resolve(this.opsHref);
    if (q(this.opsHref)) return C.resolve(this.opsHref());
  }
  return Mn(t, e).then((s) => {
    try {
      return H(s, u.REPO_OPS);
    } catch (r) {
      throw new c(c.UNEXPECTED, "Could not get ops href.", r);
    }
  });
}
const Re = x("dcx:assets:operations"), Ke = x("dcx:assets:operations:builder"), Wr = 500;
function xn(t, e, s, r, n, o, i) {
  Re("copyAsset()"), E(["svc", t, "object"], ["srcAsset", e, "object"], ["destAsset", s, "object"], ["createIntermediates", r, "boolean"], ["overwriteExisting", n, "boolean", !0], ["manifestPatch", i, ["object", "string"], !0]), Ne(e, ["repo:path", "path", "assetId", "repo:assetId"], "string"), Ne(s, ["repo:path", "path", "assetId", "repo:assetId"], "string");
  const a = Te("copy", s, e, { overwriteExisting: n, createIntermediates: r }, { "repo:manifestPatch": JSON.stringify(i) }), d = U(t);
  return De.call(this, t).then((h) => je(d, h, a, o)).then(rs.bind(void 0, s)).then(or);
}
function Bn(t, e, s, r, n, o) {
  Re("moveAsset()"), E(["svc", t, "object"], ["srcAsset", e, "object"], ["destAsset", s, "object"], ["createIntermediates", r, "boolean"], ["overwriteExisting", n, "boolean", !0]), Ne(e, ["repo:path", "path", "assetId", "repo:assetId"], "string"), Ne(s, ["repo:path", "path", "assetId", "repo:assetId"], "string");
  const i = Te("move", s, e, { createIntermediates: r, overwriteExisting: n }), a = U(t);
  return De.call(this, t).then((d) => je(a, d, i, o)).then(rs.bind(void 0, s)).then(or);
}
function jn(t, e, s, r, n) {
  Re("discardAsset()"), E(["svc", t, "object"], ["asset", e, "object"], ["etag", s, "string", !0], ["recursive", r, "boolean", !0]);
  const o = U(t);
  Ne(e, ["repo:path", "path", "assetId", "repo:assetId"], "string");
  const i = Te("discard", Object.assign(Object.assign({}, e), { etag: s }), void 0, { recursive: r });
  return De.call(this, t).then((a) => je(o, a, i, n)).then(Jt);
}
const Vn = ss("AdobeDCX.deleteAsset", function(t, e, s = "*", r, n) {
  Re("deleteAsset()"), pe("mediaType", e.format), pe("assetId", e.assetId), E(["svc", t, "object"], ["asset", e, "object"], ["etag", s, "string", !0], ["recursive", r, "boolean", !0]);
  const o = U(t);
  if (e.format === Ha && r == null) throw new c(c.INVALID_PARAMS, "Recursive flag is required for directory assets.");
  if (!r && za(e, [u.REPO_METADATA])) {
    const d = Z(e, u.REPO_METADATA, {});
    return o.invoke("DELETE", d, { [R.IF_MATCH]: s }, void 0, { isStatusValid: N() }).then(Jt);
  }
  Ne(e, ["repo:path", "path", "assetId", "repo:assetId"], "string");
  const i = Object.create(Object.getPrototypeOf(e), Object.getOwnPropertyDescriptors(e));
  i.etag = s;
  const a = Te("delete", i, void 0, { recursive: r });
  return De.call(this, t).then((d) => je(o, d, a, n)).then(Jt);
});
function Fn(t, e, s) {
  Re("restoreAsset()"), E(["svc", t, "object"], ["asset", e, "object"]);
  const r = U(t);
  Ne(e, ["assetId", "repo:assetId"], "string");
  const n = Te("restore", e);
  return De.call(this, t).then((o) => je(r, o, n, s)).then(rs.bind(void 0, e)).then(or);
}
function Hn(t, e, s, r, n, o) {
  var i, a;
  Re("packageAssets()"), E(["svc", t, "object"], ["destination", s, "object"]), Ye("sources", e, ["object", "object[]"]), e = fe(e) ? e : [e], i = ["repo:path", "path", "assetId", "repo:assetId"], a = "string", e.map((l) => Ne(l, i, a)), Ne(s, ["repo:path", "path", "assetId", "repo:assetId"], "string");
  const d = Te("package", s, e, { createIntermediates: r, overwriteExisting: n }), h = U(t);
  return De.call(this, t).then((l) => je(h, l, d, o)).then(rs.bind(void 0, s)).then(Jt);
}
function Za(t, e, s, r) {
  return Gn(t, e, s, r).then(Ja);
}
function Ja(t) {
  return { result: (fe(t.response) ? t.response : [t.response]).map(Qa), response: t };
}
function Qa(t) {
  if (!t.error) return t;
  const e = Object.assign({}, t), s = N()(t.error.status);
  return e.error = it(s) ? s : new c(c.UNEXPECTED, "Unexpected response"), e._additionalData = t.error, e.error._message = t.error.title, e;
}
function je(t, e, s, r) {
  return Re("doOperation()"), E(["svc", t, "object"], ["opsEndpoint", e, "string"], ["operationDocument", s, ["string", "object"]], ["additionalHeaders", r, "object", !0]), Gn(t, e, s, r).then(xo);
}
class ec {
  constructor() {
    this.opBatchLimit = 100, this._docs = [];
  }
  getDocumentEntry(e) {
    return this._docs[e];
  }
  getDocument() {
    return this._docs;
  }
  get entryCount() {
    return this._docs.length;
  }
  copyResources(e, s, r, n, o, i) {
    Ke("copyResource()"), this._assertUnderLimit(), this._checkSourceType(e), this._checkTargetType(s);
    const a = this._docs.find(/* @__PURE__ */ function(h, l) {
      return function(p) {
        return p.op === "copy_resources" && Xr(p.source, h) && Xr(p.target, l);
      };
    }(e, s));
    if (a) return a.resources = a.resources.concat(r), o && (a["repo:manifestPatch"] = JSON.stringify(o)), n !== void 0 && (a.intermediates = n), this;
    const d = Te("copy_resources", s, e, { createIntermediates: n }, { resources: r, "repo:manifestPatch": JSON.stringify(o), additionalHeaders: i });
    return this._docs.push(d), this;
  }
  copy(e, s, r, n, o) {
    Ke("copy()"), this._assertUnderLimit(), this._checkSourceType(e), this._checkTargetType(s);
    const i = Te("copy", s, e, { createIntermediates: r, overwriteExisting: n }, o);
    return this._docs.push(i), this;
  }
  move(e, s, r, n, o) {
    Ke("move()"), this._assertUnderLimit(), this._checkSourceType(e), this._checkTargetType(s);
    const i = Te("move", s, e, { createIntermediates: r, overwriteExisting: n }, o);
    return this._docs.push(i), this;
  }
  package(e, s, r, n, o) {
    Ke("package()"), this._assertUnderLimit(), (e = fe(e) ? e : [e]).map((a) => {
      this._checkSourceType(a);
    }), this._checkTargetType(s);
    const i = Te("package", s, e, { createIntermediates: r, overwriteExisting: n }, o);
    return this._docs.push(i), this;
  }
  discard(e, s, r) {
    Ke("discard()"), this._assertUnderLimit(), this._checkTargetType(e);
    const n = Te("discard", e, void 0, { recursive: s }, r);
    return this._docs.push(n), this;
  }
  restore(e, s) {
    Ke("restore()"), this._assertUnderLimit(), Ne(e, ["assetId", "repo:assetId"], "string"), this._checkTargetType(e);
    const r = Te("restore", e, void 0, void 0, s);
    return this._docs.push(r), this;
  }
  delete(e, s, r) {
    Ke("delete()"), this._assertUnderLimit(), this._checkTargetType(e);
    const n = Te("delete", e, void 0, { recursive: s }, r);
    return this._docs.push(n), this;
  }
  _assertUnderLimit() {
    if (this._docs.length >= this.opBatchLimit) throw new c(c.INVALID_STATE, `Exceeds limit of ${this.opBatchLimit} operations in a single batch.`);
  }
  _checkTargetType(e) {
    this._checkSourceOrTargetType(e, "Target");
  }
  _checkSourceType(e) {
    this._checkSourceOrTargetType(e, "Source");
  }
  _checkSourceOrTargetType(e, s) {
    if ([!!e.assetId || !!e["repo:assetId"], !!e.path || !!e["repo:path"]].filter((o) => o).length === 0) throw new c(c.INVALID_PARAMS, `${s} identifier is underspecified. Exactly one of [href, repo:path, repo:assetId] required.`);
    const r = this._getSourceType(e), n = s === "Source" ? this._batchSourceType : this._batchTargetType;
    if (n) {
      if (r !== n) throw new c(c.INVALID_PARAMS, `Operation ${s.toLowerCase()} types must all be the same type. Expected ${n}, encountered ${r}.`);
    } else s === "Source" ? this._batchSourceType = r : this._batchTargetType = r;
  }
  _getSourceType(e) {
    return e.assetId || e["repo:assetId"] ? "id" : e.path || e["repo:path"] ? e.baseAssetId || e["repo:baseAssetId"] ? "pathAndBaseAssetId" : "path" : void 0;
  }
}
function Kr() {
  return new ec();
}
function Xr(t, e) {
  var s, r;
  return t[T.REPO_ASSET_ID] === ((s = e[T.REPO_ASSET_ID]) !== null && s !== void 0 ? s : e.assetId) && t[T.REPO_REPOSITORY_ID] === ((r = e[T.REPO_REPOSITORY_ID]) !== null && r !== void 0 ? r : e.repositoryId);
}
function Gn(t, e, s, r = {}) {
  return t.invoke(O.POST, e, Object.assign({ [R.CONTENT_TYPE]: Ya }, r), typeof s == "string" ? s : JSON.stringify(s), { isStatusValid: N(), responseType: "json", retryOptions: { pollCodes: [202], pollHeader: "location", pollMethod: "get", modifyHeadersCallback: On([R.PREFER]) } });
}
function rs(t, e) {
  return e.response.asset = Object.assign(Object.assign({}, e.response.asset || {}), { repositoryId: t.repositoryId || t["repo:repositoryId"] }), e;
}
function or(t) {
  return { response: t, result: se(t.response.asset) };
}
function Jt(t) {
  return { response: t, result: { success: t.statusCode > 199 && t.statusCode < 400 } };
}
function ms(t, e, s) {
  if (Re("_convertToACPSource()"), typeof e != "object") return;
  const r = { "repo:repositoryId": e.repositoryId || e["repo:repositoryId"], "repo:path": e.path || e["repo:path"], "repo:assetId": e.assetId || e["repo:assetId"], "repo:baseAssetId": e.baseAssetId || e["repo:baseAssetId"] };
  return typeof r.href == "string" ? (delete r["repo:path"], delete r["repo:assetId"], delete r["repo:baseAssetId"]) : typeof r["repo:assetId"] == "string" && (delete r["repo:path"], delete r["repo:baseAssetId"]), t === "target" ? s === !0 ? r[R.IF_MATCH] = e.format !== $e.Directory && e["dc:format"] !== $e.Directory && e.etag || "*" : s === !1 ? r[R.IF_NONE_MATCH] = "*" : e.format !== $e.Directory && e["dc:format"] !== $e.Directory && (r[R.IF_MATCH] = e.etag) : e.format !== $e.Directory && e["dc:format"] !== $e.Directory && (r[R.IF_MATCH] = e.etag || "*"), e.version && (r["repo:version"] = e.version), r["repo:path"] && kn(r, "repo:repositoryId", "string"), Re("_cTACPS() out", r), w(r);
}
function Te(t, e, s, r = {}, n = {}) {
  Re("_buildOperationDoc()");
  const o = w({ op: t, target: e, source: fe(s) ? [] : s ? {} : void 0 }), { overwriteExisting: i, createIntermediates: a, recursive: d } = r;
  if (o.source && (o.source = fe(s) ? s.map((h) => ms("source", h, i)).filter((h) => h != null) : ms("source", s, i)), typeof e == "object") {
    const h = ms("target", e, i);
    h && (o.target = h);
  }
  return o.target["repo:assetId"] == null && a != null && (o.intermediates = a), d != null && (o.recursive = d), Object.assign(o, n), Re("_OD() doc", o), o;
}
function $n(t, e, s, r, n, o, i) {
  if (E(["resources", r, "array", !1]), r.length <= Wr) {
    const a = Kr().copyResources(e, s, r, n, o).getDocument();
    return De(t).then((d) => je(U(t), d, a, i)).then((d) => {
      const { asset: h, source: l, target: p, resources: _ } = d.response[0];
      return { result: { source: se(l), target: se(p), resources: _, asset: h ? se(h) : void 0 }, response: d };
    });
  }
  return function(a, d, h, l, p, _, f, A) {
    E(["resources", l, "array", !1]);
    const y = [];
    for (let m = 0; m < l.length; m += p) y.push(l.slice(m, m + p));
    let b;
    function v(m, D) {
      const k = Kr().copyResources(d, h, D, _, f).getDocument();
      return De(a).then((j) => je(U(a), j, k, A)).then((j) => {
        b ? b.response[0].resources.push(...j.response[0].resources) : b = j;
        const { asset: J, source: G, target: ve, resources: ke } = j.response[0], Q = { source: se(G), target: se(ve), resources: ke, asset: J ? se(J) : void 0 };
        return Object.assign(Object.assign({}, Q), { resources: [...m == null ? void 0 : m.resources, ...Q.resources], asset: Q.asset || m.asset });
      });
    }
    let P = C.resolve({ resources: [], source: {}, target: {} });
    for (const m of y) P = P.then((D) => v(D, m));
    return P.then((m) => {
      if (!b) throw new c(c.UNEXPECTED_RESPONSE, "No response received from copy resources operation");
      return { result: m, response: b };
    });
  }(t, e, s, r, Wr, n, o, i);
}
var g;
(function(t) {
  t.NOT_INITIALIZED = "NOT_INITIALIZED", t.INITIALIZING = "INITIALIZING", t.INITIALIZED = "INITIALIZED", t.WAITING = "WAITING", t.STARTED = "STARTED", t.PAUSING = "PAUSING", t.PAUSED = "PAUSED", t.CANCELED = "CANCELED", t.ERROR = "ERROR", t.FINALIZING = "FINALIZING", t.COMPLETE = "COMPLETE";
})(g || (g = {}));
const ce = new class {
  constructor() {
    this._uploads = [], this._downloads = [], this._pendingUploadRequests = [], this._pendingDownloadRequests = [], this._downloadChunkSize = 10485760;
  }
  get downloads() {
    return this._downloads;
  }
  get uploads() {
    return this._uploads;
  }
  set downloadChunkSize(t) {
    E(["downloadChunkSize", t, "+number"]), this._downloadChunkSize = t;
  }
  get downloadChunkSize() {
    return this._downloadChunkSize;
  }
  get pendingUploadRequests() {
    return this._pendingUploadRequests;
  }
  get pendingDownloadRequests() {
    return this._pendingDownloadRequests;
  }
  resetUploads() {
    this._uploads = [], this._pendingUploadRequests = [];
  }
  addAndStartUpload(t) {
    return this._addAndStart("upload", t);
  }
  addAndStartDownload(t) {
    return t.state !== g.INITIALIZED ? Promise.resolve(t) : this._addAndStart("download", t);
  }
  startNextWaiting(t) {
    const e = t === "upload" ? this._uploads : this._downloads, s = [];
    let r = !1;
    for (const o of e) !r && o && o.state === g.WAITING ? (o.start(), r = !0) : o.state !== g.CANCELED && o.state !== g.ERROR && o.state !== g.FINALIZING && o.state !== g.COMPLETE || s.push(o);
    const n = e.filter((o) => !s.includes(o));
    t === "download" ? this._downloads = n : this._uploads = n;
  }
  _addAndStart(t, e) {
    const s = t === "upload" ? this._uploads : this._downloads;
    return s.filter((r) => r && (r.state === g.NOT_INITIALIZED || r.state === g.INITIALIZED || r.state === g.INITIALIZING || r.state === g.STARTED)).length === 0 ? e.start() : e._setWaiting(), s.push(e), e.promise;
  }
}(), $ = x("dcx:assets:blockdownload"), tc = x("dcx:assets:blockdownload:leaf"), sc = function* () {
  let t = 0;
  for (; ; ) yield t++;
}();
class rc extends $s {
  constructor(e, s, r = {}) {
    super(["stateChanged"]), this._state = g.NOT_INITIALIZED, this._cachedBlocks = /* @__PURE__ */ new Map(), this._blockRequestIndex = 0, this._blockHandledIndex = 0, this._currentByteRange = [void 0, void 0], this._pending = [], $("constructor");
    const { startByte: n, blockSize: o, endByte: i, url: a, totalSize: d, maxConcurrentRequests: h } = Object.assign({ blockSize: ce.downloadChunkSize, maxConcurrentRequests: 4 }, w(r));
    E(["svc", e, "object"], ["responseType", s, "enum", !1, ["buffer"]], ["blockSize", o, "+number"], ["url", a, "string", !0], ["startByte", n, "number", !0], ["endByte", i, "number", !0], ["totalSize", d, "number", !0], ["maxConcurrentRequests", h, "+number"]), this._dbgId = sc.next().value, this._maxConcurrentRequests = h, this._blockSize = Math.round(o), this._service = e, this._url = a, this._startByte = n, this._endByte = i, this._totalSize = d, this._bytes = new Uint8Array(), this._promise = new C((l, p) => {
      this._resolve = () => {
        $(this._dbgId, "resolving"), this.removeAllHandlers(), l(this);
      }, this._reject = (_) => {
        $(this._dbgId, "rejecting: ", _), this.removeAllHandlers(), p(_);
      };
    });
  }
  get contentType() {
    var e;
    return (e = this._contentType) !== null && e !== void 0 ? e : "";
  }
  get totalSize() {
    return this._totalSize;
  }
  get buffer() {
    return this._bytes;
  }
  get state() {
    return this._state;
  }
  get promise() {
    return this._promise;
  }
  _requestBlock(e, s, r, n) {
    $(this._dbgId, "_requestBlock(): ", e, s, r, n);
    const o = Yn(e, s);
    return this._service.invoke(O.GET, this._url, o, void 0, { responseType: "defaultbuffer", isStatusValid: N(), isExternalRequest: !0 }).then((i) => ({ response: i, index: r, lane: n })).catch(this._handleErrorAndThrow.bind(this));
  }
  init(e = this._url, s = this._totalSize) {
    if ($(this._dbgId, "init(): ", e, s), this._state === g.INITIALIZED && e === this._url && s === this._totalSize) return C.resolve(this);
    if (this._assertStateIsValid("init"), this._shiftState(g.INITIALIZING), this._url = e, this._initByteRange(s), this._totalSize !== 1 / 0 || this._currentByteRange[0] == null) return this._shiftState(g.INITIALIZED), C.resolve(this);
    const { startByte: r, endByte: n, blockIndex: o } = this._nextBlockData();
    let i = g.INITIALIZED;
    return this._requestBlock(r, n, o, 0).then((a) => (this._updateTotalSize(a), (!n || n > this._endByte) && (i = g.FINALIZING), a)).then(this._handleBlock.bind(this)).then(() => this._shiftState(i)).catch(this._handleErrorAndThrow.bind(this));
  }
  start() {
    if ($(this._dbgId, "start()"), this._assertStateIsValid("start"), this._shiftState(g.STARTED), this._currentByteRange[0] != null) return this._start(), this._promise;
    const [e, s] = this._currentByteRange, r = this._blockRequestIndex;
    return this._blockRequestIndex += 1, this._currentByteRange = [s + 1, s], this._requestBlock(e, s, r, 0).then(this._handleBlock.bind(this)).catch(this._handleError.bind(this)), this._promise;
  }
  pause() {
    return $(this._dbgId, "pause()"), this._assertStateIsValid("pause"), this._shiftState(g.PAUSING), C.allSettled(this._pending).then(() => (this._shiftState(g.PAUSED), ce.startNextWaiting("download"), this));
  }
  resume() {
    return $(this._dbgId, "resume()"), this.state === g.PAUSED && (this._shiftState(g.STARTED), this._start()), this;
  }
  cancel() {
    return $(this._dbgId, "cancel()"), this._assertStateIsValid("cancel"), this._shiftState(g.CANCELED), this._reject(new c(c.ABORTED, "BlockDownload aborted.")), ce.startNextWaiting("download"), this._promise;
  }
  _setWaiting() {
    this._shiftState(g.WAITING);
  }
  _start() {
    $(this._dbgId, "_start()");
    for (let e = 0; e < this._maxConcurrentRequests; e++) this._loop(e).catch(this._handleError.bind(this));
  }
  get _loopShouldContinue() {
    const e = this._state === g.STARTED && this._currentByteRange[0] <= this._endByte;
    return $(this._dbgId, "_loopShouldContinue() ", e, this._currentByteRange, this._endByte), e;
  }
  _loop(e) {
    return re(this, void 0, void 0, function* () {
      $(this._dbgId, "_loop(): ", e);
      let s = !1;
      for (; this._loopShouldContinue && !s; ) {
        const { startByte: r, endByte: n, blockIndex: o, done: i } = this._nextBlockData();
        s = i;
        const a = this._requestBlock(r, n, o, e).then(this._handleBlock.bind(this)).catch(this._handleError.bind(this));
        this._pending[e] = a, yield a;
      }
      $(this._dbgId, `_loop(${e}) done, ${s}`), s && ($(this._dbgId, `_loop(${e}) finalize`), this._shiftState(g.FINALIZING));
    });
  }
  _nextBlockData() {
    $(this._dbgId, "_nextBlockData()");
    const e = this._blockRequestIndex;
    this._blockRequestIndex += 1;
    const [s, r] = this._currentByteRange;
    return this._currentByteRange[0] += this._blockSize, this._currentByteRange[1] = Math.min(this._currentByteRange[1] + this._blockSize, this._endByte), { startByte: s, endByte: r, blockIndex: e, done: r >= this._endByte };
  }
  _initByteRange(e = this._totalSize) {
    if ($(this._dbgId, "_initByteRange(): ", e), this._totalSize = e, this._totalSize != null && this._totalSize < 0) throw new c(c.INVALID_PARAMS, "Total size must be positive.");
    if (this._totalSize || (this._totalSize = 1 / 0), this._endByte || (this._endByte = this._totalSize), !this._startByte && this._endByte === this._totalSize) return this._startByte = 0, void (this._currentByteRange = [0, this._blockSize - 1]);
    if (!this._startByte && this._endByte < 0 && this._totalSize !== 1 / 0 ? (this._startByte = Math.max(0, this._totalSize + this._endByte), this._endByte = this._totalSize) : !this._startByte && this._endByte > 0 && (this._startByte = 0), this._startByte != null && (this._currentByteRange[0] = Math.max(this._startByte, 0)), (this._endByte == null || this._endByte > 0) && (this._currentByteRange[1] = Math.min(this._endByte, (this._startByte || 0) + this._blockSize - 1)), this._startByte != null || this._endByte === 1 / 0) return;
    if (this._totalSize === 1 / 0) {
      if (-this._endByte > this._blockSize) throw new c(c.INVALID_PARAMS, "Cannot download last N bytes without a total size.");
      return void (this._currentByteRange = [void 0, this._endByte]);
    }
    this._startByte = Math.max(0, this._totalSize + this._endByte), this._endByte = this._totalSize;
    const s = Math.min(this._startByte + this._blockSize - 1, this._endByte);
    this._currentByteRange = [this._startByte, s];
  }
  _finalize() {
    return $(this._dbgId, "_finalize() start"), ce.startNextWaiting("download"), C.allSettled(this._pending).then(() => {
      this._checkCachedBlocks(), this._shiftState(g.COMPLETE);
    });
  }
  _updateTotalSize(e) {
    if ($(this._dbgId, "_updateTotalSize()"), this._totalSize == null || this._totalSize === 1 / 0) try {
      const s = e.response.headers["content-range"], r = parseInt(s.split("/")[1]);
      pn(() => !isNaN(r), "Invalid number."), this._totalSize = r, this._endByte === 1 / 0 && (this._endByte = this._totalSize);
    } catch (s) {
      throw new c(c.INVALID_DATA, "Could not determine total size.", s, e.response);
    }
    return $(this._dbgId, "_uTS(): ", this._totalSize, this._endByte), e;
  }
  _handleError(e) {
    $(this._dbgId, "_handleError(): ", e), this._shiftState(g.ERROR), this._error = e, it(e) || (this._error = new c(c.UNEXPECTED, "An unexpected error occurred.", e)), this._reject(this._error);
  }
  _handleErrorAndThrow(e) {
    throw this._handleError(e), this._error;
  }
  _handleBlock(e) {
    this._endByte === 1 / 0 && this._updateTotalSize(e);
    const { index: s, response: r } = e;
    if ($(this._dbgId, `_handleBlock(${s})`), s !== this._blockHandledIndex) return $(this._dbgId, `_handleBlock(${s}) cached`), void this._cachedBlocks.set(s, e);
    $(this._dbgId, `_handleBlock(${s}) handled`), this._pushBlockData(r), this._markCurrentBlockHandled();
  }
  _markCurrentBlockHandled() {
    this._cachedBlocks.delete(this._blockHandledIndex), this._blockHandledIndex += 1, this._checkCachedBlocks();
  }
  _checkCachedBlocks() {
    const e = this._cachedBlocks.get(this._blockHandledIndex);
    e && this._handleBlock(e);
  }
  _pushBlockData(e) {
    if (this._state === g.ERROR) return;
    this._contentType = this._contentType || e.headers[R.CONTENT_TYPE];
    const s = typeof Buffer < "u" && e.response instanceof Buffer ? e.response : new Uint8Array(e.response);
    this._bytes = we(this._bytes, s);
  }
  _shiftState(e) {
    return $(this._dbgId, "_shiftState(): ", e), this._state === g.COMPLETE || this._state === g.ERROR || this._state === g.CANCELED || (this._state = e, this.emit("stateChanged", [this._state, this]), e === g.FINALIZING && this._finalize(), e === g.COMPLETE && Promise.all(this._pending).then(this._resolve.bind(this))), this;
  }
  _assertStateIsValid(e, s = this._state) {
    $(this._dbgId, "_assertStateIsValid() ", e, s);
    let r = !1;
    const n = "Invalid state transition.";
    switch (e) {
      case "init":
        s === g.NOT_INITIALIZED && (r = !0);
        break;
      case "start":
        s !== g.INITIALIZED && s !== g.WAITING && s !== g.STARTED || (r = !0);
        break;
      case "pause":
        s !== g.INITIALIZING && s !== g.STARTED || (r = !0);
        break;
      case "cancel":
        r = !0;
    }
    if (!r) throw $(this._dbgId, "_aSIV() throw ", n), new c(c.INVALID_STATE, n, void 0, void 0, { method: e, currentState: s });
  }
}
function nc(t, e, s) {
  return new rc(t, e, s);
}
function et(t, e, s, r, n = "defaultbuffer", o, i, a) {
  tc("_doBlockDownload()");
  const d = n === "stream" ? void 0 : nc(t, "buffer", { startByte: s, endByte: r });
  (this != null ? this : {}).blockDownload = d;
  let h = C.resolve(e, this !== void 0 ? this : {});
  return o || (h = h.then(() => t.invoke(O.GET, e, Object.assign({ priority: "u=1" }, a), void 0, { responseType: "text", isStatusValid: N(), retryOptions: { pollCodes: [202], pollHeader: "location", pollMethod: "GET" } })).then((l) => {
    const p = l.response.indexOf("href") > 0 ? Cr(l.response, '"href":\\s*"([^;"]*)"') : "";
    if (typeof p != "string" || p === "") throw new c(c.UNEXPECTED_RESPONSE, "No block download href found in response.", void 0, l);
    return i = i || parseInt(Cr(l.response, '"size":\\s*(\\d+)')), p;
  })), h.then((l) => re(this, void 0, void 0, function* () {
    return d ? Promise.race([d.init(l, i).then(() => ce.addAndStartDownload(d)), d.promise]).then(() => ({ statusCode: 200, headers: w({ [R.CONTENT_TYPE]: d.contentType, [R.CONTENT_LENGTH]: d.totalSize }), responseType: n, response: oc(d.buffer, n, d.contentType), message: "OK" })) : t.invoke(O.GET, l, Yn(s, r), void 0, { responseType: "stream", isExternalRequest: !0 });
  }));
}
function oc(t, e, s) {
  if (e === "defaultbuffer" || e === "buffer" || e === "arraybuffer") return t.buffer;
  if (e === "blob") return new Blob([t], { type: s });
  const r = ye(t);
  if (e === "text") return r;
  try {
    return JSON.parse(r);
  } catch {
    return r;
  }
}
function Yn(t, e) {
  return t == null && e == null ? {} : { range: `bytes=${t ?? (e != null && e > 0 ? "0" : "")}-${e != null ? Math.abs(e) : ""}` };
}
const Ht = x("dcx:assets:private");
function ir(t, e, s, r, n = "defaultbuffer", o, i, a = {}, d = !1) {
  let h;
  Ht("_getUrlFallbackDirect()");
  const l = this !== void 0 ? this : {};
  return C.resolve(void 0, l).then(() => t.invoke(O.GET, s, Object.assign({ priority: "u=1" }, a), void 0, { responseType: n, isStatusValid: N([400]) })).then((p) => (Ht("_gUFD() status code", p.statusCode), h = p, p.statusCode === 400 && p.xhr ? p.xhr.getResponseDataAsJSON() : p)).then((p) => {
    const _ = S(p) && (h.statusCode === 400 || p.status === 400) && p.type === X.RESPONSE_TOO_LARGE;
    if (Ht("_gUFD() do direct", _), !_ && h.statusCode === 400) throw new c(c.UNEXPECTED_RESPONSE, "Unexpected response", void 0, h);
    return _;
  }).then((p) => {
    if (!p) return h;
    if (!("location" in h.headers) || typeof h.headers.location != "string") {
      if (!at(e.links, [u.BLOCK_DOWNLOAD])) throw new c(c.INVALID_DATA, "Resource too large and missing download link.");
      const _ = w({ reltype: r, component_id: o, revision: i }), f = Z(e.links, u.BLOCK_DOWNLOAD, { resource: r ? JSON.stringify(_) : void 0 });
      return d ? { statusCode: 200, headers: w({ [R.CONTENT_TYPE]: h.headers["content-type"], [R.CONTENT_LENGTH]: h.headers["content-length"] }), responseType: n, response: { href: f }, message: "OK" } : et.call(l, t, f, void 0, void 0, n, !1, void 0, a);
    }
    return d ? { statusCode: 200, headers: w({ [R.CONTENT_TYPE]: h.headers["content-type"], [R.CONTENT_LENGTH]: h.headers["content-length"] }), responseType: n, response: { href: h.headers.location }, message: "OK" } : et.call(l, t, h.headers.location, void 0, void 0, n, !0, void 0, a);
  });
}
function Gt({ additionalHeaders: t = {}, asset: e, contentType: s, data: r, etag: n, headHref: o, href: i, maybeIsNew: a, relation: d, service: h }, l = !1) {
  if (Ht("_doUpload()"), E(["service", h, "object"], ["asset", e, "object"], ["href", i, "string"], ["headHref", o, "string"], ["contentType", s, "string", !0], ["maybeIsNew", a, "boolean", !0], ["etag", n, "string", !0], ["isRetry", l, "boolean", !0], ["additionalHeaders", t, "object", !0]), a == null) return h.invoke(O.HEAD, o, t, void 0, { isStatusValid: N([404]) }).then((_) => {
    const f = _.statusCode !== 200;
    return Gt({ additionalHeaders: t, asset: e, contentType: s, data: r, etag: n, headHref: o, href: i, maybeIsNew: f, relation: d, service: h }, l);
  });
  const p = a;
  return p ? delete t[R.IF_MATCH] : t[R.IF_MATCH] = n || "*", s && (t[R.CONTENT_TYPE] = s), h.invoke(O.PUT, i, t, r, { isStatusValid: N([404, 409, 412]), retryOptions: { pollHeader: "location", pollCodes: [202] } }).then((_) => {
    const f = _.statusCode;
    if (f > 400 && !l) {
      if (n != null) throw N()(f, _);
      if (!p && f === 404) return Gt({ additionalHeaders: t, asset: e, contentType: s, data: r, etag: n, headHref: o, href: i, maybeIsNew: !0, relation: d, service: h }, !0);
      if (f === 404) throw new c(c.NOT_FOUND, "Unexpected response", void 0, _);
      if (f === 409 || f === 412) return Gt({ additionalHeaders: t, asset: e, contentType: s, data: r, etag: n, headHref: o, href: i, maybeIsNew: void 0, relation: d, service: h }, !0);
    }
    return _;
  });
}
const ic = x("dcx:assets:bulk");
function ac(t, e) {
  const s = `\r
`;
  let r = Uint8Array.from([]);
  for (let n = 0; n < t.length; n++) {
    const o = t[n];
    r = we(r, Ie(n === 0 ? `--${e}${s}` : `${s}--${e}${s}`)), r = we(r, Ie(`${[R.CONTENT_TYPE]}: application/http${s}`)), r = we(r, Ie(`${s}${o.method} ${o.href}`));
    let i = !1;
    for (const a in o.headers) {
      const d = a.toLowerCase();
      d === "content-length" && (i = !0), r = we(r, Ie(`${s}${d}: ${o.headers[a]}`));
    }
    if (o.body) {
      const a = cc(o.body);
      i || (r = we(r, Ie(`${s}content-length: ${a.length}`))), r = we(r, Ie(`${s}${s}`)), r = we(r, a);
    }
  }
  return r = we(r, Ie(`${s}--${e}--${s}`)), r;
}
function cc(t) {
  if (typeof t == "string") return Ie(t);
  if ($o(t)) return new Uint8Array(t);
  if (Rn(t)) return t;
  throw new c(c.INVALID_PARAMS, "Bulk subrequest body expecting string | ArrayBuffer | Buffer");
}
function ar(t, e) {
  const s = t.headers[R.CONTENT_TYPE];
  if (!s) throw new c(c.UNEXPECTED_RESPONSE, "Missing boundary header in multipart response");
  const r = s.split("=")[1], n = function(o, i) {
    const a = new Uint8Array(o), d = Ie(`--${i}`);
    return qn(a, Us(a, d), d.byteLength).map((l) => ns(l, !0));
  }(t.response, r);
  if (e && n.length !== e) throw new c(c.UNEXPECTED_RESPONSE, `Unexpected number of parts; Expected ${e}, Received ${n.length}`);
  return n;
}
function Us(t, e) {
  const s = new Array(256).fill(-1), r = [];
  for (let o = 0; o < e.length; o++) s[e[o]] = o;
  let n = 0;
  for (; n <= t.length - e.length; ) {
    let o = e.length - 1;
    for (; o >= 0 && e[o] === t[n + o]; ) o--;
    o < 0 ? (r.push(n), n += n + e.length < t.length ? e.length - s[t[n + e.length]] : 1) : n += Math.max(1, o - s[t[n + o]]);
  }
  return r;
}
function qn(t, e, s, r = !1) {
  let n = r ? 0 : void 0;
  const o = [];
  for (const i of e) n !== void 0 && o.push(t.subarray(n, i)), n = i + s;
  return r && o.push(t.subarray(n)), o;
}
function ns(t, e = !1) {
  const s = Ie(`\r
\r
`), r = Us(t, s).slice(0, 2), n = Ie(`

`), o = qn(t, ...r.length > 0 ? [r, s.byteLength] : [Us(t, n).slice(0, 2), n.byteLength], !0), i = o.slice(0, e || o.length > 1 ? 2 : 1).reduce((p, _) => Object.assign(p, Ys(ye(_))), {}), a = o.length > 1 ? o[o.length - 1] : void 0, d = parseInt(ye(o[e ? 1 : 0]).split(`\r
`, 1)[0].split(" ")[1]), h = parseInt(i["content-length"], 10);
  let l;
  return l = isNaN(h) ? (a == null ? void 0 : a.length) === 0 ? new Uint8Array([]) : a : h === 0 ? new Uint8Array([]) : a == null ? void 0 : a.subarray(0, h), { headers: i, response: i[R.CONTENT_TYPE] === Ms && l !== void 0 ? JSON.parse(ye(l)) : l, statusCode: d };
}
function dc(t) {
  if (t.length > 10) throw new c(c.INVALID_PARAMS, "A single bulk request can only contain a maximum of 10 sub-requests.");
  const { writeOperations: e, readOperations: s } = t.reduce((r, n) => {
    if (typeof n.href != "string") throw new c(c.INVALID_PARAMS, "A sub-request of the bulk operation is missing an href");
    if (typeof n.method != "string") throw new c(c.INVALID_PARAMS, "A sub-request of the bulk operation is missing the HTTP method");
    const o = n.method.toUpperCase();
    if (!Object.values(O).includes(o)) throw new c(c.INVALID_PARAMS, "A sub-request of the bulk operation includes an invalid HTTP method");
    return [O.GET, O.HEAD].includes(o) ? r.readOperations.push(n) : r.writeOperations.push(n), r;
  }, { readOperations: [], writeOperations: [] });
  if (e.length > 0 && s.length > 0) throw new c(c.INVALID_PARAMS, "Cannot mix READ and WRITE operations in bulk sub requests.");
}
function os(t, e, s, r = "id", n = {}, o = !1) {
  return ic("performBulkRequest()"), E(["svc", t, "object"], ["asset", e, "object"], ["requests", s, "array"], ["linkMode", r, "string", !0, ["id", "path"]]), F(e.links, [u.BULK_REQUEST]), dc(s), zn(t, e, s, r, n).then(({ response: i, subresponses: a }) => re(this, void 0, void 0, function* () {
    const d = Wn(a, s);
    return { result: o ? yield Kn(t, e, d, r, n, a) : a, response: i };
  }));
}
function zn(t, e, s, r = "id", n = {}) {
  const o = `boundary-${Date.now()}`, i = ac(s, o), a = Object.assign(Object.assign({}, n), { [R.CONTENT_TYPE]: `multipart/mixed;boundary=${o}` }), d = H(e.links, u.BULK_REQUEST, r);
  return t.invoke(O.POST, d, a, i, { isStatusValid: N(), responseType: "defaultbuffer", retryOptions: { pollHeader: "location", pollCodes: [202], pollMethod: O.GET } }).then((h) => ({ response: h, subresponses: ar(h, s.length) }));
}
function Wn(t, e) {
  return t.filter(({ statusCode: s }) => gt(s)).map((s) => e.find(({ href: r }) => r === s.headers["content-id"])).filter((s) => s);
}
function Kn(t, e, s, r = "id", n = {}, o, i = 5) {
  return re(this, void 0, void 0, function* () {
    if (s.length === 0 || i <= 0) return o;
    if (s.length === 1) {
      const [d] = s, h = yield U(t).invoke(d.method, d.href, d.headers, d.body, { isStatusValid: N(), responseType: "defaultbuffer", retryOptions: { pollHeader: "location", pollCodes: [202], pollMethod: O.GET } });
      return h.headers["content-id"] = d.href, o.map((l) => "content-id" in l.headers && l.headers["content-id"] === h.headers["content-id"] ? h : l);
    }
    const a = yield zn(t, e, s, r, n).then((d) => re(this, void 0, void 0, function* () {
      const h = Wn(d.subresponses, s);
      return h.length ? yield Kn(t, e, h, r, n, d.subresponses, i - 1) : d.subresponses;
    }));
    return o.map((d) => a.find((h) => h.headers["content-id"] === d.headers["content-id"]) || d);
  });
}
const V = x("dcx:assets:asset"), Y = x("dcx:assets:asset:leaf");
class vt {
  constructor(e, s, r = {}) {
    this.type = $e.Asset, this._data = {}, this._data = se(e), this._svc = U(s), this._cache = ne(s), this._links = he({}, e.links || {}, e._links || {}, r);
  }
  setLinks(e) {
    this._links = e, this._updateCachedLinks();
  }
  get links() {
    return this._links;
  }
  set links(e) {
    this.setLinks(e);
  }
  setLink(e, s) {
    this._links[e] = s, this._updateCachedLinks();
  }
  getLink(e) {
    return this._links[e];
  }
  removeLink(e) {
    delete this._links[e], this._updateCachedLinks();
  }
  _updateCachedLinks() {
    this._cache && this._cache.setValueWithAsset(this.links, this.asset);
  }
  getLinkProperty(e, s, r = "id") {
    return V("getLinkProperty()"), Qt({ _links: this._links }, e, s, r);
  }
  getLinkHrefTemplated(e, s, r = "id") {
    return V("getLinkHrefTemplated()"), Z({ _links: this._links }, e, s, r);
  }
  getLinkHref(e, s = "id") {
    return V("getLinkHref()"), H({ _links: this._links }, e, s);
  }
  get asset() {
    return Object.assign(Object.assign({}, this._data), this.links);
  }
  get serviceConfig() {
    return { service: this._svc, cache: this._cache };
  }
  get repositoryId() {
    return this._data.repositoryId;
  }
  set repositoryId(e) {
    this._data.repositoryId = e;
  }
  get assetId() {
    return this._data.assetId;
  }
  set assetId(e) {
    this._data.assetId = e;
  }
  get path() {
    return this._data.path;
  }
  set path(e) {
    this._data.path = e;
  }
  get name() {
    return this._data.name;
  }
  get etag() {
    return this._data.etag;
  }
  set etag(e) {
    this._data.etag = e;
  }
  get version() {
    return this._data.version;
  }
  set version(e) {
    this._data.version = e;
  }
  get format() {
    return this._data.format;
  }
  set format(e) {
    this._data.format = e;
  }
  get assetClass() {
    return this._data.assetClass;
  }
  get createDate() {
    return this._data.createDate;
  }
  get modifyDate() {
    return this._data.modifyDate;
  }
  get discardDate() {
    return this._data.discardDate;
  }
  get createdBy() {
    return this._data.createdBy;
  }
  get modifiedBy() {
    return this._data.modifiedBy;
  }
  get discardedBy() {
    return this._data.discardedBy;
  }
  get deviceCreateDate() {
    return this._data.deviceCreateDate;
  }
  get deviceModifyDate() {
    return this._data.deviceModifyDate;
  }
  get baseAssetId() {
    return this._data.baseAssetId;
  }
  set baseAssetId(e) {
    this._data.baseAssetId = e;
  }
  get state() {
    return this._data.state;
  }
  get size() {
    return this._data.size;
  }
  set size(e) {
    this._data.size = e;
  }
  get md5() {
    return this._data.md5;
  }
  set defaultScheduledDeletionDuration(e) {
    this._data.defaultScheduledDeletionDuration = e;
  }
  get defaultScheduledDeletionDuration() {
    return this._data.defaultScheduledDeletionDuration;
  }
  set scheduledDeletionDate(e) {
    this._data.scheduledDeletionDate = e;
  }
  get scheduledDeletionDate() {
    return this._data.scheduledDeletionDate;
  }
  get assetType() {
    return this._data.assetType;
  }
  set assetType(e) {
    this._data.assetType = e;
  }
  get assetSubType() {
    return this._data.assetSubType;
  }
  set assetSubType(e) {
    this._data.assetSubType = e;
  }
  get representations() {
    return this._data.representations;
  }
  get contributors() {
    return this._data.contributors;
  }
  get les() {
    return this._data.les;
  }
  set width(e) {
    this._data.width = e;
  }
  get width() {
    return this._data.width;
  }
  set length(e) {
    this._data.length = e;
  }
  get length() {
    return this._data.length;
  }
  fetchLinksIfMissing(e = [], s) {
    return V("fetchLinksIfMissing()"), po(this.serviceConfig, this, e, void 0, s).then(({ result: r, response: n }) => (this._updateDataWithResponse(n), this));
  }
  useLinkOrResolveResource(e, s) {
    return V("useLinkOrResolveResource()"), uo(this.serviceConfig, this, e, s).then((r) => (this._updateDataWithResponse(r.response), this.setLinks(he(this.links, r.result.links)), r));
  }
  headPrimaryResource(e) {
    return V("headPrimaryResource()"), this.fetchLinksIfMissing([u.PRIMARY], e).then(() => Zn(this.serviceConfig, this, e)).then((s) => (this._updateDataWithResponse(s), s));
  }
  getRepresentation(e) {
    return this._data.representations ? this._data.representations[e] : void 0;
  }
  getRepoMetadata() {
    return V("getRepoMetadata()"), this.useLinkOrResolveResource(u.REPO_METADATA, "json").then((e) => {
      this._data = he(this._data, e.result, se(e.response.response));
      const s = e.response.response;
      return s && s._links && this.setLinks(he(this.links, s._links)), { result: this._data, response: e.response };
    });
  }
  updateRepoMetadata(e) {
    return V("updateRepoMetadata()"), this.fetchLinksIfMissing([u.REPO_METADATA], e).then(() => eo(this._svc, this, e));
  }
  headAppMetadata(e) {
    return V("headAppMetadata()"), this.fetchLinksIfMissing([u.APP_METADATA], e).then(() => so(this.serviceConfig, this));
  }
  getAppMetadata(e, s) {
    return V("getAppMetadata()"), E(["etag", e, "string", !0]), this.fetchLinksIfMissing([u.APP_METADATA], s).then(() => ro(this._svc, this, e, s));
  }
  putAppMetadata(e, s, r) {
    return V("putAppMetadata()"), E(["etag", s, "string", !0], ["metadata", e, ["object", "string"]]), this.fetchLinksIfMissing([u.APP_METADATA], r).then(() => no(this._svc, this, e, s, r));
  }
  patchAppMetadata(e, s, r) {
    return V("patchAppMetadata()"), E(["patchDoc", e, ["string", "object[]"]], ["etag", s, "string"]), this.fetchLinksIfMissing([u.APP_METADATA], r).then(() => oo(this._svc, this, e, s, r));
  }
  getBaseDirectoryMetadata() {
    return V("getBaseDirectoryMetadata()"), Ec(this._svc);
  }
  getLinks(e) {
    return V("getLinks()"), S(this.links) && Object.keys(this.links).length > 0 ? C.resolve(this.links) : Qn(this._svc, this, e).then((s) => (this.setLinks(s), s));
  }
  getRepositoryResource(e) {
    return V("getRepositoryResource()"), this.fetchLinksIfMissing([u.REPOSITORY], e).then(() => to(this._svc, this, e)).then((s) => (this.repositoryId = s.result["repo:repositoryId"], s));
  }
  getEffectivePrivileges(e) {
    return V("getEffectivePrivileges()"), this.fetchLinksIfMissing([u.EFFECTIVE_PRIVILAGES], e).then(() => io(this._svc, this));
  }
  performBulkRequest(e, s, r) {
    return V("performBulkRequest()"), E(["requests", e, "array"], ["linkMode", s, "string", !0, ["id", "path"]]), this.fetchLinksIfMissing([u.BULK_REQUEST], r).then(() => os(this._svc, this, e, s, r));
  }
  getACLPolicy(e) {
    return V("getACLPolicy()"), this.fetchLinksIfMissing([u.ACL_POLICY], e).then(() => ao(this._svc, this));
  }
  checkACLPrivilege(e, s, r) {
    return V("checkACLPrivilege()"), E(["privilege", e, "string"], ["relation", s, "string"]), this.fetchLinksIfMissing([u.ACCESS_CHECK], r).then(() => co(this._svc, this, e, s));
  }
  patchACLPolicy(e, s, r) {
    return V("patchACLPolicy()"), E(["policy", e, ["string", "object"]]), this.fetchLinksIfMissing([u.ACL_POLICY], r).then(() => ho(this._svc, this, e, s));
  }
  deleteACLPolicy(e) {
    return V("deleteACLPolicy()"), this.fetchLinksIfMissing([u.ACL_POLICY], e).then(() => lo(this._svc, this));
  }
  getPrimaryResource(e, s) {
    V("getPrimaryResource()"), E(["responseType", e, "string"]);
    const r = {};
    return this._withSourcePromise(r).then(() => this.fetchLinksIfMissing([u.PRIMARY], s)).then(() => Xn.call(r, this._svc, this, e, s));
  }
  copy(e, s, r, n, o) {
    return V("copy()"), E(["destination", e, ["object", "string"]], ["createIntermediates", s, "boolean"], ["overwriteExisting", r, "boolean"], ["manifestPatch", o, ["object", "string"], !0]), xn(this.serviceConfig, { repositoryId: this.repositoryId, assetId: this.assetId, path: this.path }, e, s, r, n, o).then(({ response: i, result: a }) => ({ response: i, result: new vt(a, this.serviceConfig) }));
  }
  copyResources(e, s, r, n, o) {
    return V("copyResources()"), E(["targetAsset", e, "object"], ["resources", s, "array"], ["manifestPatch", n, ["object", "string"], !0], ["intermediates", r, "boolean", !0]), $n(this.serviceConfig, { repositoryId: this.repositoryId, assetId: this.assetId, path: this.path, version: this.version }, e, s, r, n, o);
  }
  move(e, s, r, n) {
    return V("move()"), E(["destination", e, ["object", "string"]], ["createIntermediates", s, "boolean"], ["overwriteExisting", r, "boolean"]), Bn(this.serviceConfig, { repositoryId: this.repositoryId, assetId: this.assetId, path: this.path }, e, s, r, n).then(({ response: o, result: i }) => (this._data = Object.assign(Object.assign({}, this._data), w(i)), { response: o, result: this }));
  }
  delete(e, s = !1, r) {
    return V("delete()"), E(["etag", e, "string", !0], ["recursive", s, "boolean"]), Vn(this.serviceConfig, { repositoryId: this.repositoryId, assetId: this.assetId, path: this.path }, e, s, r).then((n) => (this._data.state = "DELETED", n));
  }
  discard(e, s = !1, r) {
    return V("discard()"), E(["etag", e, "string", !0], ["recursive", s, "boolean"]), jn(this.serviceConfig, { repositoryId: this.repositoryId, assetId: this.assetId, path: this.path }, e, s, r).then((n) => (this._data.state = "DISCARDED", n));
  }
  package(e, s, r, n) {
    return V("package()"), E(["destination", e, ["object", "string"]], ["createIntermediates", s, "boolean"], ["overwriteExisting", r, "boolean"]), Hn(this._svc, { repositoryId: this.repositoryId, assetId: this.assetId, path: this.path }, e, s, r, n);
  }
  restore(e) {
    return V("restore()"), Fn(this._svc, { repositoryId: this.repositoryId, assetId: this.assetId }, e).then(({ response: s, result: r }) => (this._data = Object.assign(Object.assign(Object.assign({}, this._data), w(r)), { state: "ACTIVE" }), { response: s, result: this }));
  }
  _updateDataWithResponse(e) {
    return e && (this._data.etag = e.headers.etag || this._data.etag, this._data.version = e.headers.version || this._data.version, this._data.assetId = e.headers["asset-id"] || this._data.assetId, this._data.md5 = e.headers["content-md5"] || this._data.md5, this._data.repositoryId = e.headers["repository-id"] || this._data.repositoryId, e);
  }
  _withSourcePromise(e) {
    return C.resolve(void 0, e);
  }
}
function Xn(t, e, s, r) {
  V("getPrimaryResource()"), E(["svc", t, "object"], ["asset", e, "object"], ["responseType", s, "enum", !0, tr]), F(e.links, [u.PRIMARY]);
  const n = H(e.links, u.PRIMARY);
  return ir.call({}, t, e, n, u.PRIMARY, s, void 0, void 0, r);
}
function Zn(t, e, s) {
  V("headPrimaryResource()"), E(["svc", t, "object"], ["asset", e, "object"]), F(e.links, [u.PRIMARY]);
  const r = H(e.links, u.PRIMARY);
  return U(t).invoke(O.HEAD, r, s, void 0, { isStatusValid: N() }).then((n) => {
    const o = Ee(n);
    e.links = he(e.links || {}, o);
    const i = ne(t);
    return i && i.setValueWithAsset(e.links || {}, e), n;
  });
}
const hc = "/content/directory/resolve{?repositoryId,id,resource,mode}", lc = "/content/directory/resolve{?repositoryId,path,resource,mode}";
function uc(t, e, s = "id", r, n) {
  Y("getResolveLinkForAsset()"), E(["svc", t, "object"], ["asset", e, "object"], ["mode", s, "enum", !1, ["id", "path"]], ["resource", r, ["string", "object"], !0]), Dn(e);
  const o = { repositoryId: e.repositoryId, id: e.assetId, path: e.path, mode: s, resource: S(r) ? JSON.stringify(r) : r }, i = U(t), a = qe(e.assetId ? hc : lc, i);
  return C.resolve(Ve(a, w(o)));
}
const pc = "/content/create/~/:create{?path,mode,intermediates,respondWith,repoMetaPatch*}", _c = "/content/create/~/:block_upload";
function cr(t, e, s = "id", r, n, o) {
  Y("resolveAsset()"), E(["svc", t, "object"], ["asset", e, "object"], ["mode", s, "enum", !0, ["id", "path"]], ["resource", r, ["string", "object"], !0]), Dn(e);
  const i = U(t), a = ne(t), d = a && e.assetId && e.repositoryId && s === "id";
  return d && (Y("rA() set pending"), a.setPending(e.assetId, e.repositoryId)), uc(t, e, s, r).then((h) => r == null ? sr(i, h, o) : Ka(i, h, o, n)).then((h) => ({ response: h, result: fo(e, h, s === "id", a) })).catch((h) => {
    throw d && a.deleteWithAsset(e), h;
  });
}
function fc(t, e, s) {
  return Y("fetchLinksForAsset()"), Jn(t, e, s).then((r) => r.result.links);
}
function Jn(t, e, s) {
  if (Y("fetchAsset()"), E(["svc", t, "object"], ["asset", e, "object"]), Qs(e)) return cr(t, e, "id", void 0, void 0, s).then((a) => a);
  let r;
  try {
    r = Cn(e.links, [u.ID, u.REPO_METADATA, u.PRIMARY, u.PATH]);
  } catch (a) {
    throw new c(c.INVALID_PARAMS, "Asset is not resolvable. Must contain repositoryId & path, assetId, or links.", a);
  }
  const n = H(e.links, r), o = U(t), i = ne(t);
  return o.invoke(O.HEAD, n, s, void 0, { isStatusValid: N() }).then((a) => ({ result: fo(e, a, r === u.ID, i), response: a }));
}
function Qn(t, e, s) {
  Y("getLinksForAsset()"), E(["svc", t, "object"], ["asset", e, "object"]);
  const r = e.links || e[T.LINKS];
  if (S(r) && Object.keys(r).length !== 0) return C.resolve(r);
  const n = ne(t);
  if (n) {
    const o = n.getValueWithAsset(e);
    if (o) return C.resolve(o);
  }
  return fc(t, e, s);
}
function eo(t, e, s) {
  Y("updateRepoMetadata()"), E(["svc", t, "object"], ["asset", e, "object"]), F(e.links, [u.REPO_METADATA]);
  const r = H(e.links, u.REPO_METADATA), n = Object.assign({ [R.CONTENT_TYPE]: ct }, s), o = Xa(e);
  return t.invoke(O.PATCH, r, n, JSON.stringify(o), { responseType: "json", isStatusValid: N() }).then((i) => ({ result: i.response, response: i }));
}
function Ec(t, e) {
  throw Y("getBaseDirectoryMetadata()"), new c(c.NOT_IMPLEMENTED, "Method not implemented.");
}
function to(t, e, s) {
  Y("getRepositoryResource()"), E(["svc", t, "object"], ["asset", e, "object"]), F(e.links, [u.REPOSITORY]);
  const r = H(e.links, u.REPOSITORY);
  return t.invoke(O.GET, r, s, void 0, { responseType: "json", isStatusValid: N() }).then((n) => ({ result: n.response, response: n }));
}
function so(t, e, s) {
  V("headAppMetadata()"), E(["svc", t, "object"], ["asset", e, "object"]), F(e.links, [u.APP_METADATA]);
  const r = H(e.links, u.APP_METADATA);
  return U(t).invoke(O.HEAD, r, s, void 0, { isStatusValid: N() }).then((n) => {
    const o = Ee(n);
    e.links = he(e.links || {}, o);
    const i = ne(t);
    return i && i.setValueWithAsset(e.links, e), n;
  });
}
function ro(t, e, s, r = {}) {
  Y("getAppMetadata()"), E(["svc", t, "object"], ["asset", e, "object"], ["etag", s, "string", !0]);
  const n = H(e.links, u.APP_METADATA), o = Object.assign({}, r);
  return s && (o[R.IF_NONE_MATCH] = s), t.invoke(O.GET, n, o, void 0, { responseType: "json", isStatusValid: N([304]) }).then((i) => {
    let a = i.response, d = i.headers.etag;
    return i.statusCode === 304 && (a = null, d = s), { result: a, response: i, etag: d };
  });
}
function no(t, e, s, r, n = {}) {
  Y("putAppMetadata()"), E(["svc", t, "object"], ["asset", e, "object"], ["metadata", s, ["object", "string"]], ["etag", r, "string", !0]), F(e.links, [u.APP_METADATA]);
  const o = H(e.links, u.APP_METADATA);
  return t.invoke(O.PUT, o, w(Object.assign(n, { [R.IF_MATCH]: r, [R.CONTENT_TYPE]: $a })), typeof s == "string" ? s : JSON.stringify(s), { isStatusValid: N() }).then((i) => ({ response: i, result: { etag: i.headers.etag } }));
}
function oo(t, e, s, r, n = {}) {
  Y("patchAppMetadata()"), E(["svc", t, "object"], ["asset", e, "object"], ["metadata", s, ["object[]", "string"]], ["etag", r, "string"]), F(e.links, [u.APP_METADATA]);
  const o = H(e.links, u.APP_METADATA);
  return t.invoke(O.PATCH, o, w(Object.assign(n, { [R.IF_MATCH]: r, [R.CONTENT_TYPE]: ct })), typeof s == "string" ? s : JSON.stringify(s), { isStatusValid: N() }).then((i) => ({ response: i, result: { etag: i.headers.etag } }));
}
function io(t, e, s) {
  Y("getEffectivePrivileges()"), E(["svc", t, "object"], ["asset", e, "object"]), F(e.links, [u.EFFECTIVE_PRIVILAGES]);
  const r = H(e.links, u.EFFECTIVE_PRIVILAGES);
  return t.invoke(O.GET, r, s, void 0, { responseType: "json", isStatusValid: N() }).then((n) => ({ result: n.response, response: n }));
}
function ao(t, e, s) {
  Y("getACLPolicy()"), E(["svc", t, "object"], ["asset", e, "object"]), F(e.links, [u.ACL_POLICY]);
  const r = H(e.links, u.ACL_POLICY);
  return t.invoke(O.GET, r, s, void 0, { responseType: "json", isStatusValid: N() }).then((n) => ({ result: n.response, response: n }));
}
function co(t, e, s, r, n = {}) {
  Y("checkACLPrivilege()"), E(["svc", t, "object"], ["asset", e, "object"], ["privilege", s, "string", !1, ["ack", "read", "write", "delete"]]), F(e.links, [u.ACCESS_CHECK]);
  const o = Z(e.links, u.ACCESS_CHECK, { privilege: s.toString(), relation: r });
  return t.invoke(O.GET, o, Object.assign({ directive: "acl-check-no-body" }, n), void 0, { responseType: "json", isStatusValid: N([403]) }).then((i) => ({ result: i.statusCode !== 403, response: i }));
}
function ho(t, e, s, r, n = {}) {
  Y("patchACLPolicy()"), E(["svc", t, "object"], ["asset", e, "object"], ["policy", s, ["string", "object"]], ["etag", r, "string", !0]), F(e.links, [u.ACL_POLICY]);
  const o = w(Object.assign(n, { [R.CONTENT_TYPE]: ct, [R.IF_MATCH]: r })), i = H(e.links, u.ACL_POLICY);
  return U(t).invoke(O.PATCH, i, o, typeof s == "string" ? s : JSON.stringify(s), { responseType: "json", isStatusValid: N() }).then((a) => ({ result: a.response, response: a }));
}
function lo(t, e, s = {}) {
  Y("deleteACLPolicy()"), E(["svc", t, "object"], ["asset", e, "object"]), F(e.links, [u.ACL_POLICY]);
  const r = H(e.links, u.ACL_POLICY);
  return U(t).invoke(O.DELETE, r, s, void 0, { responseType: "json", isStatusValid: N() }).then((n) => ({ result: n.response, response: n }));
}
function uo(t, e, s, r, n) {
  Y("useLinkOrResolveResource()"), E(["svc", t, "object"], ["asset", e, "object"], ["resource", s, "string"]);
  const o = U(t);
  let i;
  try {
    i = H(e.links, s);
  } catch {
  }
  return C.resolve(i).then((a) => {
    if (typeof a == "string") return Y("uLORR() asset has link"), a;
    const d = ne(t);
    return _o(e, d, [s]);
  }).then((a) => {
    if (typeof a == "string") return a;
    try {
      return H(a, s);
    } catch {
      return;
    }
  }).then((a) => {
    if (typeof a == "string") return Y("uLORR() cache or asset had link"), o.invoke(O.GET, a, n, void 0, { isStatusValid: N(), responseType: r });
    if (!Qs(e)) throw new c(c.INVALID_PARAMS, "Asset is not resolvable. Must contain repository ID + path/id or links.");
    return cr(t, e, "id", s, r, n);
  }).then((a) => bn(a) ? a : { result: e, response: a });
}
function dt(t, e, s = [], r = !1, n) {
  return po(t, e, s, r, n).then(({ result: o }) => o);
}
const gc = /* @__PURE__ */ new Set([u.BASE_DIRECTORY, u.RESOLVE_BY_ID, u.RESOLVE_BY_PATH, u.REPO_OPS, u.REPOSITORY, u.DIRECTORY, u.DISCARD, u.RESTORE, u.PATH, u.ANNOTATIONS]), Ic = "/links{?assetId,repositoryId,clientRegion}";
function Tc(t, e, s) {
  const r = function(n, o) {
    Y("getLinksAPIUrlForAsset()"), E(["svc", n, "object"], ["asset", o, "object"]);
    const i = U(n), a = qe(Ic, i), { assetId: d, repositoryId: h, contentRegion: l } = o, p = w({ assetId: d, repositoryId: h, contentRegion: l });
    return Ve(a, p);
  }(t, e);
  return U(t).invoke(O.GET, r, s, void 0, { responseType: "json" }).then((n) => {
    const o = ne(t);
    return e.links = Object.assign({}, e.links, n.response._links), o == null || o.setValueWithAsset(e.links, e), { response: n, result: e };
  });
}
function po(t, e, s = [], r = !1, n) {
  if (Y("fetchLinksIfMissing()", s), E(["svc", t, "object"], ["asset", e, "object"], ["linksToPopulate", s, "string[]"], ["suppressMissingErrors", r, "boolean", !0]), at(e.links, s)) return Y("fLIM() links exist"), C.resolve({ result: e.links });
  const o = ne(t);
  return _o(e, o, s, !0).then((i) => i || (function(a, d) {
    return typeof a.assetId == "string" && a.assetId.length > 0 && d.every((h) => !gc.has(h));
  }(e, s) ? Tc(t, e, n) : (Y("fLIM() fetching links"), Jn(t, e, n)))).then((i) => {
    let a, d, h = i;
    if (bn(i) && (a = i.response, h = i.result.links, d = i.result), e.links !== h) {
      e.links = he(e.links || {}, h);
      const l = ne(t);
      l && l.setValueWithAsset(e.links, e);
    }
    if (!r && !at(h, s)) throw new c(c.INVALID_PARAMS, "Required links could not be fetched for asset.", void 0, a, w({ required: s, asset: d }));
    return Y("fLIM() fetchedOCached exists"), { result: h || e.links, response: a };
  });
}
function _o(t, e, s, r) {
  if (Y("getLinksFromCache()"), !e) return C.resolve(void 0);
  const n = e.getValueWithAsset(t);
  return n == null ? (r && e.setPending(t.assetId, t.repositoryId), C.resolve(void 0)) : C.resolve(n).then((o) => s ? at(o, s) ? o : void (r && e.setPending(t.assetId, t.repositoryId)) : o);
}
function Ac(t, e, s, r, n, o, i) {
  return $n(t, e, s, r, n, o, i);
}
function fo(t, e, s, r) {
  const n = Ee(e), o = Object.assign(Object.assign(Object.assign({}, function(i) {
    return S(i.asset) ? i.asset : i;
  }(t)), w({ assetId: e.headers["asset-id"] || e.headers["x-resource-id"], format: e.headers[R.CONTENT_TYPE], md5: e.headers["content-md5"], etag: e.headers.etag, version: e.headers.version, repositoryId: e.headers["repository-id"] })), { links: n });
  return s && n && Object.keys(n).length > 0 && r && r.setValueWithAsset(n, o), o;
}
x("dcx:assets:block_transfer");
const is = 10485760, mc = 52428800, yc = is / 4;
let Eo = mc;
function dr(t, e) {
  const s = function(n) {
    return go(n, B.REPO_MIN_BLOCK_TRANSFER_SIZE);
  }(t);
  if (s && e < s) return !1;
  const r = vc(t);
  return !!(r && e > r) || e > is;
}
function go(t, e) {
  if (!at(t.links, [u.BLOCK_UPLOAD_INIT])) return;
  const s = Qt(t.links, u.BLOCK_UPLOAD_INIT, e);
  return s ? parseInt(s) : void 0;
}
function vc(t) {
  return go(t, B.MAX_SINGLE_TRANSFER_SIZE);
}
const xe = (t) => typeof t == "string" ? t.length >= yc ? Ie(t).byteLength : t.length : "size" in t ? t.size : t.byteLength, Je = (t, e) => {
  if (!q(t)) return t;
  if (t.length < 2) throw new c(c.INVALID_PARAMS, "GetSliceCallback is expected to accept 2 parameters");
  if (e === void 0 || isNaN(e) || e < 0) throw new c(c.INVALID_PARAMS, "Size parameter should indicate total number of bytes to be read from GetSliceCallback");
  return { getSlice: t, size: e };
}, Io = () => Eo, bc = (t) => {
  if (Number.isNaN(t) || typeof t != "number" || t <= 0) throw new c(c.INVALID_PARAMS, "Invalid block download threshold, must be positive integer");
  Eo = t;
};
function Rc(t, e, s, r) {
  const n = Ys(r);
  return { id: e, length: s, type: t, links: nr(n.link), etag: n.etag, location: n.location, version: n.version, revision: n.revision, md5: n["content-md5"] };
}
const L = x("dcx:assets:blockupload"), Oc = x("dcx:assets:blockupload:leaf");
class Pc extends $s {
  constructor(e, s, r, n, o, i, a, d, h, l, p, _, f, A) {
    super(["stateChanged"]), this._internalBlockUploadId = zt(), this._state = g.NOT_INITIALIZED, this._currentBlockIndex = 0, this._pendingBlockRequests = /* @__PURE__ */ new Map(), this._bytesUploaded = 0, this._indeterminateTransfer = !1, this._maxConcurrentRequests = 4, this._retryQueue = /* @__PURE__ */ new Set(), this._activeBlockIndex = 0, this._lastExtendTime = 0, this._uploadedBlocksURLs = [], this._service = e, this._getSliceCallback = s, Fa(r) ? (E([B.REPO_SIZE, r[B.REPO_SIZE], "number"]), this._blockTransferDocument = r, this._transferBlockLinks = this._blockTransferDocument[T.LINKS][u.BLOCK_TRANSFER], this._dataSize = this._blockTransferDocument[B.REPO_SIZE], this._relationType = this._blockTransferDocument[B.REPO_REL_TYPE], this._shiftState(g.INITIALIZED), L(`BlockUpload Initialized: Transfer document found with ${this._transferBlockLinks.length} links. BlockUploadId: ${this._internalBlockUploadId}`)) : (E(["relationType", n, "string"], ["dataSize", o, "number"], ["contentType", i, "string"], ["componentId", a, "string", !0], ["etag", h, "string", !0]), this._asset = r, F(this._asset.links, [u.BLOCK_UPLOAD_INIT], c.UNEXPECTED, "/rel/block/init missing from BlockTransferDocument."), this._relationType = n, this._dataSize = o, this._contentType = i, this._componentId = a, this._md5 = d, this._ifMatch = h), this._relPath = l, this._createIntermediates = p, this._respondWith = _, this._repoMetaPatch = f, this._maxConcurrentRequests = A || 4, this._promise = new C((y, b) => {
      this._reject = b, this._resolve = y;
    }), ce.uploads.push(this);
  }
  init(e) {
    if (this._assertStateIsValid("init"), !this._blockTransferDocument || !this._blockTransferDocument[T.LINKS]) {
      this._shiftState(g.INITIALIZING);
      const s = w(Object.assign({ [B.REPO_REL_TYPE]: this._relationType, [B.REPO_IF_MATCH]: this._ifMatch, [B.REPO_SIZE]: this._dataSize, [B.DC_FORMAT]: this._contentType, [B.COMPONENT_ID]: this._componentId, [B.REPO_MD5]: this._md5 }, this._blockTransferDocument));
      return hr(this._service, this._asset, s, e).then((r) => (this._blockTransferDocument = r.result, this._transferBlockLinks = this._blockTransferDocument[T.LINKS][u.BLOCK_TRANSFER], this._shiftState(g.INITIALIZED), L(`BlockUpload Initialized: Transfer document found with ${this._transferBlockLinks.length} links. BlockUploadId: ${this._internalBlockUploadId}`), this));
    }
    return C.resolve(this);
  }
  get state() {
    return this._state;
  }
  get promise() {
    return this._promise;
  }
  start() {
    return this._assertStateIsValid("start"), ce.uploads[0] !== this || this._state !== g.INITIALIZED && this._state !== g.PAUSED || (L(`Starting the transfer of BlockUpload: ${this._internalBlockUploadId}`), this._shiftState(g.STARTED), this._uploadLoop()), this._promise;
  }
  pause() {
    return this._assertStateIsValid("pause"), this._shiftState(g.PAUSING), C.allSettled([...this._pendingBlockRequests.values()]).then(() => (this._shiftState(g.PAUSED), L(`BlockUploading has been paused.  BlockUploadId: ${this._internalBlockUploadId}`), this));
  }
  resume() {
    return this._assertStateIsValid("resume"), L(`BlockUploading has been resumed.  BlockUploadId: ${this._internalBlockUploadId}`), this.start(), this;
  }
  cancel() {
    this._assertStateIsValid("cancel"), this._shiftState(g.CANCELED), L(`A BlockUpload has been canceled... BlockUploadId: ${this._internalBlockUploadId}`), this._promise.cancel(), this._cancel();
  }
  _setWaiting() {
    this._shiftState(g.WAITING);
  }
  uploadNextBlock(e) {
    if (this._assertStateIsValid("uploadNextBlock"), this._isEmptyBlock(e)) throw new c(c.INVALID_PARAMS, "Trying to upload empty data block.");
    const s = this._activeBlockIndex, r = Date.now(), n = this._blockTransferDocument[T.LINKS][u.BLOCK_TRANSFER][s].href;
    let o;
    L(`Uploading a block... BlockUploadId: ${this._internalBlockUploadId}`);
    const i = xe(e), a = this._uploadBlock(e, n).then((d) => (this._uploadedBlocksURLs[s] = { href: n }, this._updateProgress(i), o(), L(`A block has completed... ${this._pendingBlocksCount} requests still active. BlockUploadId: ${this._internalBlockUploadId}`), d)).catch((d) => (o(), this._isTransferUrlExpiredError(d) ? (L(`A block with index as ${s} has FAILED due to Transfer Expiry!! ${this._pendingBlocksCount} requests still active. BlockUploadId: ${this._internalBlockUploadId}`), this._retryQueue.add(s), r <= this._lastExtendTime ? (L(`Skipping extend for block ${s}  request started after last extend.`), this._maybePauseForRetry().then(() => C.reject(g.PAUSED))) : this._maybeExtendWithPauseResume().catch((h) => (L(`Extend flow failed for block ${s}`, h), C.reject(h)))) : (L(`A block upload has failed. BlockUploadId: ${this._internalBlockUploadId}`), this._shiftState(g.ERROR), this._reject(new c(c.UNEXPECTED_RESPONSE, "A block has failed during upload", d, d.response)), this.cancel(), C.reject(d))));
    return o = this._pushPendingBlockRequest(s, a), a;
  }
  get _pendingBlocksCount() {
    return ce.pendingUploadRequests.filter((e) => !!e).length;
  }
  _nextBlockLock() {
    return this._pendingBlocksCount < this._maxConcurrentRequests ? Promise.resolve() : Promise.race(ce.pendingUploadRequests.filter((e) => !!e));
  }
  _handleAssetMoved(e) {
    throw L("_handleAssetMoved"), this._pendingBlockRequests.forEach((s) => {
      s.abort();
    }), this._pendingBlockRequests.clear(), this._uploadedBlocksURLs.length = 0, this._transferBlockLinks.length = 0, this._asset.links = Object.assign(Object.assign({}, this._asset.links), Ee(e.response)), this._retryQueue.clear(), this._activeBlockIndex = 0, this._lastExtendTime = 0, this._currentBlockIndex = 0, this._bytesUploaded = 0, this._state = g.NOT_INITIALIZED, this._blockTransferDocument[T.LINKS] = void 0, this.init().then(() => this.start()), g.INITIALIZING;
  }
  _getNextUploadBlockData() {
    if (this._retryQueue.size > 0) {
      const [e] = this._retryQueue;
      this._retryQueue.delete(e), this._activeBlockIndex = e;
    } else this._activeBlockIndex = this._currentBlockIndex;
    return this._getBlockAtIndex(this._activeBlockIndex);
  }
  _uploadLoop() {
    this._nextBlockLock().then(() => {
      if (this._state === g.FINALIZING || this._state === g.COMPLETE) throw g.COMPLETE;
      if (this._state === g.PAUSING || this._state === g.PAUSED) throw g.PAUSED;
      if (this._state === g.CANCELED) throw g.CANCELED;
      if (this._state === g.ERROR) throw g.ERROR;
    }).then(() => this._getNextUploadBlockData()).then((e) => this._isEmptyBlock(e) ? (L(`No more blocks.  BlockUploadId: ${this._internalBlockUploadId}`), Promise.all([...this._pendingBlockRequests.values()]).then(this._finalize.bind(this))) : e && xe(e) > 0 && this._activeBlockIndex >= this._transferBlockLinks.length ? this._extend().then(() => e) : e).then((e) => {
      if (!e) throw g.COMPLETE;
      this.uploadNextBlock(e), this._activeBlockIndex === this._currentBlockIndex && this._currentBlockIndex++;
    }).then(() => {
      this._uploadLoop();
    }).catch((e) => {
      if (typeof e != "string" && (this._continueBlockUploads(), this._reject(e)), e !== g.INITIALIZING) if (e !== g.COMPLETE) {
        if (e !== g.PAUSED) return e === g.CANCELED ? (L(`BlockUpload loop is terminated due to the upload being canceled. BlockUploadId: ${this._internalBlockUploadId}`), void this._continueBlockUploads()) : e === g.ERROR ? (L(`BlockUpload loop is terminated due to error state. BlockUploadId: ${this._internalBlockUploadId}`), void this._continueBlockUploads()) : void 0;
        L(`BlockUpload loop is terminated due to paused state. BlockUploadId: ${this._internalBlockUploadId}`);
      } else L(`BlockUpload loop is complete. BlockUploadId: ${this._internalBlockUploadId}`);
      else L(`BlockUpload loop must be re-started due to assetmoved BlockUploadId: ${this._internalBlockUploadId}`);
    });
  }
  _getBlockAtIndex(e) {
    L(`_getBlockAtIndex(${e})`);
    const s = Math.min(this._dataSize, this._blockTransferDocument[B.REPO_BLOCK_SIZE]);
    if (this._state === g.STARTED) {
      const r = e * s;
      return L("calling _getSliceCallback", r, r + s), this._getSliceCallback(r, r + s).catch((n) => {
        throw new c(c.UNEXPECTED_RESPONSE, "The getSliceCallback threw an unexpected error.", n);
      });
    }
  }
  _uploadBlock(e, s) {
    return this._service.invoke(O.PUT, s, void 0, e, { isStatusValid: N(), isExternalRequest: !0 });
  }
  _isEmptyBlock(e) {
    return typeof e == "string" ? e.length === 0 : ja(e) ? e.size === 0 : !e || e.byteLength === 0;
  }
  _extend(e = !0) {
    F(this._blockTransferDocument[T.LINKS], [u.BLOCK_EXTEND], c.UNEXPECTED, "The transfer document does not contain an extend href");
    const s = this._blockTransferDocument[B.REPO_SIZE], r = e ? Math.ceil(1.5 * s) : s, n = Z(this._blockTransferDocument[T.LINKS], u.BLOCK_EXTEND, { size: r });
    return this._service.invoke(O.POST, n, {}, void 0, { isStatusValid: N(), responseType: "json" }).then((o) => (this._indeterminateTransfer = !0, this._blockTransferDocument = o.response, this._transferBlockLinks = this._blockTransferDocument[T.LINKS][u.BLOCK_TRANSFER], L(`Transfer document extended (${e ? "size increased" : "URL refresh only"}): ${this._transferBlockLinks.length} transfer links. BlockUploadId: ${this._internalBlockUploadId}`), o)).catch((o) => {
      throw it(o) && o.problemType === X.ASSET_MOVED && this._handleAssetMoved(o), new c(c.UNEXPECTED_RESPONSE, "An unexpected error occurred while extending the block transfer document.", o, o.response);
    });
  }
  _maybeExtendWithPauseResume() {
    if (this._extendPromise) return L("Reusing in-progress extend (with pause/resume)"), C.reject(g.PAUSED);
    L("[_maybeExtendWithPauseResume] Setting state to PAUSED and triggering extend"), this._shiftState(g.PAUSED);
    const e = C.resolve().then(() => (L("[_maybeExtendWithPauseResume] Pause done, calling _extend()"), this._extend(!1))).then((s) => (this._lastExtendTime = Date.now(), L("[_maybeExtendWithPauseResume] Extend done, calling resume()"), C.resolve(this.resume()).then(() => (L("[_maybeExtendWithPauseResume] Resume done"), s))));
    return this._extendPromise = e.finally(() => {
      this._extendPromise = void 0;
    }), C.reject(g.PAUSED);
  }
  _maybePauseForRetry() {
    return this._state === g.PAUSED || this._state === g.PAUSING ? (L("[_maybePauseForRetry] Already in PAUSED or PAUSING state  skipping."), C.resolve()) : (L("[_maybePauseForRetry] Shifting to PAUSED state to trigger retry mechanism."), this._shiftState(g.PAUSED), L("[_maybePauseForRetry] Calling resume() to restart upload loop for retries."), this.resume(), C.resolve());
  }
  _isTransferUrlExpiredError(e) {
    var s, r;
    const n = (s = e == null ? void 0 : e.response) === null || s === void 0 ? void 0 : s.statusCode, o = e == null ? void 0 : e.code, i = ((r = e == null ? void 0 : e.response) === null || r === void 0 ? void 0 : r.response) || "";
    return L(`[TransferExpiryCheck] StatusCode: ${n}`), L(`[TransferExpiryCheck] Code: ${o}`), L(`[TransferExpiryCheck] RawResponse: ${i}`), !(n !== 403 && o !== "FORBIDDEN" || typeof i != "string" || !i.toLowerCase().includes("request has expired"));
  }
  _pushPendingBlockRequest(e, s) {
    this._pendingBlockRequests.set(e, s);
    const r = ce.pendingUploadRequests.push(s);
    return () => {
      this._pendingBlockRequests.delete(e), delete ce.pendingUploadRequests[r - 1];
    };
  }
  _updateProgress(e) {
    if (L("_updateProgress()", e), typeof e == "number" && (this._bytesUploaded += e), this.onProgress && q(this.onProgress)) try {
      this.onProgress(this._bytesUploaded, Math.max(this._blockTransferDocument[B.REPO_SIZE], this._bytesUploaded), this._indeterminateTransfer);
    } catch (s) {
      console.error("Error in onProgress callback", s);
    }
  }
  _cancel() {
    this._pendingBlockRequests.forEach((e) => {
      e == null || e.cancel();
    }), this._state !== g.ERROR && this._resolve(this);
  }
  _assertStateIsValid(e, s) {
    const r = s || this._state;
    switch (e) {
      case "init":
        if (r !== g.NOT_INITIALIZED && r !== g.INITIALIZED) throw new c(c.INVALID_STATE, "BlockUpload has already been initialized");
        break;
      case "start":
        if (r === g.NOT_INITIALIZED) throw new c(c.INVALID_STATE, "Please call init before starting the block upload");
        break;
      case "uploadNextBlock":
        if (r === g.PAUSED || r === g.CANCELED) throw new c(c.INVALID_STATE, "Cannot add block when Paused or Cancelled");
        break;
      case "getBlockAtIndex":
        if (r !== g.STARTED) throw new c(c.INVALID_STATE, `Cannot fetch block while in the ${r} state`);
        break;
      case "cancel":
        if (r !== g.STARTED && r !== g.FINALIZING && r !== g.PAUSING && r !== g.PAUSED && r !== g.ERROR) throw new c(c.INVALID_STATE, `Trying to cancel while in an invalid state ${r}`);
    }
  }
  _continueBlockUploads() {
    if (L("continueBlockUploads()"), ce.uploads[0] === this) if (ce.uploads.shift(), ce.uploads.length > 0) {
      const e = ce.uploads[0];
      L("Another block upload found in the queue, starting..."), e.start();
    } else this._pendingBlocksCount === 0 && (L("There are no more pending block transfers.. Clean up blockUploadManager.."), ce.resetUploads());
  }
  _finalize() {
    L(`Finalizing block transfer.  BlockUploadId: ${this._internalBlockUploadId}`), this._shiftState(g.FINALIZING);
    const e = Z(this._blockTransferDocument[T.LINKS], u.BLOCK_FINALIZE, w({ path: this._relPath, intermediates: this._createIntermediates, respondWith: S(this._respondWith) ? JSON.stringify(this._respondWith) : this._respondWith, repoMetaPatch: this._repoMetaPatch }));
    return this._blockTransferDocument[T.LINKS][u.BLOCK_TRANSFER] = this._uploadedBlocksURLs, this._service.invoke(O.POST, e, { [R.CONTENT_TYPE]: Pn }, JSON.stringify(w(this._blockTransferDocument)), { isStatusValid: N(), retryOptions: { pollHeader: "location", pollCodes: [202], timeoutAfter: 12e4 }, responseType: "arraybuffer" }).then((s) => {
      if (s.statusCode === 200 || s.statusCode === 201) {
        L(`Finalize complete.  BlockUploadId: ${this._internalBlockUploadId}`);
        const r = ns(new Uint8Array(s.response));
        if (this._relationType === u.PRIMARY) {
          if (this.finalizeResponse = r, this.createdAsset = w({ assetId: r.headers["asset-id"], repositoryId: r.headers["repository-id"], links: nr(r.headers.link), etag: r.headers.etag, md5: r.headers["content-md5"] }), r.response && this._respondWith) try {
            const n = JSON.parse(ye(r.response));
            r.response = n, this.createdAsset = Ue(this.createdAsset, se(n));
          } catch (n) {
            throw new c(c.UNEXPECTED, "Unexpected error parsing respondWith parameter", n);
          }
        } else {
          this.finalizeResponse = s;
          try {
            this.uploadRecord = Rc(this._blockTransferDocument[B.DC_FORMAT], this._blockTransferDocument[B.COMPONENT_ID], this._bytesUploaded, ye(s.response));
          } catch (n) {
            throw new c(c.UNEXPECTED, "An error occurred while deserializing upload component record.", n, r);
          }
        }
        this._shiftState(g.COMPLETE), this._updateProgress(!0), this._resolve(this);
      }
      this._continueBlockUploads();
    }).catch((s) => {
      if (it(s)) switch (s.problemType) {
        case X.ASSET_MOVED:
          return void this._handleAssetMoved(s);
        case X.ASSET_NAME_CONFLICT:
          return L("Error occurred finalizing the block transfer due to asset name conflict.. Rejecting with ALREADY_EXISTS"), this._reject(new c(c.ALREADY_EXISTS, "Asset name conflict occurred during block transfer finalization.", s, s.response)), void this._continueBlockUploads();
      }
      L("Error occurred finalizing the block transfer.. Rejecting"), this._reject(new c(c.UNEXPECTED_RESPONSE, "An error occurred while finalizing the block transfer.", s, s.response)), this._continueBlockUploads();
    });
  }
  _shiftState(e) {
    return L(`_shiftState(): ${e}`), this._state === g.COMPLETE || this._state === g.ERROR || this._state === g.CANCELED || (this._state = e, this.emit("stateChanged", [this._state])), this;
  }
}
function hr(t, e, s, r = {}) {
  if (E(["svc", t, "object"], ["assetOrLink", e, ["object", "string"]], ["transferDocument", s, "object"], ["additionalHeaders", r, "object", !0]), Zt(e) && F(e.links, [u.BLOCK_UPLOAD_INIT]), s["repo:resource"]) {
    if (!s["repo:resource"].reltype) throw new c(c.INVALID_DATA, "reltype param is required in the Resource Designator");
    s[B.REPO_REL_TYPE] = s["repo:resource"].reltype, s["repo:resource"].component_id && (s[B.COMPONENT_ID] = s["repo:resource"].component_id), s["repo:resource"].etag && (s[B.REPO_IF_MATCH] = s["repo:resource"].etag), delete s["repo:resource"];
  }
  if (s[B.REPO_REL_TYPE] === u.COMPONENT && !s[B.COMPONENT_ID]) throw new c(c.INVALID_DATA, "Component Id required to block upload to a component");
  const n = Zt(e) ? H(e.links, u.BLOCK_UPLOAD_INIT) : e;
  r[R.CONTENT_TYPE] = Pn;
  const o = Ot(r);
  return o.priority = o.priority || "u=1", t.invoke(O.POST, n, o, JSON.stringify(s), { responseType: "json", isStatusValid: N() }).then((i) => ({ response: i, result: i.response }));
}
function To({ additionalHeaders: t, asset: e, componentId: s, contentType: r, dataOrSliceCallback: n, etag: o, maybeIsNew: i, md5: a, progressCb: d, relation: h, size: l, svc: p, blockSize: _, maxConcurrentRequests: f }) {
  Oc("_upload()"), E(["svc", p, "object"], ["asset", e, "object"], ["size", l, "number", !0], ["md5", a, "string", !0], ["etag", o, "string", !0]);
  const A = Je(n, l), y = xe(A), b = U(p);
  if (dr(e, y)) return bt({ asset: e, additionalHeaders: t, componentId: s, contentType: r, dataOrSliceCallback: n, etag: o, md5: a, progressCb: d, relation: h, size: l, service: b, blockSize: _, maxConcurrentRequests: f });
  F(e.links, [h]);
  const v = Z(e.links, h, { component_id: s });
  return C.resolve(void 0, { blockUpload: void 0, progress: d }).then(() => Promise.resolve(q(n) ? n(0, y) : n)).then((P) => Gt({ asset: e, additionalHeaders: t, contentType: r, data: P, etag: o, headHref: v, href: v, maybeIsNew: i, relation: h, service: b })).then((P) => {
    let m = {};
    try {
      m = Ee(P), e.links = he(e.links || {}, m);
      const D = ne(p);
      D && D.setValueWithAsset(e.links, e);
    } catch {
    }
    return { response: P, result: { revision: P.headers.revision || P.headers.version, location: P.headers.location, links: m, etag: P.headers.etag, version: P.headers.version || P.headers.revision, md5: P.headers.md5 || P.headers["content-md5"], length: y, type: r }, isBlockUpload: !1, asset: { assetId: e.assetId || P.headers["asset-id"], repositoryId: e.repositoryId || P.headers["repository-id"], links: e.links || m } };
  }).catch((P) => {
    throw P;
  });
}
function Ao({ service: t, asset: e, additionalHeaders: s, dataOrSliceCallback: r, contentType: n, progressCb: o, relation: i, size: a, componentId: d, md5: h, etag: l, relPath: p, createIntermediates: _, respondWith: f, blockSize: A, repoMetaPatch: y, maxConcurrentRequests: b }) {
  const v = q(r) ? r : function(m) {
    if (!q(m.slice)) throw new c(c.INVALID_PARAMS, "Data cannot be sliced");
    return function(D, k) {
      return re(this, void 0, void 0, function* () {
        return m.slice(D, k);
      });
    };
  }(r);
  e && F(e.links, [u.BLOCK_UPLOAD_INIT]);
  const P = hr(t, e || function(m) {
    V("getBlockUploadLinkForGuest"), E(["svc", m, "object"]);
    const D = U(m), k = qe(_c, D);
    return Ve(k, {});
  }(t), w({ [B.REPO_REL_TYPE]: i, [B.REPO_IF_MATCH]: l, [B.REPO_SIZE]: a, [B.DC_FORMAT]: n, [B.COMPONENT_ID]: d, [B.REPO_MD5]: h, [B.REPO_BLOCK_SIZE]: A }), s);
  return P.then((m) => {
    const D = new Pc(t, v, m.result, i, a, n, d, h, l, p, _, f, y, b);
    return D.onProgress = o, Object.assign(P, { blockUpload: D }), D.init(s);
  }).then((m) => m.start()).then((m) => {
    const D = m.finalizeResponse || { headers: {} }, k = m.uploadRecord || m.createdAsset;
    return { response: D, result: k, blockUpload: m, isBlockUpload: !0, asset: { assetId: D.headers["asset-id"] || e.assetId, repositoryId: D.headers["repository-id"] || e.repositoryId, etag: D.headers.etag, links: e ? e.links : k.links } };
  });
}
function bt({ service: t, asset: e, additionalHeaders: s, dataOrSliceCallback: r, contentType: n, progressCb: o, relation: i, size: a, componentId: d, md5: h, etag: l, relPath: p, createIntermediates: _, respondWith: f, blockSize: A, repoMetaPatch: y, maxConcurrentRequests: b }) {
  return Ao({ service: t, asset: e, additionalHeaders: s, dataOrSliceCallback: r, contentType: n, progressCb: o, relation: i, size: a, componentId: d, md5: h, etag: l, relPath: p, createIntermediates: _, respondWith: f, blockSize: A, repoMetaPatch: y, maxConcurrentRequests: b });
}
function ys({ service: t, additionalHeaders: e, dataOrSliceCallback: s, contentType: r, progressCb: n, relation: o, size: i, componentId: a, md5: d, etag: h, relPath: l, respondWith: p, blockSize: _, repoMetaPatch: f, maxConcurrentRequests: A }) {
  return Ao({ service: t, asset: void 0, additionalHeaders: e, dataOrSliceCallback: s, contentType: r, progressCb: n, relation: o, size: i, componentId: a, md5: d, etag: h, relPath: l, createIntermediates: !0, respondWith: p, blockSize: _, repoMetaPatch: f, maxConcurrentRequests: A });
}
function Sc(t) {
  return t || "defaultbuffer";
}
function Cc(t) {
  return !!(t.deviceModifyDate || t.assetType || t.assetSubType);
}
function Nc(t, e, s = "json", r = {}) {
  E(["svc", t, "object"], ["asset", e, "object"], ["format", s, "enum", !1, ["json", "xml"]]), F(e.links, [u.EMBEDDED_METADATA]);
  const n = H(e.links, u.EMBEDDED_METADATA);
  return t.invoke(O.GET, n, Object.assign(Object.assign({}, r), { accept: Xt[s.toUpperCase()] }), void 0, { isStatusValid: N(), responseType: s === "json" ? "json" : "text" }).then((o) => ({ result: o.response, response: o }));
}
function Dc(t, e, s, r, n = "json", o = {}) {
  E(["svc", t, "object"], ["asset", e, "object"], ["data", s, ["string", "object", "object[]"]], ["etag", r, "string", !0], ["format", n, "enum", !1, ["json", "xml"]]), F(e.links, [u.EMBEDDED_METADATA]);
  const i = H(e.links, u.EMBEDDED_METADATA), a = Object.assign(Object.assign({}, o), { [R.CONTENT_TYPE]: Xt[n.toUpperCase()], [R.IF_MATCH]: r });
  return t.invoke(O.PUT, i, a, typeof s == "string" ? s : JSON.stringify(s), { isStatusValid: N() });
}
function kc(t, e, s, r, n = {}) {
  E(["svc", t, "object"], ["asset", e, "object"], ["data", s, ["string", "object", "object[]"]], ["etag", r, "string", !0]), F(e.links, [u.EMBEDDED_METADATA]);
  const o = H(e.links, u.EMBEDDED_METADATA);
  return t.invoke(O.PATCH, o, Object.assign(n, { [R.CONTENT_TYPE]: ct, [R.IF_MATCH]: r }), typeof s == "string" ? s : JSON.stringify(s), { isStatusValid: N(), retryOptions: { pollCodes: [202], pollHeader: "location", pollMethod: "GET" } });
}
x("dcx:assets:filebase");
const lr = x("dcx:assets:filebase:leaf"), mo = "application/vnd.adobe.versions+json";
function Lc(t, e, s, r = "defaultbuffer", n, o) {
  lr("getRendition()"), E(["svc", t, "object"], ["asset", e, "object"], ["renditionOptions", s, "object", !0], ["linkProvider", n, "object", !0]), F(e.links, [u.RENDITION]);
  const i = n ? si(e.links[u.RENDITION], n, s) : Z(e.links, u.RENDITION, Object.assign({}, s));
  return t.invoke(O.GET, i, o, void 0, { responseType: Sc(r), isStatusValid: N() }).then((a) => ({ result: a.response, response: a }));
}
function Zr(t, e, s, r, n, o, i, a, d) {
  lr("doBlockDownload()"), E(["svc", t, "object"], ["assetOrPresignedUrl", e, ["object", "string"]], ["startByte", s, "number", !0], ["endByte", r, "number", !0], ["resource", n, "string", !0], ["componentId", o, "string", !0], ["version", i, "string", !0], ["responseType", a, "enum", !0, tr]), pn(() => s == null || r == null || s < r, "endByte must be greater than startByte");
  const h = this != null ? this : {};
  if (typeof e == "string") return et.call(h, t, e, s, r, a, !0, void 0, d);
  const l = e;
  F(l.links, [u.BLOCK_DOWNLOAD]);
  const p = w({ reltype: n, component_id: o, revision: i }), _ = Z(l.links, u.BLOCK_DOWNLOAD, { resource: n !== void 0 ? JSON.stringify(p) : void 0 });
  return et.call(h, t, _, s, r, a, !1, void 0, d);
}
function wc(t, e, s, r, n, o, i, a) {
  return lr("updatePrimaryResource()"), E(["service", t, "object"], ["asset", e, "object"], ["dataOrSliceCallback", s, ["function", "object", "string"]], ["contentType", r, "string"], ["size", n, "number", !0], ["md5", i, "string", !0]), F(e.links, [u.PRIMARY]), To({ svc: t, asset: e, dataOrSliceCallback: s, contentType: r, relation: u.PRIMARY, size: n, md5: i, maybeIsNew: !1, etag: o, additionalHeaders: a }).catch((d) => {
    var h;
    if (((h = d.response) === null || h === void 0 ? void 0 : h.statusCode) === 413) return bt({ service: U(t), asset: e, dataOrSliceCallback: s, contentType: r, relation: u.PRIMARY, size: n, md5: i, etag: o, additionalHeaders: a });
    throw d;
  });
}
const Et = x("dcx:assets:pagination");
class as {
  constructor(e, s, r, n) {
    if (this._links = e, this._svc = s, this._transformer = r, this._items = {}, this.ListResource = n, !e || !e[u.PAGE]) throw new c(c.INVALID_PARAMS, "Asset must have links that contain a page relation.");
  }
  get items() {
    return Object.values(this._items);
  }
  get data() {
    return this._data;
  }
  getPage(e = {}, s) {
    Et("getPage()");
    const { embed: r } = e, n = Sn(e, ["embed"]);
    r && (n.embed = r.some((i) => typeof i == "object") ? JSON.stringify(r) : r.join(",")), this.ListResource && Object.assign(n, { resource: this.ListResource });
    const o = Z(this._links, u.PAGE, n);
    return this._svc.invoke(O.GET, o, s, void 0, { isStatusValid: N(), responseType: "json" }).then((i) => {
      const a = this.parseResponse(i);
      return this._data = a, { paged: this, result: this._data, response: i };
    });
  }
  getNextPage() {
    if (Et("getNextPage()"), this.hasNextPage() && this._nextPageLink) return this._svc.invoke(O.GET, this._nextPageLink.href, void 0, void 0, { isStatusValid: N(), responseType: "json" }).then((e) => {
      const s = this.parseResponse(e);
      return this._data = s, { paged: this, result: this._data, response: e };
    });
  }
  hasNextPage() {
    return Et("hasNextPage() ", this._nextPageLink !== void 0), this._nextPageLink !== void 0;
  }
  *[Symbol.iterator]() {
    for (const e in this._items) yield this._items[e];
  }
  [Symbol.asyncIterator]() {
    return qa(this, arguments, function* () {
      for (const e in this._items) yield yield ot(this._items[e]);
      for (; this.hasNextPage(); ) {
        const e = yield ot(this.next());
        for (const s of e.value.paged) yield yield ot(s);
      }
    });
  }
  next() {
    return re(this, void 0, void 0, function* () {
      if (Et("next()"), !this.hasNextPage()) return { done: !0, value: void 0 };
      const e = yield this.getNextPage();
      return e ? { done: !1, value: e } : { done: !0, value: void 0 };
    });
  }
  parseResponse(e) {
    Et("parseResponse()"), this._items = {};
    const s = e.response;
    for (const r in s[T.CHILDREN]) {
      const n = s[T.CHILDREN][r], [o, i] = this._transformer(n, this._svc);
      this._items[o] = i;
    }
    return this._nextPageLink = s[T.LINKS].next, this.currentPage = s[T.PAGE], s;
  }
}
x("dcx:assets:version");
const yo = x("dcx:assets:version:leaf");
function Mc(t) {
  yo("adobeVersionTransformer()");
  const e = ur(t);
  return e.links = he({}, t.links, t._links), [e.version, e];
}
function ur(t) {
  return yo("deserializeVersion()"), { version: t.version || t[Me.VERSION], createDate: t.created || t[Me.CREATED], createdBy: t.createdBy || t[Me.CREATED_BY], milestone: t.milestone || t[Me.MILESTONE], links: t._links };
}
x("dcx:assets:file");
const pr = x("dcx:assets:file:leaf");
function Uc(t, e, s, r, n) {
  pr("patchVersions()"), E(["svc", t, "object"], ["asset", e, "object"], ["patchDoc", s, ["string", "array"]], ["etag", r, "string", !0]), F(e.links, [u.VERSION_HISTORY]);
  const o = Object.assign(Object.assign({}, n), { [R.CONTENT_TYPE]: ct });
  r && (o[R.IF_MATCH] = r);
  const i = H(e.links, u.VERSION_HISTORY);
  return t.invoke(O.PATCH, i, o, typeof s == "string" ? s : JSON.stringify(s), { isStatusValid: N() });
}
function vo(t, e, s, r) {
  pr("getVersionResource()"), E(["svc", t, "object"], ["asset", e, "object"], ["version", s, "string"]), F(e.links, [u.PAGE]), Nn(e.links, u.PAGE, "type", mo);
  const n = Z(e.links, u.PAGE, { version: s });
  return t.invoke(O.GET, n, r, void 0, { responseType: "json", isStatusValid: N() }).then((o) => ({ result: o.response[Me.TOTAL_CHILDREN] > 0 ? o.response[T.CHILDREN][0] : void 0, response: o }));
}
function xc(t, e, s = {}, r) {
  return pr("getPagedVersions()"), E(["svc", t, "object"], ["asset", e, "object"], ["pageOpts", s, "object"]), F(e.links, [u.PAGE]), Nn(e.links, u.PAGE, "type", mo), new as(e.links, t, s.itemTransformer || Mc, u.VERSION_HISTORY).getPage(s, r);
}
x("dcx:assets:composite");
const _e = x("dcx:assets:composite:leaf"), Bc = de.getInstance();
function jc(t, e, s) {
  return _e("headCompositeManifest()"), E(["svc", t, "object"], ["asset", e, "object"]), F(e.links, [u.MANIFEST]), cs(t, e, void 0, s).then((r) => t.invoke(O.HEAD, r, s, void 0, { responseType: "json", isStatusValid: N() }));
}
function Vc(t, e, s, r, n) {
  return _e("getCompositeManifest()"), E(["svc", t, "object"], ["asset", e, "object"], ["version", s, "string", !0], ["etag", r, "string", !0]), F(e.links, [u.MANIFEST]), cs(t, e, s, n).then((o) => t.invoke(O.GET, o, Object.assign(n ?? {}, r ? { [R.IF_NONE_MATCH]: r } : {}), void 0, { isStatusValid: N([304]), retryOptions: { pollCodes: [404, 202], pollHeader: "location", pollMethod: O.GET, problemWithCode: { problemType: X.RESOURCE_NOT_READY, code: 404 } } })).then((o) => {
    if ((o.statusCode === 200 || o.statusCode === 201) && o.headers[R.CONTENT_TYPE] === "application/http") {
      if (o.response) {
        const i = ns(Ie(o.response));
        return { manifestData: JSON.parse(ye(i.response)) || null, manifestEtag: i.headers.etag, response: i };
      }
      return { manifestData: o.response || null, manifestEtag: o.headers.etag, response: o.response };
    }
    if (typeof o.response == "string") return { manifestData: o.response ? JSON.parse(o.response) : null, manifestEtag: o.headers.etag, response: o };
    if (o.response === null && ["application/problem+json", "application/json"].includes(o.headers["content-type"])) throw new c(c.UNEXPECTED, "Unexpected response type");
    return { manifestData: o.response || null, manifestEtag: o.headers.etag, response: o };
  });
}
function cs(t, e, s, r) {
  return _e("getCompositeManifestUrl()"), _r(t, e, u.MANIFEST, s, r).then((n) => Ve(n, {}));
}
function Fc(t, e, s, r) {
  return _e("_getComponentPathUrl()"), _r(t, e, u.COMPONENT, e.version, r).then((n) => Ve(n, w({ component_path: s })));
}
function _r(t, e, s, r, n) {
  return _e("_getUrl()"), E(["svc", t, "object"], ["asset", e, "object"], ["versionId", r, "string", !0]), C.resolve().then(() => {
    if (r) return vo(t, e, r, n);
  }).then((o) => {
    if (r != null) {
      if (!o || !S(o) || typeof o.result != "object") throw new c(c.UNEXPECTED_RESPONSE, "Invalid version resource.", void 0, o ? o.response : void 0);
      return F(o.result[T.LINKS], [s]), H(o.result[T.LINKS], s);
    }
    return H(e.links, s);
  });
}
function Hc(t, e, s, r, n, o) {
  E(["svc", t, "object"], ["asset", e, "object"], ["components", s, "array"], ["version", r, "string", !0], ["etag", n, "string", !0]);
  const i = [u.MANIFEST, u.COMPONENT, u.BULK_REQUEST, u.BLOCK_DOWNLOAD];
  return r && i.push(u.PAGE), dt(t, e, i, void 0, o).then((a) => re(this, void 0, void 0, function* () {
    e.links = Object.assign({}, e.links, a);
    const d = U(t), h = s.map(({ component_path: _, responseType: f, subrequestHeaders: A }) => ({ method: O.GET, href: Z(e.links, u.COMPONENT, { component_path: _ }), headers: Object.assign(A || {}, o), component_path: _, responseType: f })), l = yield cs(d, e, r, o);
    h.unshift({ method: O.GET, href: l, headers: Object.assign(n ? { [R.IF_NONE_MATCH]: n } : {}, o) });
    const p = { startTime: ie(), timeoutAfter: 72e5 };
    return fn(Gc.bind(void 0, t, e, s, h, o), 404, p, X.RESOURCE_NOT_READY);
  }));
}
function Gc(t, e, s, r, n) {
  return re(this, void 0, void 0, function* () {
    const o = U(t), i = yield Promise.all(ei(r, 10).map((a) => os(o, e, a, void 0, n, !0)));
    return C.resolve(yield i.reduce((a, d) => re(this, void 0, void 0, function* () {
      var h, l;
      const p = yield a;
      if (p.responses.push(d.response), d.response.statusCode !== 200) return p;
      const { componentResponses: _, manifestResponse: f } = function(y, b) {
        return y.reduce((v, P) => {
          const m = b.find((D) => D.href === P.headers[R.CONTENT_ID]);
          if (!m) throw new c(c.UNEXPECTED_RESPONSE, "Bulk sub-response content-id did not match any bulk request", void 0, P);
          return "component_path" in m ? v.componentResponses.push(P) : v.manifestResponse = P, v;
        }, { componentResponses: [] });
      }(d.result, r), A = {};
      if (s.forEach((y) => {
        y.hasOwnProperty("skipBlockDownload") && (A[y.component_path] = y.skipBlockDownload);
      }), Object.assign(p.components, yield function(y, b, v, P, m, D) {
        return re(this, void 0, void 0, function* () {
          return (yield Promise.all(b.map((k) => re(this, void 0, void 0, function* () {
            if (k.headers[R.CONTENT_TYPE] === Ms && k.response.type === X.RESPONSE_TOO_LARGE) {
              const j = Jr(k, y), J = k.headers.location ? k.headers.location : Z(P, u.BLOCK_DOWNLOAD, { resource: JSON.stringify({ component_path: j.component_path }) });
              if (D && D[j.component_path]) return { statusCode: 200, headers: w({ [R.CONTENT_TYPE]: k.headers["content-type"], [R.CONTENT_LENGTH]: k.headers["content-length"], [R.CONTENT_ID]: k.headers[R.CONTENT_ID] }), responseType: "application/json", response: { href: J }, message: "OK" };
              const G = yield et(U(v), J, void 0, void 0, "defaultbuffer", !0, void 0, m);
              return Object.assign(G.headers, { [R.CONTENT_ID]: k.headers[R.CONTENT_ID] }), G;
            }
            return k;
          })))).reduce((k, j) => {
            const J = Jr(j, y);
            try {
              const G = Tt(j);
              k[J.component_path] = Object.assign({}, J, { response: j, [G ? "error" : "data"]: G || vs(j.response, J.responseType || "defaultbuffer", j.headers["content-type"]) });
            } catch (G) {
              k[J.component_path] = Object.assign({}, J, { response: j, error: new c(c.UNEXPECTED, "Error parsing sub-response into requested responseType", G) });
            }
            return k;
          }, {});
        });
      }(r.slice(1), _, t, e.links, n, A)), !f) return p;
      if (f.statusCode === 200) {
        p.manifest.data = vs(f.response, "json"), p.manifest.response = f, ws(e) && typeof ((h = e.current) === null || h === void 0 ? void 0 : h.parse) == "function" && (e.current.parse(ye(f.response)), e.current.versionId = f.headers.version), e.links = Ee(f);
        const y = ne(t);
        return y && y.setValueWithAsset(e.links, e), p;
      }
      if (f.statusCode === 304) return p.manifest.response = f, p;
      if (f.statusCode === 404) {
        if (f.response = vs(f.response, "json"), f.response && f.response.type === X.RESOURCE_NOT_READY) throw new c(c.NOT_FOUND, void 0, void 0, f);
        return p.manifest.error = Tt(f) || new c(c.NO_COMPOSITE, "Composite missing or deleted", void 0, f), p;
      }
      if (f.headers[R.CONTENT_TYPE] === Ms && f.response.type === X.RESPONSE_TOO_LARGE) {
        try {
          const y = f.headers.location ? f.headers.location : Z(e.links, u.BLOCK_DOWNLOAD, { resource: JSON.stringify({ reltype: u.MANIFEST }) }), b = yield et(o, y, void 0, void 0, "json", !0, void 0, n);
          p.manifest.data = b.response, p.manifest.response = b, ws(e) && typeof ((l = e.current) === null || l === void 0 ? void 0 : l.parse) == "function" && e.current.parse(JSON.stringify(b.response)), e.links = Ee(b);
        } catch (y) {
          p.manifest.error = y instanceof c ? y : new c(c.UNEXPECTED, "Error fetching manifest via block download", y);
        }
        return p;
      }
      return p.manifest.error = Tt(f) || new c(c.UNEXPECTED_RESPONSE, f.response.title || "Failed to fetch manifest. Operation failed.", void 0, f), p;
    }), Promise.resolve({ manifest: {}, components: {}, responses: [] })));
  });
}
function Jr(t, e) {
  if (!t.headers[R.CONTENT_ID]) throw new c(c.UNEXPECTED_RESPONSE, "Sub-response is missing content-id header", void 0, t);
  const s = e.find(({ href: r }) => r === t.headers[R.CONTENT_ID]);
  if (!s) throw new c(c.UNEXPECTED_RESPONSE, "Bulk sub-response content-id did not match any bulk request", void 0, t);
  return s;
}
function vs(t, e, s) {
  if (!Rn(t)) return t;
  switch (e) {
    case "text":
      return ye(t);
    case "json":
      return JSON.parse(ye(t));
    case "blob":
      return new Blob([t], { type: s });
    case "buffer":
    case "defaultbuffer":
      return t;
    case "arraybuffer":
      return t.buffer;
  }
  throw new c(c.INVALID_PARAMS, "requested response type is not supported");
}
function $c(t, e, s, r, n, o) {
  return re(this, void 0, void 0, function* () {
    const i = [{ method: O.PUT, href: s, headers: n, body: r }], a = [];
    if (e.deviceModifyDate && a.push({ op: "add", path: `/${[T.REPO_DEVICE_MODIFY_DATE]}`, value: e.deviceModifyDate }), a.length) {
      const _ = { [R.CONTENT_TYPE]: ct };
      i.push({ method: O.PATCH, href: H(e.links, u.REPO_METADATA), headers: _, body: JSON.stringify(a) });
    }
    const { result: d, response: h } = yield os(t, e, i, void 0, o, !0), { manifestResponse: l, repoMetadataResponse: p } = function(_, f) {
      const A = { manifestResponse: {}, repoMetadataResponse: {} };
      return f.forEach((y) => {
        const b = _.find((v) => v.headers[R.CONTENT_ID] === y.href);
        if (!b) throw new c(c.UNEXPECTED_RESPONSE, "Bulk sub-response content-id did not match any bulk request", void 0, b);
        y.href.includes(":repometadata") ? A.repoMetadataResponse = b : A.manifestResponse = b;
      }), A;
    }(d, i);
    return { manifestResponse: l, repoMetadataResponse: p, response: h };
  });
}
function fr(t, e, s, r) {
  return _e("getCompositeComponentUrl()"), E(["svc", t, "object"], ["asset", e, "object"], ["componentId", s, "string"], ["componentRevision", r, "string", !0]), F(e.links, [u.COMPONENT]), Z(e.links, u.COMPONENT, { component_id: s, revision: r });
}
function bo(t, e, s, r) {
  return _e("getPresignedUrl()"), E(["svc", t, "object"], ["asset", e, "object"]), dt(t, e, [u.BLOCK_DOWNLOAD], void 0, r).then((n) => {
    const o = s ? JSON.stringify(s) : void 0, i = Z(n, u.BLOCK_DOWNLOAD, { resource: o });
    return (er(t) ? t.service : t).invoke(O.GET, i, Object.assign({ priority: "u=1" }, r), void 0, { isStatusValid: N(), responseType: "json", retryOptions: { pollCodes: [202], pollHeader: "location", pollMethod: O.GET } });
  }).then((n) => {
    if (typeof n.response.href != "string") throw new c(c.INVALID_DATA, "Direct download URL not found.", void 0, n);
    return { response: n, result: n.response.href };
  });
}
const Ro = ss("AdobeDCX.getCompositeComponentPresignedUrl", function(t, e, s, r, n) {
  return _e("getCompositeComponentPresignedUrl()"), pe("componentId", s), pe("componentRevision", r), E(["svc", t, "object"], ["asset", e, "object"], ["componentId", s, "string"], ["componentRevision", r, "string"]), bo(t, e, { reltype: u.COMPONENT, revision: r, component_id: s }, n);
});
function Yc(t, e, s, r = "defaultbuffer", n, o) {
  return E(["svc", t, "object"], ["asset", e, "object"], ["componentPath", s, "string"], ["responseType", r, "string", !0], ["additionalHeaders", n, "object", !0]), dt(t, e, [u.COMPONENT, u.PAGE], void 0, n).then((i) => {
    if (e.links = i, e.version) return Fc(U(t), e, s);
  }).then((i) => ir(U(t), e, i ?? Z(e.links, u.COMPONENT, { component_path: s }), u.COMPONENT, r, void 0, void 0, n, o));
}
function qc(t, e, s, r, n = "defaultbuffer", o, i) {
  _e("getCompositeComponent()"), E(["svc", t, "object"], ["asset", e, "object"], ["componentId", s, "string"], ["componentRevision", r, "string"], ["responseType", n, "string", !0], ["additionalHeaders", o, "object", !0], ["componentSize", i, "number", !0]);
  const a = {};
  if (!i || i < Io()) {
    const d = fr(t, e, s, r);
    return ir.call(a, t, e, d, u.COMPONENT, n, s, r, o);
  }
  return Ro(t, e, s, r, o).then(({ response: d, result: h }) => et.call(a, t, h, void 0, void 0, n, !0, d.response.size, o));
}
function xs(t, e, s, r, n = 1, o, i = {}, a) {
  if (_e("updateCompositeManifest() ", r, o), E(["svc", t, "object"], ["asset", e, "object"], ["manifest", s, ["object", "string"]], ["overwrite", r, "boolean"], ["validationLevel", n, "+number"], ["etag", o, "string", !0]), n < 1) throw new c(c.INVALID_PARAMS, "ValidationLevel must be >=1");
  return F(e.links, [u.BULK_REQUEST, u.REPO_METADATA]), _r(t, e, u.MANIFEST, void 0, i).then((d) => re(this, void 0, void 0, function* () {
    const h = Object.assign({}, i);
    r ? h[R.IF_MATCH] = "*" : o && (h[R.IF_MATCH] = o);
    const l = `${Ga}; validation-level=${n}`;
    h[R.CONTENT_TYPE] = l;
    const p = typeof s == "string" ? s : JSON.stringify(s);
    let _, f, A;
    const y = d.includes(yt.REPO_META_PATCH) || d.includes(yt.RESPOND_WITH);
    if (y) {
      const v = {}, P = w({ [T.REPO_DEVICE_MODIFY_DATE]: e.deviceModifyDate });
      Object.keys(P).length && (v[yt.REPO_META_PATCH] = P), d = Ve(d, v), _ = yield function(m, D, k, j) {
        return re(this, void 0, void 0, function* () {
          return yield m.invoke(O.PUT, D, j, k, { isStatusValid: N([412, 409]), responseType: "arraybuffer", retryOptions: { pollCodes: [202], pollHeader: "location", pollMethod: O.GET, modifyHeadersCallback: On([R.IF_MATCH]) } });
        });
      }(t, d, p, h);
    } else {
      const v = yield $c(t, e, d, p, h, i);
      _ = v.manifestResponse, f = v.repoMetadataResponse, A = v.response;
    }
    if (_e("uCM() status code for manifest response: ", _.statusCode), _.statusCode === 412 && r) return _e("uCM() retry 412 without overwrite"), xs(t, e, s, !1, n, void 0, i);
    if (_.statusCode === 409 && r) return _e("uCM() retry 409 without overwrite"), xs(t, e, s, !1, n, o, i);
    if (_.statusCode === 409) throw new c(c.UPDATE_CONFLICT, "Manifest has been changed", void 0, _);
    if (_.statusCode === 412) throw new c(c.PRECONDITION_FAILED, "Precondition failed", void 0, _);
    if (_.statusCode === 400) {
      const v = Tt(_);
      throw new c(v == null ? void 0 : v.code, v == null ? void 0 : v.message, void 0, _);
    }
    {
      const v = N()(_.statusCode, _);
      if (v !== !0) throw new c(v.code || c.UNEXPECTED_RESPONSE, v._message || v.message, v.underlyingError, _);
    }
    if (!y) {
      if (_.xhr = A.xhr, _e("uCM() status code for metadata response: ", f.statusCode), Cc(e) && f.statusCode !== 200 && f.statusCode !== 201 && f.statusCode !== 204) throw new c(c.UNEXPECTED_RESPONSE, "Unexpected HTTP Response", void 0, f);
      return _;
    }
    let b = _;
    if (_.statusCode === 200 && (b = ns(new Uint8Array(_.response))), b.response && a) try {
      const v = JSON.parse(ye(b.response));
      b.response = se(v);
    } catch (v) {
      throw new c(c.UNEXPECTED, "Unexpected error parsing respondWith parameter", v);
    }
    return b;
  }));
}
function zc(t, e, s, r, n, o, i, a, d, h, l) {
  if (E(["service", t, "object"], ["asset", e, "object"], ["componentId", s, "string"], ["contentType", n, "string"], ["maybeIsNew", o, "boolean", !0], ["size", i, "number", !0], ["blockSize", l, "number", !0], ["md5", a, "string", !0]), o && !Wt(s)) throw new c(c.INVALID_PARAMS, "Component id is not a uuid");
  return Wt(s) || Bc.warn("Existing component id is not a uuid"), To({ svc: t, asset: e, dataOrSliceCallback: r, contentType: n, relation: u.COMPONENT, size: i, componentId: s, md5: a, maybeIsNew: o, additionalHeaders: h, progressCb: d, blockSize: l }).then(({ response: p, result: _, isBlockUpload: f, asset: A }) => {
    const y = { response: p, result: Object.assign(Object.assign({}, _), { id: s, type: n }), isBlockUpload: f, asset: A };
    return Object.defineProperty(y, "compositeAsset", { get: () => A }), y;
  });
}
function Wc(t, e, s, r) {
  return dt(t, e, [u.COMPONENT, u.BLOCK_UPLOAD_INIT], void 0, r).then((n) => {
    var o;
    const i = U(t);
    (o = ne(t)) === null || o === void 0 || o.setValueWithAsset(n, e), e.links = Object.assign(Object.assign({}, e.links), n);
    const a = Ot(w(Object.assign(Object.assign({}, r), { [R.AUTHORIZATION]: i.authProvider.authToken, [R.X_API_KEY]: i.authProvider.apiKey })));
    return Promise.all(s.map((d) => dr(e, d.size) ? function(h, l, p, _) {
      const f = w({ "repo:reltype": u.COMPONENT, "repo:size": p.size, "dc:format": p.contentType, component_id: p.componentId });
      return hr(h, l, f, _).then((A) => {
        if (A.response.statusCode !== 200) throw new c(c.UNEXPECTED_RESPONSE, "Unexpected response from block upload init", A.response);
        const y = A.result;
        return { blockSize: y[B.REPO_BLOCK_SIZE], uploadRequestParameters: y[T.LINKS][u.BLOCK_TRANSFER].map(({ href: b }) => ({ href: b, method: O.PUT })), finalizeRequestParameters: { href: Z(y[T.LINKS], u.BLOCK_FINALIZE, {}), method: O.POST, headers: _, body: `${JSON.stringify(y)}` } };
      }).catch((A) => {
        throw new c(c.UNEXPECTED_RESPONSE, "Unexpected response from block upload init", A);
      });
    }(i, e, d, a) : function(h, l, p, _) {
      return C.resolve({ blockSize: p.size, uploadRequestParameters: [{ href: fr(h, l, p.componentId), method: O.PUT, headers: _ }] });
    }(i, e, d, a)));
  });
}
const bs = x("dcx:assets:directory"), Dt = x("dcx:assets:directory:leaf");
class Er extends vt {
  constructor(e, s, r) {
    super(e, s, r), this.type = $e.Directory, this.children = [], this.children = e[T.CHILDREN];
  }
  getPagedChildren(e, s) {
    return bs("getPagedChildren()"), this.fetchLinksIfMissing([u.PAGE], s).then(() => Po(this._svc, this, e, s));
  }
  createAsset(e, s, r, n, o, i, a, d, h) {
    return bs("createAsset()"), So(this._svc, this, e, s, r, n, o, i, a, d, h).then((l) => ({ result: new vt(l.result, this.serviceConfig), response: l.response }));
  }
  createAssetForGuest(e, s, r, n, o, i, a, d) {
    return bs("createAssetForGAT"), Co(this._svc, e, s, r, n, o, i, a, d).then((h) => ({ result: new vt(h.result, this.serviceConfig), response: h.response }));
  }
  copy(e, s, r) {
    return super.copy(e, s, r).then(({ response: n, result: o }) => ({ response: n, result: new Er(o, this.serviceConfig) }));
  }
}
function Oo(t) {
  var e;
  Dt("directoryTransformer()");
  const s = se(t, (e = t[T.PAGE]) === null || e === void 0 ? void 0 : e.embed);
  s.links = he({}, t.links, t._links);
  const r = t.children || t[T.CHILDREN];
  return r && r.length > 0 ? s.children = r.map((n) => se(n)) : s.children = [], [s.assetId, s];
}
function Kc(t, e) {
  return Dt("getDirectoryByURL()"), t.invoke(O.GET, e, void 0, void 0, { responseType: "json", isStatusValid: N() }).then((s) => ({ result: s.response, response: s }));
}
function Po(t, e, s = {}, r) {
  if (Dt("getPagedChildren()"), F(e.links, [u.PAGE]), s && s.embed && s.embed.includes(u.REPOSITORY)) throw new c(c.INVALID_PARAMS, "Repository Resource embeds on directory listings are not supported");
  try {
    return new as(e.links, t, Oo, "api:primary").getPage(s, r);
  } catch (n) {
    return C.reject(n);
  }
}
const So = ss("AdobeDCX.createAsset", function(t, e, s, r, n, o, i = {}, a, d, h, l) {
  Dt("createAsset()"), E(["service", t, "object"], ["parentDir", e, "object"], ["relPath", s, "string"], ["createIntermediates", r, "boolean"], ["contentType", n, "string"], ["respondWith", o, ["string", "object"], !0], ["additionalHeaders", i, "object", !0], ["repoMetaPatch", h, "object", !0]);
  const p = S(o) ? JSON.stringify(o) : o;
  return dt(t, e, [u.CREATE]).then((_) => {
    const f = Z(_, u.CREATE, { path: s, intermediates: r.toString(), respondWith: p, mode: "id", repoMetaPatch: h }), A = Object.assign({}, { [R.CONTENT_TYPE]: n }, i), y = U(t), b = a ? Je(a, d) : void 0, v = b ? xe(b) : 0;
    return a && dr(e, v) ? bt({ service: y, contentType: n, relation: u.PRIMARY, asset: e, dataOrSliceCallback: a, size: v, relPath: s, createIntermediates: r, respondWith: o, repoMetaPatch: h, additionalHeaders: i, progressCb: l }).then(({ result: P, response: m }) => {
      const D = s.split("/").slice(-1);
      return { result: w(Ue({ name: D }, P)), response: m };
    }) : C.resolve().then(() => re(this, void 0, void 0, function* () {
      const P = q(a) ? yield a(0, v) : b;
      return y.invoke(O.POST, f, A, P, { responseType: "json", isStatusValid: N([413]), reuseRequestDesc: { id: "createAsset", method: O.POST, href: f, headers: A, progress: l } }).then((m) => {
        var D;
        if (m.statusCode === 413) return bt({ service: y, contentType: n, relation: u.PRIMARY, asset: e, dataOrSliceCallback: a, size: xe(Je(a, d)), relPath: s, createIntermediates: r, respondWith: o, repoMetaPatch: h, additionalHeaders: i, progressCb: l }).catch((ae) => {
          var be;
          if (ae.problemType === X.ASSET_NAME_CONFLICT) {
            const ue = { assetId: (be = ae.response.response) === null || be === void 0 ? void 0 : be["repo:assetId"], links: Ee(ae.response) };
            return bt({ service: y, contentType: n, relation: u.PRIMARY, asset: ue, dataOrSliceCallback: a, size: xe(Je(a, d)), relPath: s, createIntermediates: r, respondWith: o, repoMetaPatch: h, additionalHeaders: i, progressCb: l });
          }
          throw ae;
        }).then(({ result: ae, response: be }) => {
          const ue = s.split("/")[s.split("/").length - 1];
          return { result: w(Ue({ name: ue }, ae)), response: be };
        });
        const k = s.split("/")[s.split("/").length - 1];
        let j;
        e.path && (j = an(e.path, s));
        const J = Ee(m), G = m.headers;
        if (!((D = G[R.CONTENT_TYPE]) === null || D === void 0) && D.includes("multipart/mixed")) {
          const ae = ar(m)[1];
          throw ae.statusCode === 404 ? new c(c.ASSET_NOT_FOUND, "Asset was created successfully but repository metadata could not be found.", void 0, m) : ae.statusCode === 403 ? new c(c.FORBIDDEN, "Asset was created successfully but Permission denied for fetching repository metadata.", void 0, m) : Vs("Unexpected Server Response", void 0, m);
        }
        const ve = S(m.response) ? m.response : { etag: "", md5: "" }, ke = G["asset-id"] || G["x-resource-id"], Q = e.repositoryId;
        pe("assetId", ke);
        let le = ve.etag, Ae = ve.md5;
        o == null && (le = G.etag, Ae = G["content-md5"]);
        const ze = S(m.response) && o && (o === u.REPO_METADATA || S(o) && o.reltype === u.REPO_METADATA) ? se(m.response) : {};
        m.response && (ze.representations = m.response.representations || m.response[T.REPO_REPRESENTATIONS]);
        const Le = ne(t);
        return Le && Le.setValueWithAsset(J, ze), { result: w(Ue({ name: k }, ze, w({ links: J, assetId: ke, etag: le, md5: Ae, repositoryId: Q, format: n, path: j }))), response: m };
      });
    }));
  });
});
function Co(t, e, s, r, n = {}, o, i, a, d) {
  Dt("createAssetForGuest()"), E(["service", t, "object"], ["relPath", e, "string"], ["contentType", s, "string"], ["respondWith", r, ["string", "object"], !0], ["additionalHeaders", n, "object", !0], ["repoMetaPatch", a, "object", !0]);
  const h = S(r) ? JSON.stringify(r) : r, l = U(t);
  return function(p, _, f, A) {
    V("getCreateLinkForGuestUser"), E(["svc", p, "object"], ["assetPath", _, "string"]);
    const y = { path: _, mode: "id", intermediates: "true", repoMetaPatch: A, respondWith: f }, b = U(p), v = qe(pc, b);
    return C.resolve(Ve(v, w(y)));
  }(l, e, h, a).then((p) => {
    const _ = Object.assign({}, { [R.CONTENT_TYPE]: s }, n), f = o ? Je(o, i) : void 0, A = f ? xe(f) : 0;
    return o && A > is ? ys({ service: l, contentType: s, relation: u.PRIMARY, dataOrSliceCallback: o, size: A, relPath: e, respondWith: r, repoMetaPatch: a, additionalHeaders: n, progressCb: d }).then(({ result: y, response: b }) => {
      const v = e.split("/").slice(-1);
      return { result: w(Ue({ name: v }, y)), response: b };
    }) : C.resolve().then(() => re(this, void 0, void 0, function* () {
      const y = q(o) ? yield o(0, A) : f;
      return l.invoke(O.POST, p, _, y, { responseType: "json", isStatusValid: N([413]), reuseRequestDesc: { id: "createAssetForGuest", method: O.POST, href: p, headers: _, progress: d } }).then((b) => {
        var v;
        if (b.statusCode === 413) return ys({ service: l, contentType: s, relation: u.PRIMARY, dataOrSliceCallback: o, size: xe(Je(o, i)), relPath: e, respondWith: r, repoMetaPatch: a, additionalHeaders: n, progressCb: d }).catch((le) => {
          if (le.problemType === X.ASSET_NAME_CONFLICT) return ys({ service: l, contentType: s, relation: u.PRIMARY, dataOrSliceCallback: o, size: xe(Je(o, i)), relPath: e, respondWith: r, repoMetaPatch: a, additionalHeaders: n, progressCb: d });
          throw le;
        }).then(({ result: le, response: Ae }) => {
          const ze = e.split("/")[e.split("/").length - 1];
          return { result: w(Ue({ name: ze }, le)), response: Ae };
        });
        const P = e.split("/")[e.split("/").length - 1], m = Ee(b), D = b.headers;
        if (!((v = D[R.CONTENT_TYPE]) === null || v === void 0) && v.includes("multipart/mixed")) {
          const le = ar(b)[1];
          throw le.statusCode === 404 ? new c(c.ASSET_NOT_FOUND, "Asset was created successfully but repository metadata could not be found.", void 0, b) : le.statusCode === 403 ? new c(c.FORBIDDEN, "Asset was created successfully but Permission denied for fetching repository metadata.", void 0, b) : Vs("Unexpected Server Response", void 0, b);
        }
        const k = S(b.response) ? b.response : { etag: "", md5: "" }, j = D["asset-id"] || D["x-resource-id"], J = D["repository-id"];
        let G = k.etag, ve = k.md5;
        r == null && (G = D.etag, ve = D["content-md5"]);
        const ke = S(b.response) && r && (r === u.REPO_METADATA || S(r) && r.reltype === u.REPO_METADATA) ? se(b.response) : {}, Q = ne(t);
        return Q && Q.setValueWithAsset(m, ke), { result: w(Ue({ name: P }, ke, w({ links: m, assetId: j, etag: G, md5: ve, format: s, repositoryId: J, path: e }))), response: b };
      });
    }));
  });
}
const ds = x("dcx:assets:discoverable");
function Xc(t, e = {}, s) {
  ds("getDiscoverableAssets()"), E(["svc", t, "object"], ["pageOpts", e, "object"]);
  const r = U(t);
  return Un(t, s).then((n) => new as(n.assetLinks, r, Zc, "api:primary").getPage(e, s)).then((n) => ({ result: n.response.response, paged: n.paged, response: n.response }));
}
function Zc(t) {
  ds("discoverableAssetTransformer()");
  const e = t[T.EMBEDDED][u.REPO_METADATA], s = se(e, t[T.EMBEDDED]);
  return s.links = he({}, t.links, e._links), [s.assetId, s];
}
function Jc(t) {
  ds("discoverableReposTransformer()");
  const e = t[T.EMBEDDED][u.PRIMARY], s = rr(e);
  return s.links = e._links, [s.repositoryId, s];
}
function Qc(t, e = {}, s) {
  ds("getDiscoverableRepos()"), E(["svc", t, "object"], ["pageOpts", e, "object"]);
  const r = U(t), n = qe("/repositories", r);
  return C.resolve(void 0).then(() => re(this, void 0, void 0, function* () {
    const o = ne(t);
    let i;
    return o && (i = yield o.getRepositoryLinks()), !i && (i = Ee(yield r.invoke(O.HEAD, n, s, void 0, { isStatusValid: N() }))), o && o.setRepositoryLinks(i), new as(i, r, Jc).getPage(e, s);
  })).then((o) => ({ result: o.response.response, paged: o.paged, response: o.response }));
}
x("dcx:assets:factory");
const No = x("dcx:assets:indexdocument");
function ed(t, e) {
  No("getIndexDocument()"), E(["svc", t, "object"]);
  const s = U(t), r = qe("/index", s);
  return s.invoke(O.GET, r, e, void 0, { responseType: "json", isStatusValid: N() }).then((n) => ({ result: td(n.response), response: n.response }));
}
function td(t) {
  No("deserializeIndexDocument()");
  const e = t.children.map((s) => {
    const r = se(s[T.EMBEDDED][u.REPO_METADATA]), n = rr(s[T.EMBEDDED][u.REPOSITORY]);
    return r.embedded = { RepositoryResource: n }, r;
  });
  return { regions: t[T.REPO_REGIONS], assignedDirectories: e, links: t._links };
}
const sd = 1e5;
class rd {
  constructor(e = 1e5, s = "SESSION") {
    if (this.values = {}, this.maxEntries = sd, this.promiseToResolveMap = /* @__PURE__ */ new Map(), e <= 0) throw new c(c.INVALID_PARAMS, "Cache Max enteries must be great than 0.");
    this.maxEntries = e, this.defaultSessionKey = s;
  }
  clear() {
    this.promiseToResolveMap.forEach((e) => {
      e.call(void 0);
    });
    for (const e in this.values) this.values[e].clear();
    this.values = {};
  }
  getKey(e) {
    if (e.assetId || typeof e != "object") return e.assetId;
  }
  getValueWithAsset(e) {
    if (!e.assetId && typeof e == "object") return;
    const s = this.getKey(e);
    return s ? this.get(s, e.repositoryId) : void 0;
  }
  setPending(e, s = this.defaultSessionKey) {
    let r;
    this.values[s] || (this.values[s] = /* @__PURE__ */ new Map());
    const n = this.values[s].get(e);
    if (n && n instanceof Promise) return this.promiseToResolveMap.get(n);
    const o = new Promise((i) => {
      r = i;
    });
    return this.values[s].set(e, o), this.promiseToResolveMap.set(o, r), o.then(() => this.promiseToResolveMap.delete(o)).catch(() => this.promiseToResolveMap.delete(o)), r;
  }
  get(e, s = this.defaultSessionKey) {
    if (this.values[s] && s in this.values) return this.values[s].get(e);
  }
  setValueWithAsset(e, s) {
    if (!e) return;
    const r = this.getKey(s);
    if (r) {
      const n = s.repositoryId || this.defaultSessionKey;
      this.set(e, r, n);
    }
  }
  set(e, s, r = this.defaultSessionKey) {
    if (this.values[r]) {
      if (this.values[r] && this.values[r].get(s) instanceof Promise) {
        const n = this.values[r].get(s), o = this.promiseToResolveMap.get(n);
        this.promiseToResolveMap.delete(n), o && o(e);
      }
    } else this.values[r] = /* @__PURE__ */ new Map();
    if (this.values[r].size >= this.maxEntries) {
      const n = this.values[r].keys().next().value;
      this.values[r].delete(n);
    }
    this.values[r].set(s, Promise.resolve(e));
  }
  delete(e, s = this.defaultSessionKey) {
    this.values[s] && this.values[s].delete(e);
  }
  deleteWithAsset(e) {
    const s = this.getKey(e);
    s && this.delete(s, e.repositoryId);
  }
}
class Do extends rd {
  constructor(e = 1e5, s = 2592e6) {
    super(e, "SESSION"), this.timestampsOnLinkCreation = 0, this.maxCachePeriodMS = 0, this.maxCachePeriodMS = s;
  }
  isLinkExpired() {
    return this.maxCachePeriodMS < Date.now() - this.timestampsOnLinkCreation;
  }
  setIndexLinks(e) {
    this.set(e, "INDEX", "SESSION"), this.timestampsOnLinkCreation = Date.now();
  }
  getIndexLinks() {
    if (!this.isLinkExpired()) return this.get("INDEX", "SESSION");
  }
  setIndexRepository(e) {
    this.indexRepository = e;
  }
  getIndexRepository() {
    return this.indexRepository;
  }
  setRepositoryLinks(e) {
    this.set(e, "/Repositories", "SESSION"), this.timestampsOnLinkCreation = Date.now();
  }
  getRepositoryLinks() {
    if (!this.isLinkExpired()) return this.get("/Repositories", "SESSION");
  }
}
var Qr, en;
(function(t) {
  t.IMAGE_JPG = "image/jpg", t.IMAGE_PNG = "image/png", t.IMAGE_GIF = "image/gif", t.VIDEO_MP4 = "video/mp4", t.VIDEO_METADATA = "application/vnd.adobe.ccv.videometadata";
})(Qr || (Qr = {})), function(t) {
  t.NONE = "none", t.EMBEDDED = "embedded";
}(en || (en = {}));
x("dcx:assets:versionset");
const nd = x("dcx:assets:versionset:leaf");
function od(t) {
  nd("deserializeVersionSet()");
  const e = { versionCount: t[Me.TOTAL_CHILDREN], repositoryId: t[Me.REPO_ID], assetId: t[T.REPO_ASSET_ID], links: {}, versions: [] }, s = t.children || t[T.CHILDREN];
  return s && s.length > 0 && (e.versions = s.map((r) => ur(r))), e.links = t._links, e;
}
function rt(t, e, s, r) {
  var n, o = arguments.length, i = o < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, s) : r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") i = Reflect.decorate(t, e, s, r);
  else for (var a = t.length - 1; a >= 0; a--) (n = t[a]) && (i = (o < 3 ? n(i) : o > 3 ? n(e, s, i) : n(e, s)) || i);
  return o > 3 && i && Object.defineProperty(e, s, i), i;
}
const id = "0", ad = "md5";
class cd {
  constructor(e, s, r, n, o, i) {
    this.id = e, this.etag = s, this.version = r, this.md5 = n, this.length = o, this.type = i;
  }
}
class dd {
  constructor(e, s, r) {
    this.compositeId = e, this.compositeAssetId = s, this.repositoryId = r, this.records = {};
  }
  addUploadRecord(e, s) {
    E(["componentId", e, "string"], ["record", s, "object"]), this.records[e] = s;
  }
  getComponentDescriptor(e) {
    const s = this._checkRAPIComponentParams(e);
    return JSON.stringify(function(r, n, o, i) {
      try {
        un(i, "UploadRecord", ["id", "string"], ["version", "string"], ["length", "number"], ["etag", "string"], ["type", "string"]);
      } catch (d) {
        throw new c(c.INVALID_STATE, "Invalid record data", d);
      }
      const a = { versionId: id, componentId: i.id, cloudAssetId: r, compositeId: n, repositoryId: o, componentRevisionId: i.version, type: i.type, cloudExpiration: void 0, size: i.length, etag: i.etag, hashType: ad, hashValue: i.md5 };
      return w(a);
    }(this.compositeAssetId, this.compositeId, this.repositoryId, s));
  }
  getComponentURL(e, s) {
    const r = this._checkRAPIComponentParams(s);
    return e.getCompositeComponentUrlForDownload({ repositoryId: this.repositoryId, assetId: this.compositeAssetId }, s, r.length, r.version);
  }
  getComponent(e, s, r) {
    const n = this._checkRAPIComponentParams(s);
    return e.getCompositeComponent({ repositoryId: this.repositoryId, assetId: this.compositeAssetId }, s, n.version, r);
  }
  _checkRAPIComponentParams(e) {
    if (!this.repositoryId) throw new c(c.INVALID_STATE, "Repository ID must be defined.", void 0, void 0, { componentId: e });
    const s = this.records[e];
    if (!s) throw new c(c.INVALID_PARAMS, "UploadRecord does not exist", void 0, void 0, { componentId: e });
    return s;
  }
}
function tn(t, e, s) {
  return E(["compositeId", t, "string", !0], ["compositeAssetId", e, "string"], ["repositoryId", s, ["string", "undefined"]]), new dd(t, e, s);
}
function hd(t, e, s, r, n, o) {
  return E(["componentId", t, "string"], ["etag", e, "string"], ["version", s, "string"], ["md5", r, "string"], ["length", n, "number"], ["type", o, "string"]), new cd(t, e, s, r, n, o);
}
function ld(t, e, s) {
  E(["repoUploadResults", e, "object"], ["compositeId", s, "string", !0]), un(e, "repoUploadResults", ["result", "object"]);
  const r = e.asset || e.compositeAsset, { result: n } = e;
  if (!(r.assetId && r.repositoryId || r.links || n.links)) throw new c(c.INVALID_PARAMS, "AdobeRepoUploadResult#asset object missing repositoryId or assetId, and links");
  const o = hd(n.id, n.etag, n.revision, n.md5, n.length, n.type);
  let i;
  if (r.assetId && r.repositoryId) i = C.resolve(tn(s, r.assetId, r.repositoryId));
  else {
    E(["session", t, "object"]);
    const a = r.links || n.links, d = Cn(a, [u.PRIMARY, u.ID, u.PATH, u.COMPONENT]), h = Z(a, d, { component_id: "manifest" });
    i = t.headHTTPResource(h).then((l) => {
      const p = l.headers["repository-id"], _ = l.headers["asset-id"];
      if (!p || !_) throw new c(c.INVALID_DATA, "Fetched data missing repositoryId or assetId");
      return tn(s, _, p);
    });
  }
  return i.then((a) => (a.addUploadRecord(n.id, o), a));
}
const sn = x("dcx:repoapisession"), ud = de.getInstance(), rn = "+dcx";
let Ge = class {
  constructor(t, e, s) {
    this._authenticationAllowList = ["adobe.com", "adobe.io", "adobelogin.com", "fotolia.net"], this._blockUploadThreshold = is, E(["httpService", t, "object"], ["server", e, "string"]), this._service = t, this._service._repoAPIBaseUrl = e;
    const r = Ss(e);
    if (!r) throw new c(c.INVALID_PARAMS, "Could not determine endpoint from: " + e);
    this._endPoint = r, S(s) && q(s.getIndexLinks) ? this._linksCache = s : this._linksCache = new Do();
  }
  get serviceConfig() {
    return { service: this._service, cache: this._linksCache };
  }
  get blockUploadThreshold() {
    return this._blockUploadThreshold;
  }
  set blockUploadThreshold(t) {
    Ye("threshold", t, "+number"), this._blockUploadThreshold = t;
  }
  get blockDownloadThreshold() {
    return Io();
  }
  set blockDownloadThreshold(t) {
    Ye("threshold", t, "+number"), bc(t);
  }
  createAsset(t, e, s, r, n, o, i, a, d) {
    return So(this._service, t, e, s, r, n, o, i, a, d);
  }
  createAssetForGuest(t, e, s, r, n, o, i, a) {
    return Co(this._service, t, e, s, r, n, o, i, a);
  }
  createComposite(t, e, s, r, n, o, i, a) {
    if (sn("createComposite()"), E(["parentDir", t, "object"], ["relPath", e, "string"], ["contentType", s, "string"]), !s.endsWith(rn)) throw new c(c.INVALID_PARAMS, `Composite contentType must end in "${rn}"`);
    if (!Zt(t)) throw new c(c.INVALID_PARAMS, "parentDir must contain links or repositoryId & assetId or path");
    return this.createAsset(t, e, !0, o && s.endsWith("dcx") ? s + "ucf" : s, r, n, o, i, a).catch((d) => {
      if (!d.response || d.response.statusCode !== 409) throw Vs("Error creating composite", d, d.response);
      if (d.response.headers.link) {
        const h = Ee(d.response);
        this._linksCache.setValueWithAsset(h, { assetId: d.response.headers["asset-id"] || d.response.headers["x-resource-id"], repositoryId: t.repositoryId });
      }
      throw new c(c.ALREADY_EXISTS, "Composite already exists at " + e, void 0, d.response);
    });
  }
  copyResources(t, e, s, r, n, o) {
    return Ac(this._service, t, e, s, r, n, o);
  }
  getIndexLinks(t) {
    return Mn(this.serviceConfig, t);
  }
  getIndexRepository(t) {
    return Un(this.serviceConfig, t);
  }
  getIndexDocument(t) {
    return ed(this.serviceConfig, t);
  }
  getDiscoverableAssets(t = {}, e) {
    return Xc(this.serviceConfig, t, e);
  }
  getDiscoverableRepos(t = {}, e) {
    return Qc(this.serviceConfig, t, e);
  }
  headHTTPResource(t, e) {
    return sr(this._service, t, e);
  }
  headCompositeManifest(t, e) {
    return this.fetchLinksIfMissing(t, [u.COMPONENT], e).then(() => jc(this._service, t, e));
  }
  resolveAsset(t, e = "id", s, r, n) {
    return cr(this.serviceConfig, t, e, s, r, n);
  }
  headPrimaryResource(t, e) {
    return this.fetchLinksIfMissing(t, [u.PRIMARY], e).then(() => Zn(this.serviceConfig, t, e));
  }
  getRepoMetadata(t, e) {
    return t.assetId && pe("assetId", t.assetId), this.useLinkOrResolveResource(t, u.REPO_METADATA, "json", e).then((s) => ({ result: se(s.response.response), response: s.response }));
  }
  updateRepoMetadata(t, e) {
    return this.fetchLinksIfMissing(t, [u.REPO_METADATA], e).then(() => eo(this.serviceConfig.service, t, e));
  }
  getEmbeddedMetadata(t, e = "json", s) {
    return E(["asset", t, "object"], ["format", e, "enum", !1, ["json", "xml"]]), this.fetchLinksIfMissing(t, [u.EMBEDDED_METADATA], s).then(() => Nc(this._service, t, e));
  }
  putEmbeddedMetadata(t, e, s, r = "json", n) {
    return E(["asset", t, "object"], ["data", e, ["string", "object", "object[]"]], ["etag", s, "string", !0], ["format", r, "enum", !1, ["json", "xml"]]), this.fetchLinksIfMissing(t, [u.EMBEDDED_METADATA], n).then(() => Dc(this._service, t, e, s, r, n));
  }
  patchEmbeddedMetadata(t, e, s, r) {
    return E(["asset", t, "object"], ["data", e, ["string", "object", "object[]"]], ["etag", s, "string", !0]), this.fetchLinksIfMissing(t, [u.EMBEDDED_METADATA], r).then(() => kc(this._service, t, e, s, r));
  }
  getDirectory(t, e, s) {
    return this.fetchLinksIfMissing(t, [u.PAGE], s).then(() => Po(this._service, t, e, s).then((r) => ({ result: Oo(r.paged.data)[1], paged: r.paged, response: r.response })));
  }
  getDirectoryByURL(t) {
    return Kc(this._service, t).then((e) => ({ response: e.response, result: se(e.result) }));
  }
  getLinksForAsset(t, e) {
    return Qn(this.serviceConfig, t, e);
  }
  getACLPolicy(t, e) {
    return this.fetchLinksIfMissing(t, [u.ACL_POLICY], e).then(() => ao(this._service, t, e));
  }
  getPrimaryResource(t, e, s) {
    const r = {};
    return this._withSourcePromise(r).then(() => this.fetchLinksIfMissing(t, [u.PRIMARY], s)).then(() => Xn.call(r, this._service, t, e, s));
  }
  updatePrimaryResource(t, e, s, r, n, o, i) {
    return this.fetchLinksIfMissing(t, [u.PRIMARY], i).then(() => wc(this._service, t, e, s, r, n, o, i));
  }
  getRepositoryResource(t, e) {
    return this.fetchLinksIfMissing(t, [u.REPOSITORY], e).then(() => to(this._service, t, e));
  }
  getVersions(t, e, s) {
    return this.fetchLinksIfMissing(t, [u.PAGE], s).then(() => xc(this._service, t, e, s).then((r) => ({ result: od(r.result), response: r.response, paged: r.paged })));
  }
  getVersionResource(t, e, s) {
    return this.fetchLinksIfMissing(t, [u.PAGE], s).then(() => vo(this._service, t, e, s).then((r) => ({ result: ur(r.result), response: r.response })));
  }
  blockDownloadAsset(t, e, s, r, n, o, i, a) {
    if (typeof t == "string") return Zr(this._service, t, e, s, r, n, o, i, a);
    const d = {};
    return this._withSourcePromise(d).then(() => this.fetchLinksIfMissing(t, [u.PRIMARY])).then(() => Zr.call(d, this._service, t, e, s, r, n, o, i, a));
  }
  fetchLinksIfMissing(t, e, s) {
    return dt(this.serviceConfig, t, e, void 0, s);
  }
  useLinkOrResolveResource(t, e, s, r) {
    return uo(this.serviceConfig, t, e, s, r).then((n) => (t.links !== n.result.links && (t.links = he(t.links || {}, n.result.links), this._linksCache.setValueWithAsset(t.links, t)), n));
  }
  getLinkHrefForAsset(t, e, s = "id", r) {
    return this.fetchLinksIfMissing(t, [e], r).then((n) => H(n, e, s));
  }
  getEffectivePrivileges(t, e) {
    return this.fetchLinksIfMissing(t, [u.EFFECTIVE_PRIVILAGES], e).then(() => io(this._service, t, e));
  }
  checkACLPrivilege(t, e, s, r) {
    return this.fetchLinksIfMissing(t, [u.ACCESS_CHECK], r).then(() => co(this._service, t, e, s, r));
  }
  headAppMetadata(t, e) {
    return this.fetchLinksIfMissing(t, [u.APP_METADATA], e).then(() => so(this.serviceConfig, t, e));
  }
  getAppMetadata(t, e, s) {
    return this.fetchLinksIfMissing(t, [u.APP_METADATA], s).then(() => ro(this._service, t, e, s));
  }
  putAppMetadata(t, e, s, r) {
    return this.fetchLinksIfMissing(t, [u.APP_METADATA], r).then(() => no(this._service, t, e, s, r));
  }
  patchAppMetadata(t, e, s, r) {
    return this.fetchLinksIfMissing(t, [u.APP_METADATA], r).then(() => oo(this._service, t, e, s));
  }
  getCompositeManifestUrl(t, e, s) {
    E(["asset", t, "object"], ["version", e, "string", !0]);
    const r = this._getAsAdobeAsset(t);
    return r.version = e || r.version, this.fetchLinksIfMissing(r, [u.MANIFEST], s).then(() => cs(this._service, r, e, s));
  }
  getCompositeManifest(t, e, s, r) {
    E(["asset", t, "object"], ["version", e, "string", !0], ["etag", s, "string", !0]);
    const n = this._getAsAdobeAsset(t);
    return n.version = e || n.version, this.fetchLinksIfMissing(n, [u.MANIFEST], r).then(() => Vc(this._service, n, e, s, r));
  }
  getManifestAndComponentsByPath(t, e, s, r, n) {
    return Hc(this.serviceConfig.service, t, e, s, r, n);
  }
  getRendition(t, e, s, r, n) {
    return this.fetchLinksIfMissing(t, [u.RENDITION]).then(() => Lc(this._service, t, e, s, r, n));
  }
  getCompositeComponentUrlForDownload(t, e, s, r, n) {
    var o;
    const i = this._getAsAdobeAsset(t), a = (o = this._isDCXComponentLike(t) ? t.length : s) !== null && o !== void 0 ? o : 0, { id: d, revision: h } = this._resolveComponentIdAndRevision(t, e, r);
    return a > this.blockDownloadThreshold ? Ro(this.serviceConfig, i, d, h, n).then(({ response: l, result: p }) => ({ response: l, isPresignedUrl: !0, url: p })) : this.getCompositeComponentUrl(i, d, h, n).then((l) => ({ response: void 0, url: l, isPresignedUrl: !1 }));
  }
  getCompositeComponentUrl(t, e, s, r) {
    const n = this._getAsAdobeAsset(t), { id: o, revision: i } = this._resolveComponentIdAndRevision(t, e, s, !1);
    return this.fetchLinksIfMissing(n, [u.COMPONENT], r).then(() => (E(["asset", n, "object"], ["componentId", o, "string"], ["componentRevision", i, "string", !0]), fr(this._service, n, o, i)));
  }
  getCompositeComponentByPath(t, e, s, r, n) {
    return Yc(this._service, this._getAsAdobeAsset(t), e, s, r, n);
  }
  getCompositeComponent(t, e, s, r, n, o) {
    const i = this._getAsAdobeAsset(t), { id: a, revision: d } = this._resolveComponentIdAndRevision(t, e, s);
    return i.assetId && pe("assetId", i.assetId), e && pe("componentId", e), o && pe("componentSize", String(o)), this.fetchLinksIfMissing(i, [u.COMPONENT], n).then(() => (E(["asset", t, "object"], ["componentId", a, "string"], ["componentRevision", d, "string"], ["responseType", r, "enum", !0, tr]), qc(this._service, i, a, d, r, n, this._isDCXComponentLike(t) ? t.length : o)));
  }
  putCompositeComponent(t, e, s, r, n, o, i, a, d, h) {
    if (E(["asset", t, "object"], ["componentId", e, "string"], ["contentType", r, "string"], ["maybeIsNew", n, "boolean", !0], ["size", o, "number", !0], ["md5", i, "string", !0]), n && !Wt(e)) throw new c(c.INVALID_PARAMS, "Component id is not a uuid");
    Wt(e) || ud.warn("Existing component id is not a uuid");
    const l = this._getAsAdobeAsset(t);
    return (l.assetId || l.id) && pe("assetId", l.assetId || l.id), pe("componentId", e), o && pe("componentSize", String(o)), this.fetchLinksIfMissing(l, [u.COMPONENT, u.BLOCK_UPLOAD_INIT], d).then(() => zc(this.serviceConfig, t, e, s, r, n, o, i, a, d, h));
  }
  getCompositeComponentsUrlsForUpload(t, e, s) {
    return Wc(this._service, t, e, s);
  }
  performBulkRequest(t, e, s, r) {
    return this.fetchLinksIfMissing(t, [u.BULK_REQUEST], r).then(() => os(this._service, t, e, s, r));
  }
  updateCompositeManifest(t, e, s, r = 1, n, o) {
    sn("updateCompositeManifest()"), E(["asset", t, "object"], ["manifest", e, ["object", "string"]], ["overwrite", s, "boolean"], ["validationLevel", r, "+number"], ["etag", n, "string", !0]);
    const i = this._getAsAdobeAsset(t);
    return this.fetchLinksIfMissing(i, [u.MANIFEST], o).then(() => xs(this._service, i, e, s, r, n, o));
  }
  patchVersions(t, e, s, r) {
    return E(["asset", t, "object"], ["patchDoc", e, ["string", "array"]], ["etag", s, "string", !0]), this.fetchLinksIfMissing(t, [u.VERSION_HISTORY], r).then(() => Uc(this._service, t, e, s, r));
  }
  patchACLPolicy(t, e, s, r) {
    return E(["asset", t, "object"], ["policy", e, ["string", "object"]], ["etag", s, "string", !0]), this.fetchLinksIfMissing(t, [u.VERSION_HISTORY], r).then(() => ho(this._service, t, e, s, r));
  }
  deleteACLPolicy(t, e) {
    return E(["asset", t, "object"]), this.fetchLinksIfMissing(t, [u.ACL_POLICY], e).then(() => lo(this._service, t, e));
  }
  copyAsset(t, e, s, r, n, o) {
    return xn(this.serviceConfig, t, e, s, r, n, o);
  }
  moveAsset(t, e, s, r, n) {
    return pe("sourceAsset.assetId", t.assetId), pe("targetAsset.assetId", e.assetId), Bn(this.serviceConfig, t, e, s, r, n);
  }
  deleteAsset(t, e, s, r) {
    return Vn(this.serviceConfig, { repositoryId: t.repositoryId, path: t.path, assetId: t.assetId }, e, s, r).then((n) => (this._linksCache.deleteWithAsset(t), n));
  }
  discardAsset(t, e, s, r) {
    return jn(this.serviceConfig, { repositoryId: t.repositoryId, path: t.path, assetId: t.assetId }, e, s, r);
  }
  restoreAsset(t, e) {
    return Fn(this.serviceConfig, t, e);
  }
  packageAssets(t, e, s, r, n) {
    return Hn(this.serviceConfig, t, e, s, r, n);
  }
  performOperation(t, e) {
    return De(this.serviceConfig, e).then((s) => je(this._service, s, t, e));
  }
  performBatchOperation(t, e) {
    return De(this.serviceConfig).then((s) => Za(this._service, s, t, e));
  }
  uploadResultsFromAdobeRepoUploadResult(t, e) {
    return ld(this, t, e);
  }
  updateCachedAssetLinks(t) {
    if (!t.assetId) throw new c(c.INVALID_PARAMS, "Asset must contain an assetId");
    this._linksCache.setValueWithAsset(t.links || t._links, t);
  }
  updateCachedIndexLinks(t) {
    if (!t) throw new c(c.INVALID_PARAMS, "Index LinkSet must not be null");
    this._linksCache.setIndexLinks(t);
  }
  getLinksCache() {
    return this._linksCache;
  }
  setLinksCache(t) {
    this._linksCache = t;
  }
  clearLinksCache() {
    this._linksCache.clear();
  }
  _resolveComponentIdAndRevision(t, e, s, r = !0) {
    var n;
    if (this._isDCXComponentLike(t)) return { revision: t.version, id: t.id };
    if (!e) throw new c(c.INVALID_PARAMS, "Missing componentId.");
    if (r === !1 || s) return { revision: s, id: e };
    if (!ws(t) || !e) throw new c(c.INVALID_PARAMS, "Could not determine component revision");
    const o = (n = t.current) === null || n === void 0 ? void 0 : n.getComponentWithId(e);
    if ((o == null ? void 0 : o.version) === void 0) throw new c(c.INVALID_PARAMS, "Could not determine component revision");
    return { revision: o.version, id: e };
  }
  _isDCXComponentLike(t) {
    return !!S(t) && t.owner != null && qr(t.owner);
  }
  _withSourcePromise(t) {
    return C.resolve(void 0, t);
  }
  _getAsAdobeAsset(t) {
    if (typeof t != "object" || Array.isArray(t)) throw new c(c.INVALID_PARAMS, "Invalid asset-like object.");
    if (Zt(t)) return t;
    let e, s = {};
    if (("repositoryId" in t || "assetId" in t || "links" in t || "version" in t) && (s = { repositoryId: t.repositoryId, assetId: t.assetId, links: t.links, version: t.version }), qr(t) && (e = t._core), this._isDCXComponentLike(t) || e) {
      const o = t, i = e || (o && o.owner && o.owner._core ? o.owner._core : void 0);
      if (i) {
        const a = i._getSourceAssetInfoOfComponent(s);
        a && typeof a == "object" && (s.assetId = a.compositeAssetId || s.assetId, s.repositoryId = a.compositeRepositoryId || s.repositoryId, s.links = a.links || s.links, s.version = a.version || s.version);
      }
    }
    const r = t, n = t;
    return s.assetId = s.assetId ? s.assetId : r.owner ? r.owner.compositeAssetId : n.compositeAssetId, s.repositoryId = s.repositoryId ? s.repositoryId : r.owner ? r.owner.compositeRepositoryId : n.compositeRepositoryId, s;
  }
  get authenticationAllowList() {
    return this._authenticationAllowList;
  }
  set authenticationAllowList(t) {
    if (!Array.isArray(t)) throw new c(c.INVALID_PARAMS, "Expecting an array.");
    this._authenticationAllowList = t;
  }
  _resolveUrl(t) {
    return Ss(t) ? t : an(this._service._repoAPIBaseUrl || this._service.server, t);
  }
  registerLinks(t, e, s) {
    t = t._links || t;
    const r = { assetId: s || "urn:aaid:faux:" + zt(), repositoryId: e || "faux-repo-id" };
    return this._linksCache.setValueWithAsset(t, r), r;
  }
};
rt([ft], Ge.prototype, "getRepoMetadata", null), rt([ft], Ge.prototype, "getAppMetadata", null), rt([ft], Ge.prototype, "getCompositeComponent", null), rt([ft], Ge.prototype, "putCompositeComponent", null), rt([ft], Ge.prototype, "moveAsset", null), Ge = rt([Ua("AdobeRepoAPISession")], Ge);
const pd = (t, e, s) => new Ge(t, e, s), _d = {
  local: "https://platform-cs-stage.adobe.io",
  stage: "https://platform-cs-stage.adobe.io",
  prod: "https://platform-cs.adobe.io"
}, fd = "AdobeExpressWeb", Ed = "assets", gd = "Failed to upload asset. Please try again.", Fe = {
  UPLOAD_FAILED: {
    code: "UPLOAD_FAILED",
    message: gd
  },
  URL_GENERATION_FAILED: {
    code: "URL_GENERATION_FAILED",
    message: "Failed to generate pre-signed URL"
  },
  REPOSITORY_REQUIRED: {
    code: "REPOSITORY_REQUIRED",
    message: "Repository is required for normal token uploads"
  },
  DIRECTORY_REQUIRED: {
    code: "DIRECTORY_REQUIRED",
    message: "Directory is required for normal token uploads"
  },
  REPOSITORY_REQUIRED_FOR_DIRECTORY: {
    code: "REPOSITORY_REQUIRED_FOR_DIRECTORY",
    message: "Repository is required for directory operations"
  },
  FAILED_TO_CREATE_ASSET: {
    code: "FAILED_TO_CREATE_ASSET",
    message: "Failed to create asset"
  }
}, Id = {
  UPLOAD_STATUS: "x-express-upload-status"
};
function Be(t, e, s, r) {
  return new (s || (s = Promise))(function(n, o) {
    function i(h) {
      try {
        d(r.next(h));
      } catch (l) {
        o(l);
      }
    }
    function a(h) {
      try {
        d(r.throw(h));
      } catch (l) {
        o(l);
      }
    }
    function d(h) {
      var l;
      h.done ? n(h.value) : (l = h.value, l instanceof s ? l : new s(function(p) {
        p(l);
      })).then(i, a);
    }
    d((r = r.apply(t, [])).next());
  });
}
const Pe = x("dcx:http:auth");
class Bt {
  constructor(e, s, r) {
    this._authToken = e, this._apiKey = s, this._pendingAuth = !1, this._hasBaseRefreshCb = !1, this._authListeners = [], this._persistentListeners = [], this._authenticationAllowList = ["adobe.com", "adobe.io", "adobelogin.com", "fotolia.net"], this._authTokenScheme = "Bearer", E(["authToken", e, "string", !0], ["apiKey", s, "string", !0], ["refreshCb", r, "function", !0]), r && (this._hasBaseRefreshCb = !0, this.onChange((n, o) => {
      n === "unauthenticated" && r.call(null, o);
    }, !0)), e && s || (Pe("init unauthenticated"), this._pendingAuth = !0, setTimeout(() => {
      Pe("after tick", this._pendingAuth), this._pendingAuth && this.refreshAuth();
    }));
  }
  get authenticationAllowList() {
    return this._authenticationAllowList;
  }
  set authenticationAllowList(e) {
    if (!Array.isArray(e)) throw new c(c.INVALID_PARAMS, "Expecting an array.");
    this._authenticationAllowList = e;
  }
  get isNoAuthMode() {
    return !this._hasBaseRefreshCb;
  }
  set isNoAuthMode(e) {
    this._hasBaseRefreshCb = !e;
  }
  get apiKey() {
    return this._apiKey;
  }
  get authToken() {
    return this._authToken;
  }
  get authTokenScheme() {
    return this._authTokenScheme;
  }
  set authTokenScheme(e) {
    this._authTokenScheme = e;
  }
  setAuthToken(e) {
    Pe("setAuthToken"), this._authToken = e, this._pendingAuth = !1, this._authChanged("updated");
  }
  setApiKey(e) {
    this._apiKey = e;
  }
  resume() {
    Pe("resume()"), this._pendingAuth = !1, this._authChanged("updated");
  }
  get pendingAuth() {
    return this._pendingAuth;
  }
  onChange(e, s = !1) {
    Pe("onChange, persistent:", s);
    const r = this._authListeners.push(e) - 1;
    return s && this._persistentListeners.push(r), () => {
      try {
        s && (this._persistentListeners = this._persistentListeners.filter((n) => n !== r)), delete this._authListeners[r];
      } catch {
      }
    };
  }
  clearListeners(e = !1) {
    if (Pe("clearListeners, persistent:", e), e === !0) return this._authListeners = [], void (this._persistentListeners = []);
    this._authListeners = this._authListeners.map((s, r) => {
      if (this._persistentListeners.includes(r)) return s;
    });
  }
  get refreshPromise() {
    return this._refreshPromise;
  }
  _authChanged(e) {
    return Be(this, void 0, void 0, function* () {
      Pe("authChanged", e), this._pendingAuth = e === "unauthenticated", queueMicrotask(() => Be(this, void 0, void 0, function* () {
        const s = [];
        this._authListeners.map((r) => {
          if (typeof r == "function") {
            const n = r.call(null, e, this);
            n && typeof n == "object" && n.then && s.push(n);
          }
        }), yield Promise.all(s), e === "updated" && this._resolveRefresh();
      }));
    });
  }
  _resolveRefresh() {
    Pe("_resolveRefresh"), this._refreshResolve && this._refreshResolve(this.getAuthData()), this._refreshResolve = void 0, this._refreshPromise = void 0;
  }
  refreshAuth() {
    return Pe("refreshAuth"), this._refreshPromise || (this._refreshPromise = new Promise((e) => {
      this._refreshResolve = e;
    }), this._authChanged("unauthenticated")), this._refreshPromise;
  }
  getAuthData() {
    return { authToken: this._authToken, apiKey: this._apiKey };
  }
  getAuth() {
    return Be(this, void 0, void 0, function* () {
      return Promise.resolve(this.getAuthData());
    });
  }
  isAuthorizedURL(e) {
    const s = Wo(e);
    return this._authenticationAllowList.includes(s);
  }
  logout() {
    Pe("logout"), this._apiKey = void 0, this._authToken = void 0, this._pendingAuth === !1 && (this._pendingAuth = !0, this._authChanged("unauthenticated"));
  }
  applyAuthHeaders(e, s) {
    const r = { "x-api-key": void 0, authorization: void 0 };
    return this.isAuthorizedURL(e) && (s["x-api-key"] !== null && this.apiKey && (r["x-api-key"] = this.apiKey), s.authorization !== null && this.authToken && (r.authorization = (this.authTokenScheme ? `${this.authTokenScheme} ` : "") + this.authToken)), s = w(Object.assign(Object.assign({}, s), r));
  }
}
const Bs = 12e4, Rs = 36e5, me = x("dcx:http:xhr");
let js;
if (js = typeof window < "u" ? window.XMLHttpRequest : XMLHttpRequest, js == null) throw new c(c.INVALID_STATE, "XMLHttpRequest module not found.");
const te = { NO_ERROR: "", ABORTED: I.ABORTED, NETWORK: I.NETWORK_ERROR, TIMEOUT: I.TIMED_OUT, TOO_MANY_REDIRECTS: I.TOO_MANY_REDIRECTS, INSECURE_REDIRECT: I.INSECURE_REDIRECT };
class Td {
  constructor(e = {}) {
    this._autoParseJson = !1, this._bytesReported = 0, this._errorCode = te.NO_ERROR, this._isFetchRequest = !1, this._fetchAbort = () => {
    }, this._preferFetch = !1, this._sent = !1, this.headers = {}, this.responseType = "text", this._progressListeners = [];
    const { forceXhr: s, preCallback: r, postCallback: n, timeout: o, preferFetch: i } = e;
    this._preCallback = r, this._postCallback = n, this._timeout = o == null || o < 0 ? Bs : o, this._xhr = s ? new s() : new js(), this._xhr.timeout = Rs, this._preferFetch = i === !0, this._fetch = e.fetch ? e.fetch : typeof window < "u" && "fetch" in window && typeof window.fetch == "function" ? window.fetch.bind(window) : typeof self < "u" && "fetch" in self && typeof self.fetch == "function" ? self.fetch.bind(self) : typeof globalThis < "u" && "fetch" in globalThis && typeof globalThis.fetch == "function" ? globalThis.fetch.bind(globalThis) : void 0, this._parseFetchResponse = this._parseFetchResponse.bind(this), this.onProgress = this.onProgress.bind(this), this._autoParseJson = e.autoParseJson == null || e.autoParseJson, e.additionalNodeOptions && this._xhr.setNodeOptions && this._xhr.setNodeOptions(e.additionalNodeOptions), this._promise = new Promise((a) => {
      this._resolve = a, this._xhr.addEventListener("abort", () => {
        me("aborted", this._errorCode, this._timeout), this._errorCode = this._errorCode || te.ABORTED, this._finalize();
      }), this._xhr.addEventListener("error", (d) => {
        switch (me("err", this._errorCode, d, this._xhr.status, this._timeout), this._underlyingError = d, d ? d.code : void 0) {
          case "ERR_FR_TOO_MANY_REDIRECTS":
            this._errorCode = te.TOO_MANY_REDIRECTS;
            break;
          case c.INSECURE_REDIRECT:
            this._errorCode = te.INSECURE_REDIRECT;
            break;
          case te.TIMEOUT:
            this._errorCode = te.TIMEOUT;
            break;
          default:
            this._errorCode = te.NETWORK;
        }
        this._finalize();
      }), this._xhr.addEventListener("load", () => {
        me("load"), this._estimatedTotalBytes && this._estimatedTotalBytes > this._bytesReported && this._notifyProgressListeners(this._estimatedTotalBytes, this._estimatedTotalBytes, !1), this._finalize();
      }), this._xhr.addEventListener("timeout", () => {
        me("timeout", Rs), this._errorCode = te.TIMEOUT, this._finalize();
      });
    });
  }
  get xhr() {
    return this._xhr;
  }
  _parseFetchResponse(e) {
    return Be(this, void 0, void 0, function* () {
      if (e.status === 204) return e;
      if (e.headers.get("transfer-encoding") === "chunked" || parseInt(e.headers.get("content-length") || "0") > 0) switch (this.responseType) {
        case "json":
          Or(e.headers.get("content-type") || "") && (this._fetchBodyAsResponseType = yield e.json());
          break;
        case "arraybuffer":
          this._fetchBodyAsResponseType = yield e.arrayBuffer();
          break;
        case "blob":
          this._fetchBodyAsResponseType = yield e.blob();
          break;
        case "text":
          this._fetchBodyAsResponseType = yield e.text();
          break;
        case "void":
          break;
        case "buffer":
        case "defaultbuffer":
          this._fetchBodyAsResponseType = yield e.arrayBuffer().then((s) => new Uint8Array(s));
      }
      return this.responseType === "stream" && (this._fetchBodyAsResponseType = e.body), e;
    });
  }
  _shouldAutoParseResponse() {
    const e = this._errorCode === te.NO_ERROR && this._sent && !this._isFetchRequest && this._xhr.responseType === "text" && this._autoParseJson && typeof this._xhr.response == "string" && this._xhr.response.length < 102400 && Or(this.getResponseHeader("content-type"));
    return me("_shouldAutoParseResponse()", e), e;
  }
  _fetchWithTimeout(e, s = {}) {
    if (typeof this._fetch != "function") throw new c(c.UNEXPECTED, "fetch method not found but was invoked");
    const { timeout: r } = s, n = function(a, d) {
      var h = {};
      for (var l in a) Object.prototype.hasOwnProperty.call(a, l) && d.indexOf(l) < 0 && (h[l] = a[l]);
      if (a != null && typeof Object.getOwnPropertySymbols == "function") {
        var p = 0;
        for (l = Object.getOwnPropertySymbols(a); p < l.length; p++) d.indexOf(l[p]) < 0 && Object.prototype.propertyIsEnumerable.call(a, l[p]) && (h[l[p]] = a[l[p]]);
      }
      return h;
    }(s, ["timeout"]);
    this._isFetchRequest = !0;
    const o = (a) => () => {
      this._errorCode = this._errorCode || te.TIMEOUT, a(new c(c.TIMED_OUT, "request aborted due to timeout")), this._finalize();
    };
    if (typeof AbortController != "function") return new Promise((a, d) => Be(this, void 0, void 0, function* () {
      this._timeoutTimeout = setTimeout(o(d), r);
      const h = yield this._fetch(e, n);
      return clearTimeout(this._timeoutTimeout), this._parseFetchResponse(h).then(a);
    })).finally(() => {
      clearTimeout(this._timeoutTimeout);
    });
    const i = new AbortController();
    return this._timeoutTimeout = setTimeout(o(i.abort.bind(i)), r), this._fetchAbort = () => {
      this._errorCode = this._errorCode || te.ABORTED, i.abort(), this._finalize();
    }, new Promise((a, d) => {
      this._fetch(e, Object.assign({ signal: i.signal }, n)).then((h) => (clearTimeout(this._timeoutTimeout), this._parseFetchResponse(h))).then(a).catch((h) => {
        clearTimeout(this._timeoutTimeout), d(h);
      });
    });
  }
  _finalize() {
    if (me("_finalize", this._xhr.status, this._errorCode), this._shouldAutoParseResponse()) try {
      const e = JSON.parse(this._xhr.response);
      this._autoParsedResponse = e, this._xhr.responseType = "json";
    } catch {
    }
    this._postCallback && this._postCallback(this), this._timeoutTimeout && clearTimeout(this._timeoutTimeout), this._progressListeners = [], this._resolve(this);
  }
  _validateResponseType(e) {
    if (e === "buffer") {
      if (typeof Buffer != "function") throw new c(c.INVALID_PARAMS, "No Buffer class");
    } else if (e === "blob") {
      if (typeof Blob != "function") throw new c(c.INVALID_PARAMS, "No Blob class");
    } else if (e !== "text" && e !== "json" && e !== "arraybuffer" && e !== "stream") throw new c(c.INVALID_PARAMS, "Unsupported response type");
    return e.toLowerCase();
  }
  inactivityTimer() {
    this._timeoutTimeout && clearTimeout(this._timeoutTimeout), this._timeoutTimeout = setTimeout(() => {
      this.timedOut();
    }, this._timeout);
  }
  send(e, s, r, n = {}, o = "text", i = {}) {
    if (me("send"), this._sent) throw new Error("Xhr already sent");
    this.href = e, this.method = s.toUpperCase(), this.body = r, this.body ? this._estimatedTotalBytes = this.body.byteLength || this.body.length || this.body.size : this._estimatedTotalBytes = Number.MAX_SAFE_INTEGER;
    const a = (h) => {
      var l;
      me(`progress ${h.loaded}/${h.total}`), this._bytesReported = h.loaded, this.inactivityTimer(), h.lengthComputable ? (this._estimatedTotalBytes = h.total, this._notifyProgressListeners(this._bytesReported, (l = this._estimatedTotalBytes) !== null && l !== void 0 ? l : 1 / 0, !1)) : this._estimatedTotalBytes && this._estimatedTotalBytes > this._bytesReported && this._notifyProgressListeners(this._bytesReported, this._estimatedTotalBytes || h.total, !0);
    };
    ["POST", "PUT", "PATCH"].includes(this.method) && this._xhr.upload ? this._xhr.upload.onprogress = a : this._xhr.addEventListener("progress", a), this._timeout = i.timeout || this._timeout || Bs, me("setting timeout", this._timeout), this._xhr.timeout = Rs, o && (o = this._validateResponseType(o), me("responseType: ", o), this.responseType = o === "buffer" ? "arraybuffer" : o === "stream" ? "stream" : o === "void" ? "text" : o);
    const d = Ot(n);
    if (this.headers = d, this.href.startsWith("http:") && this.headers.authorization !== null) throw new c(c.INVALID_PARAMS, "Must not send auth token over unsecured connection");
    if (this._preCallback && this._preCallback(this), (this._preferFetch || o === "stream") && typeof this._fetch == "function") return this._xhr.responseType = this.responseType, this._promise = new Promise((h, l) => {
      this._resolve = h, this._fetchWithTimeout(this.href, { body: ["GET", "HEAD"].includes(this.method.toUpperCase()) ? void 0 : r, credentials: i.withCredentials ? "include" : void 0, headers: d, method: this.method, timeout: this._timeout }).then((p) => {
        this._fetchResponse = p, this._finalize();
      }).catch((p) => {
        l(p);
      }), this._sent = !0;
    }), this._promise;
    this._xhr.open(this.method, this.href, !0), this._xhr.responseType = this.responseType;
    for (const [h, l] of Object.entries(d)) this._xhr.setRequestHeader(h, l);
    return i.withCredentials != null && (this._xhr.withCredentials = i.withCredentials), this.inactivityTimer(), r != null ? this._xhr.send(r) : this._xhr.send(), this._sent = !0, this._promise;
  }
  abort() {
    if (me("abort()"), !this._sent) throw new Error("Cannot abort before sending.");
    this._isFetchRequest ? this._fetchAbort() : this._xhr.abort();
  }
  timedOut() {
    if (me("timedOut()"), !this._sent) throw new Error("Cannot timed out before sending.");
    this._isFetchRequest || (this._xhr.abort(), this._errorCode = te.TIMEOUT, this._finalize());
  }
  getResponseHeader(e) {
    if (!this._sent) throw new Error("Cannot getResponseHeader before sending.");
    const s = e.toLowerCase(), r = this.getAllResponseHeaders();
    if (s in r) return r[s];
  }
  getAllResponseHeaders() {
    var e, s;
    if (!this._sent) throw new Error("Cannot getAllResponseHeaders before sending.");
    if (this._parsedResponseHeaders) return this._parsedResponseHeaders;
    const r = this._isFetchRequest ? Qo((s = (e = this._fetchResponse) === null || e === void 0 ? void 0 : e.headers.entries()) !== null && s !== void 0 ? s : []) : this._xhr.getAllResponseHeaders();
    return this._parsedResponseHeaders = typeof r == "string" ? Ys(r) : Ot(r), this._parsedResponseHeaders;
  }
  isError() {
    if (!this._sent) throw new Error("Cannot check isError before sending.");
    return this._errorCode !== te.NO_ERROR;
  }
  isAborted() {
    if (!this._sent) throw new Error("Cannot check isAborted before sending.");
    return this._errorCode === te.ABORTED;
  }
  isTimedOut() {
    if (!this._sent) throw new Error("Cannot check isTimedOut before sending.");
    return this._errorCode === te.TIMEOUT;
  }
  isSent() {
    return this._sent;
  }
  getErrorCode() {
    return this._errorCode;
  }
  getStatus() {
    if (!this._sent) throw new Error("Cannot getStatus before sending.");
    return this._fetchResponse ? this._fetchResponse.status : this._xhr.status;
  }
  getResponse() {
    var e;
    if (!this._sent) throw new Error("Cannot getResponse before sending.");
    return this._response || (this._response = { statusCode: this.getStatus(), headers: this.getAllResponseHeaders(), responseType: this._autoParsedResponse ? "json" : this.responseType, response: this.getResponseData(), message: this._isFetchRequest ? ((e = this._fetchResponse) === null || e === void 0 ? void 0 : e.statusText) || "" : this._xhr.statusText, xhr: this }, this._autoParsedResponse && (this._response.originalResponseData = this._xhr.response)), this._response;
  }
  toJSON() {
    return { statusCode: this.getStatus(), headers: this.getAllResponseHeaders(), responseType: this._autoParsedResponse ? "json" : this.responseType, response: this.getResponseData(), message: this._xhr.statusText };
  }
  getResponseDataAsJSON() {
    return Be(this, void 0, void 0, function* () {
      try {
        if (this._fetchResponse) return yield this._fetchResponse.json();
        if (this._autoParsedResponse) return this._autoParsedResponse;
        if (this._xhr.responseType === "json") {
          if (typeof this._xhr.response == "string") return JSON.parse(this._xhr.response);
          if (this.xhr.response === null && ["application/problem+json", "application/json"].includes(this.xhr.getResponseHeader("content-type"))) throw new c(c.UNEXPECTED, "Unexpected response type");
          return this.xhr.response;
        }
        let e = this._xhr.response;
        if (this._xhr.responseType === "text" && this._xhr.responseText !== null) e = this._xhr.responseText;
        else if (this._xhr.responseType === "arraybuffer") e = ye(this._xhr.response);
        else {
          if (this._xhr.responseType === "blob" && (e instanceof Blob || q(e.text))) return JSON.parse(yield e.text());
          this.responseType === "stream" ? yield new Promise((s, r) => {
            if (e = "", typeof this.xhr.response.on == "function") return this.xhr.response.on("data", (n) => {
              e += n;
            }), this.xhr.response.on("end", s), void this.xhr.response.on("error", r);
            if (typeof this.xhr.response == "string") return s(e = this.xhr.response);
            throw new c(c.UNEXPECTED, "Unexpected response type");
          }) : e = this._xhr.responseText ? this._xhr.responseText : e;
        }
        return typeof e == "string" ? JSON.parse(e) : e;
      } catch (e) {
        throw new c(c.INVALID_JSON, "Could not parse response as JSON", e, this.toJSON());
      }
    });
  }
  getResponseData() {
    if (!this._sent) throw new Error("Cannot getResponseData before sending.");
    return this._isFetchRequest && this._fetchBodyAsResponseType ? this._fetchBodyAsResponseType : this._autoParsedResponse || this._xhr.response;
  }
  onProgress(e) {
    const s = this._progressListeners.push(e) - 1;
    return () => {
      try {
        delete this._progressListeners[s];
      } catch {
      }
    };
  }
  _notifyProgressListeners(e, s, r) {
    this._progressListeners.map((n) => n && n.call && n.call(null, e, s, r));
  }
}
const He = x("dcx:http:backoff");
function Ad(t, e, s, r = {}, n, o = {}, i = !1) {
  const { disableRetry: a = !1, retryNetworkError: d = !0, responseType: h = "text", authCallback: l = null, progressListeners: p = [], initialWait: _ = 2e3, maxWait: f = 32e3, preCallback: A, postCallback: y, preScheduleCallback: b, postScheduleCallback: v, preferRetryAfterHeader: P = !0, pollCodes: m = [], pollHeader: D, pollMethod: k = "get", problemWithCode: j = { problemType: "", code: null, url: "" }, modifyHeadersCallback: J = null } = o;
  let { retryCodes: G = [], timeoutAfter: ve = 72e3 } = o;
  G = i ? [...m, ...G] : a || Go(s) ? [] : o.retryCodes || ln, He("retry codes", G);
  const ke = o.increase || ((W, ee, M) => W === 1 ? M : ee * ee > f ? f : ee * ee);
  let Q = 0, le = 0, Ae = !1;
  const ze = ie();
  let Le, ae, be, ue, ht = ie(), We = 0, kt = !1, gr = !1;
  const Ir = [];
  let Tr;
  function Lt() {
    He("getSnapshot()", Ae, Q, ie(), ht, We);
    const W = Ae || Le != null ? 0 : Q - (ie() - ht);
    let ee = We;
    ee += Ae ? ie() - ht : 0;
    const M = (Le || ie()) - ze;
    return { count: le, canceled: kt, timedOut: gr, requests: Ir, duration: M, totalWaited: ee, requestPending: Ae, waitingFor: W };
  }
  function Ar() {
    const W = ke(le, Q, _);
    return Math.min(W, f);
  }
  function mr(W) {
    if (W) return (ee) => W(ee, Lt());
  }
  function yr(W) {
    const ee = W.getResponseHeader("retry-after");
    if (P && ee) {
      if (isNaN(ee)) {
        const M = Date.parse(ee) - Date.now();
        return He("nextWait from retry-after", M), M < 0 ? Ar() : M;
      }
      return 1e3 * parseInt(W.getResponseHeader("retry-after"));
    }
  }
  function st(W = Q) {
    return Be(this, void 0, void 0, function* () {
      if (We >= ve) return He("timed out", We, ve), gr = !0, ae(ue);
      ht = ie(), b && (yield b(Lt())), He("retry in ", W), Tr = setTimeout(() => {
        var ee;
        try {
          He("retry start"), jr(`Request: ${e.toUpperCase()} ${t} ${(ee = r == null ? void 0 : r["x-request-id"]) !== null && ee !== void 0 ? ee : ""}`), Ae = !0, We += W, ue = new Td(Object.assign(Object.assign({}, o), { timeout: n, preCallback: mr(A), postCallback: mr(y) })), Ir.push(ue), le++;
          for (const M of p) ue.onProgress(M);
          ue.send(t, e, s, r, h).then((M) => Be(this, void 0, void 0, function* () {
            var ls, us, ps;
            if (jr(`Response: ${e.toUpperCase()} ${t} ${(ls = M.headers) === null || ls === void 0 ? void 0 : ls["x-request-id"]} ${M.getStatus()}`), Ae = !1, !M.isError() && !gt(M.getStatus(), G) && (M.getStatus() !== 401 || l == null) && (typeof D != "string" || m == null || !gt(M.getStatus(), m)) || (j == null ? void 0 : j.code) === M.getStatus() && M.getResponseData() && (j == null ? void 0 : j.problemType) !== ((us = yield M.getResponseDataAsJSON()) === null || us === void 0 ? void 0 : us.type)) return Le = ie(), ae(M);
            if (M.isAborted() || kt) return Le = ie(), kt = !0, ae(M);
            if (!i && typeof D == "string" && m != null && gt(M.getStatus(), m)) {
              const lt = M.getResponseHeader(D.toLowerCase()), ut = j.url, vr = ut && j.code === M.getStatus() && j.problemType === ((ps = M.getResponseData()) === null || ps === void 0 ? void 0 : ps.type);
              if (lt || vr) {
                i = !0, t = vr ? ut : lt, e = k, s = void 0, J && (r = J(r)), G = [...G, ...m], We = 0, ve *= 3;
                const Mo = M.getResponseHeader("retry-after");
                if (P && Mo) {
                  const br = yr(M);
                  if (br != null) return Q = br, st(Q);
                }
                return st(0);
              }
            }
            if (M.getStatus() === 401) {
              if (l) {
                try {
                  r = yield l(t, r);
                } catch {
                  return be(new c(c.UNAUTHORIZED, "Authentication Failed", M));
                }
                return We += ie() - ht, st(0);
              }
              return Le = ie(), be(new c(c.UNAUTHORIZED, "Authentication Failed", M));
            }
            if (gt(M.getStatus(), G) || d && M.getErrorCode() === I.NETWORK_ERROR) {
              const lt = M.getResponseHeader("retry-after");
              if (P && lt) {
                const ut = yr(M);
                if (ut != null) return Q = ut, st(Q);
              }
              return Q = Ar(), st(Q);
            }
            return Le = ie(), ae(M);
          })).catch((M) => {
            be(M);
          });
        } catch (M) {
          be(M);
        }
      }, W), v && (yield v(Lt()));
    });
  }
  const wo = new Promise((W, ee) => {
    ae = W, be = ee, st(0);
  });
  return { getPromise: () => wo, cancel: function() {
    He("cancel()"), kt = !0, ue != null && ue.abort(), Ae || (He("abort"), clearTimeout(Tr), ae({ getErrorCode: () => te.ABORTED }));
  }, onProgress: function(W) {
    if (!p.includes(W)) return p.push(W), ue != null ? ue.onProgress && ue.onProgress(W) : void 0;
  }, getSnapshot: Lt };
}
class md {
  constructor(e, s, r, n, o = "text", i, a, d = {}) {
    const { descriptor: h } = d;
    delete d.descriptor;
    const { cancel: l, getPromise: p, onProgress: _, getSnapshot: f } = Ad(e, s, r, n, d.timeout, Object.assign(Object.assign(Object.assign(Object.assign({}, d), { responseType: o, authCallback: a }), d.retryOptions), { descriptor: h, forceXhr: d.forceXhr, autoParseJson: d.autoParseJson }));
    this.onProgress = _, typeof i == "function" && _((A, y) => i("progress", { total: y, sentOrReceived: A })), this._cancel = l, this._promise = p(), this._getSnapshot = f;
  }
  getSnapshot() {
    return this._getSnapshot();
  }
  getPromise() {
    return this._promise;
  }
  cancel(e) {
    this._cancel(e);
  }
}
const Os = x("dcx:http:req");
class hs {
  constructor(e) {
    var s;
    if (this._pausable = !1, this._listeners = { progress: [], cancel: [] }, this._isStatusValid = e.isStatusValid || Yt, this._isExternalRequest = e.isExternalRequest, this._authProvider = e.authProvider, this._id = e.id, this._descriptor = e.descriptor, e.descriptor && e.descriptor.progress) {
      const n = e.descriptor.progress;
      this.on("progress", ({ sentOrReceived: o, total: i }) => {
        n.call(void 0, o, i);
      });
    }
    const r = this._authProvider.applyAuthHeaders(e.url, Ot(e.headers || {}));
    this._isExternalRequest && hs._internalOnlyHeaders.forEach((n) => delete r[n]), this._networkRequest = new md(e.url, e.method, e.body, r, e.responseType, !((s = e.descriptor) === null || s === void 0) && s.progress ? this._emit.bind(this) : void 0, this._getAuthCb(), e), this._promise = this._networkRequest.getPromise().then((n) => {
      const o = n.getErrorCode(), i = o || this._isStatusValid(n.getStatus(), n.getResponse());
      if (o || i !== !0)
        throw o === te.ABORTED ? new c(c.ABORTED, "Aborted") : o === te.NETWORK ? new c(c.NETWORK_ERROR, "Network error", void 0, n.getResponse()) : o === te.TIMEOUT ? new c(c.TIMED_OUT, "Timeout", void 0, n.getResponse()) : i instanceof c || i instanceof Error ? new c(i.code || c.UNEXPECTED_RESPONSE, i._message || i.message, i.underlyingError, n.getResponse()) : new c(c.UNEXPECTED_RESPONSE, "Unexpected response", void 0, n.getResponse());
      const a = this._networkRequest.getSnapshot().requests;
      return Os("resolve", e.id), Object.assign(Object.assign({}, n.getResponse()), { xhr: a[a.length - 1] });
    }).catch((n) => {
      throw Os("reject", e.id), n;
    });
  }
  get id() {
    return this._id;
  }
  get descriptor() {
    return this._descriptor;
  }
  _getAuthCb() {
    if (!this._authProvider.isNoAuthMode) return this._authCb.bind(this);
  }
  _authCb(e, s) {
    return Os("_authCb()"), this._authProvider.isAuthorizedURL(e) ? this._authProvider.refreshAuth().then(() => this._authProvider.applyAuthHeaders(e, s)) : Promise.reject(new c(c.UNAUTHORIZED, "URL is not part of authenticationAllowList.", void 0, void 0, { url: e }));
  }
  _emit(e, s) {
    this._listeners[e].map((r) => r.call(null, s));
  }
  getPromise() {
    return this._promise;
  }
  cancel(e) {
    return this._networkRequest.cancel(e);
  }
  on(e, s) {
    var r;
    e === "progress" && this._listeners[e].length === 0 && ((r = this._networkRequest) === null || r === void 0 || r.onProgress((n, o) => this._emit(e, { total: o, sentOrReceived: n }))), this._listeners[e].push(s);
  }
}
hs._internalOnlyHeaders = ["x-request-id", "x-api-key", "authorization"];
const yd = (t) => new hs(t), Ps = x("dcx:http:map");
class vd {
  constructor() {
    this._map = /* @__PURE__ */ new Map();
  }
  addRequest(e, s) {
    return Ps("addRequest()", e), this._map.set(e, s), s.getPromise().then((r) => {
      Ps("then", e), this._map.delete(e);
    }).catch((r) => {
      Ps("catch", e, r), this._map.delete(e);
    }), e;
  }
  get(e) {
    return this._map.get(e);
  }
  get length() {
    return this._map.size;
  }
  has(e) {
    return this._map.has(e);
  }
  removeById(e) {
    const s = this._map.get(e);
    s && this.remove(s);
  }
  remove(e, s) {
    return e && e.cancel && e.cancel(s);
  }
  clear(e) {
    this._map.forEach((s) => {
      this.remove(s, e);
    }), this._map.clear();
  }
  removeAllWithToken(e) {
    this._map.forEach((s) => {
      s.descriptor.token === e && this.remove(s);
    });
  }
}
const jt = x("dcx:http:q"), bd = (t) => t.method.toLowerCase() === "head";
class Rd {
  constructor() {
    this._queue = [], this._later = {}, this._headEndPtr = 0, this._isPriority = bd, this._usePriority = !1;
  }
  push(e, s, r) {
    return Be(this, void 0, void 0, function* () {
      let n;
      const o = new Promise((h) => {
        n = h;
      });
      if (typeof s != "number" || s <= 0) {
        const h = { descriptor: e, notifySent: (l) => n(l), notifyCanceled: this._notifyCanceled(n) };
        return this._push(h), o;
      }
      const { id: i } = e, a = setTimeout(() => {
        this._ready(i);
      }, s), d = (h) => n(h);
      return this._later[i] = { readyTimeout: a, wait: s, descriptor: e, notifySent: d, notifyCanceled: this._notifyCanceled(n), notifyReady: () => {
        r && r.call(null, { wait: s, descriptor: e, notifySent: d });
      } }, o;
    });
  }
  _notifyCanceled(e) {
    return (s) => {
      if (!s) return e({ canceled: !0 });
      e({ canceled: !0, error: s });
    };
  }
  _push(e) {
    this._usePriority && this._isPriority(e.descriptor) ? this._queue.splice(this._headEndPtr++, 0, e) : this._queue.push(e);
  }
  remove(e) {
    if (e.id in this._later) return jt("remove from later", e.id), this._remove(e.id);
    const s = this._indexOf(e);
    return jt("remove from q", s), s >= 0 ? this._remove(s) : void 0;
  }
  _remove(e, s) {
    if (jt("_remove", e), typeof e == "string") {
      const r = this._later[e];
      return r.notifyCanceled.call(null, s), r.readyTimeout && clearTimeout(r.readyTimeout), void delete this._later[e];
    }
    this._queue[e].notifyCanceled.call(null, s), this._queue.splice(e, 1), e < this._headEndPtr && this._headEndPtr--;
  }
  _indexOf(e) {
    const s = !!e.method, r = s && this._usePriority && this._isPriority(e), n = r ? this._headEndPtr : this._queue.length, o = r || !s ? 0 : this._headEndPtr;
    for (let i = o; i < o + n; i++) if (e.id === this._queue[i].descriptor.id) return i;
    return -1;
  }
  exists(e) {
    return e.id in this._later || this._indexOf(e) >= 0;
  }
  _ready(e) {
    const s = this._later[e], r = s.notifyReady;
    delete this._later[e], delete s.notifyReady, delete s.readyTimeout, delete s.wait, this._push(s), typeof r == "function" && r.call(null);
  }
  pop() {
    const e = this._queue.shift();
    return this._headEndPtr > 0 && this._headEndPtr--, e;
  }
  get length() {
    return jt("length: ", this._queue.length, Object.keys(this._later).length), this._queue.length + Object.keys(this._later).length;
  }
  clear(e) {
    for (let r = this._queue.length - 1; r >= 0; r--) this._remove(r, e);
    this._queue = [];
    const s = Object.keys(this._later);
    for (const r in s) {
      const n = s[r];
      this._remove(n, e);
    }
    this._later = {};
  }
  removeAllWithToken(e) {
    for (let r = this._queue.length - 1; r >= 0; r--) this._queue[r].descriptor.token === e && this._remove(r);
    const s = Object.keys(this._later);
    for (const r in s) {
      const n = s[r];
      this._later[n].descriptor.token === e && this._remove(n);
    }
  }
}
const K = x("dcx:http:service"), nn = 3e5;
class Od {
  constructor(e, s = {}) {
    this.name = "AdobeHTTPService", this._requestQueue = new Rd(), this._requestsOutstanding = new vd(), this._authProvider = void 0, this._isActive = !0, this._preferFetch = !1, this._handlesRedirects = !0, this._withCredentials = !1, this._additionalNodeOptions = {}, this._retryOptions = {}, this._serviceGuid = zt(), this._reqNum = 0, this.featureFlags = {}, e instanceof Bt || S(e) && q(e.onChange) ? this._authProvider = e : q(e) && (s.useAuthProvider ? (this._authProvider = new Bt(void 0, void 0, e), this._waitingForAuthentication = !0) : (this._authProvider = new Bt(void 0, void 0, () => e.call(null, this)), this._waitingForAuthentication = !0)), this._authProvider ? this._authProvider.onChange(this._onAuthChange.bind(this)) : (this._authProvider = new Bt(), this._authProvider.resume()), this._maxOutstanding = s.maxOutstanding || 5, this._withCredentials = s.crossOriginCredentials || !1, this._timeout = s.timeout == null ? Bs : s.timeout, this._preferFetch = s.preferFetch === !0, this._requestIdPrefix = s.requestIdPrefix, s.server && (this.server = s.server);
  }
  get isActive() {
    return this._isActive;
  }
  set isActive(e) {
    this._isActive !== e && (this._isActive = e, e || this._authProvider.logout(), this._checkQueue());
  }
  get crossOriginCredentials() {
    return this._withCredentials;
  }
  set crossOriginCredentials(e) {
    this._withCredentials = e;
  }
  get maxOutstanding() {
    return this._maxOutstanding;
  }
  set maxOutstanding(e) {
    this._maxOutstanding = e, this._checkQueue();
  }
  get handlesRedirects() {
    return this._handlesRedirects;
  }
  get server() {
    return this._server;
  }
  set server(e) {
    this._server = e && e.endsWith("/") ? e.substr(0, e.length - 1) : e;
  }
  _forceXhr(e, s = !1) {
    this._forcedXhr = e, this._handlesRedirects = !s;
  }
  _useFetchApi(e) {
    this._fetch = e;
  }
  setAdditionalHeaders(e) {
    this._additionalHeaders = e || {};
  }
  setValidateStatus(e) {
    this._isStatusValid = e;
  }
  setAdditionalNodeOptions(e) {
    this._additionalNodeOptions = e, qt() && e && e.maxRedirects === 0 && (this._handlesRedirects = !1);
  }
  setRetryOptions(e) {
    this._retryOptions = e;
  }
  set authenticationAllowList(e) {
    this._authProvider.authenticationAllowList = e;
  }
  get authenticationAllowList() {
    return this._authProvider.authenticationAllowList;
  }
  get authProvider() {
    return this._authProvider;
  }
  setApiKey(e) {
    this._authProvider.setApiKey(e);
  }
  setTimeout(e) {
    this._timeout = e;
  }
  setAuthToken(e) {
    e ? this._authProvider.setAuthToken(e) : this._authProvider.logout();
  }
  _onAuthChange(e, s) {
    K("_oAC", e);
    const r = this._waitingForAuthentication;
    e === "unauthenticated" ? this._waitingForAuthentication = !0 : (this._waitingForAuthentication = !1, r !== !1 && this._checkQueue());
  }
  resume() {
    this._waitingForAuthentication = !1, this._authProvider.resume(), this._checkQueue();
  }
  setRequestHooks(e, s) {
    this._beforeHook = e, this._afterHook = s;
  }
  invoke(e = "GET", s, r = {}, n, o = {}, i) {
    var a;
    K("invoke", e, s, o);
    let d = (o = o || {}).autoParseJson || !1, h = o.responseType;
    if (h != null && h !== "void" || (d = o.autoParseJson == null || o.autoParseJson, h = o.responseType = "text"), h === "defaultbuffer" && (h = qt() ? o.responseType = "buffer" : o.responseType = "arraybuffer"), h === "buffer") {
      if (typeof Buffer != "function") throw new c(c.INVALID_PARAMS, "No Buffer class");
    } else if (h === "blob") {
      if (typeof Blob != "function") throw new c(c.INVALID_PARAMS, "No Blob class");
    } else if (h && h !== "text" && h !== "json" && h !== "arraybuffer" && h !== "stream") throw new c(c.INVALID_PARAMS, "Unsupported response type: " + h);
    !Ss(s) && this.server && (s = `${this.server}/${s.startsWith("/") ? s.substr(1, s.length) : s}`), K("invoke href", s);
    const l = he({}, r, this._additionalHeaders);
    K("invoke headers", r), l["x-request-id"] = [this._requestIdPrefix, this._serviceGuid, l["x-request-id"], "" + this._reqNum++].filter((A) => A).join("."), o.additionalNodeOptions = Object.assign({}, this._additionalNodeOptions || {}, o.additionalNodeOptions || {}), o.isStatusValid = o.isStatusValid || this._isStatusValid, o.retryOptions = Object.assign({}, this._retryOptions || {}, o.retryOptions || {});
    let p = { method: e, href: s, headers: l, token: void 0, body: n, options: o, progress: (a = o.reuseRequestDesc) === null || a === void 0 ? void 0 : a.progress, autoParseJson: d }, _ = o.reuseRequestDesc;
    _ && _ instanceof C && "props" in _ && (_ = _.props), _ && ((this._requestQueue.exists(_) || _.id && this._requestsOutstanding.get(_.id) != null) && K("requestDesc still in use"), p = he(_, p)), p.id = p.id || zt(), i && ("maxRedirects" in o.additionalNodeOptions && (o.additionalNodeOptions.maxRedirects = 0), o.retryOptions && Object.keys(o.retryOptions).length !== 0 || (o.retryOptions = { disableRetry: !0 }));
    const f = this._getRequestPromise(p);
    return f.getPromise().then(this._checkQueue.bind(this)).catch(this._checkQueue.bind(this)), q(i) && (K("invoke - cb"), f.then((A) => {
      K("invoke - cb - resolve ", A.statusCode);
      try {
        i(void 0, A, A.response);
      } catch (y) {
        console.error("[dcx:http] error in success callback", y, y.stack);
      }
    }).catch((A) => {
      K("invoke - cb - reject: ", A);
      try {
        i(A, A.response);
      } catch (y) {
        console.error("[dcx:http] error in failure callback", y, y.stack);
      }
    })), this._checkQueue(), f;
  }
  _makeRequest(e) {
    K("_makeRequest(): ", e.id);
    const s = e.options || {}, r = yd(w(Object.assign(Object.assign({ url: e.href, autoParseJson: e.autoParseJson, descriptor: e }, e), { timeout: s.timeout || this._timeout, authProvider: this._authProvider, forceXhr: this._forcedXhr, fetch: this._fetch, responseType: s.responseType, preCallback: this._beforeHook, postCallback: this._afterHook, isStatusValid: s.isStatusValid, additionalNodeOptions: s.additionalNodeOptions, retryOptions: s.retryOptions, isExternalRequest: s.isExternalRequest, preferFetch: this._preferFetch })));
    return this._requestsOutstanding.addRequest(e.id, r), e.startTime = (/* @__PURE__ */ new Date()).valueOf(), r;
  }
  _checkQueue() {
    queueMicrotask(this._checkQueueLoop.bind(this));
  }
  _checkQueueLoop() {
    if (K("_checkQueueLoop()", this._waitingForAuthentication, this.isActive, this._requestsOutstanding.length, "<?", this.maxOutstanding), !this._isActive) {
      K("_cQL inactive");
      const s = new c(c.SERVICE_IS_INACTIVE, "Network request in inactive state");
      this._requestsOutstanding.clear(s), this._requestQueue.clear(s);
    }
    let e = !0;
    for (; e && !this._waitingForAuthentication && this._requestsOutstanding.length < this.maxOutstanding && (e = this._requestQueue.pop(), e != null); ) {
      const s = this._makeRequest(e.descriptor);
      e.notifySent(s);
    }
    K("_cQL done");
  }
  _getRequestPromise(e) {
    return K("_getRequestPromise()"), new C((s, r, n) => {
      if (!this._isActive) return K("_gRP inactive"), r(new c(c.SERVICE_IS_INACTIVE, "Network request in inactive state"));
      n(() => {
        K("_gRP cancel 1", e.id), this._requestQueue.remove(e);
      });
      let o = e.noSoonerThen || null;
      return o && (o -= ie(), o = o < 0 ? 0 : o > nn ? nn : o), delete e.noSoonerThen, this._requestQueue.push(e, o, this._checkQueue.bind(this)).then((i) => (K("_gRP sent", e.id), i.canceled ? (K("_gRP reject 1: ", e.id), r(new c(c.ABORTED, "Request aborted", i.error))) : (n((a) => {
        K("_gRP cancel 2", e.id, a), i.cancel(new c(c.ABORTED, "Request aborted", a));
      }), i.getPromise().then((a) => (K("_gRP resolve 1", e.id, a), s(a))).catch((a) => (K("_gRP reject 2: ", e.id, a), r(a)))))).catch(r);
    }, e);
  }
  abort(e) {
    e && e.cancel ? e.cancel() : this._requestQueue.exists(e) ? this._requestQueue.remove(e) : this._requestsOutstanding.removeById(e.id);
  }
  abortAllWithToken(e) {
    K("abortAllWithToken()"), this._requestsOutstanding.removeAllWithToken(e), this._requestQueue.removeAllWithToken(e);
  }
}
const Pd = (t, e) => new Od(t, {}), ko = class Lo extends CustomEvent {
  constructor(e) {
    super(Lo.EVENT_NAME, { bubbles: !0, composed: !0, detail: e });
  }
};
ko.EVENT_NAME = Id.UPLOAD_STATUS;
let Sd = ko;
class Cd {
  /**
   * Create a new UploadService instance
   * @param config - Configuration for the upload service
   */
  constructor(e) {
    this._uploadStatus = nt.IDLE, this._uploadBytesCompleted = !1, this._uploadProgressPercentage = 0, this.config = e, this.httpService = Pd(), this.authConfig = e.authConfig, this.session = this.prepareSession();
  }
  /**
   * Initialize logging service
   */
  async initializeLogging() {
    const { LogService: e } = await import("./Logging-CNt0Dd78.min.js");
    this.logService = new e(), await this.logService.initialize(this.config.environment);
  }
  /**
   * Initialize repository for user token type
   */
  async initializeUserRepository() {
    try {
      const e = await this.setupUserRepository();
      e && (this.config.repository = e);
    } catch (e) {
      throw this.handleError(
        Fe.REPOSITORY_REQUIRED.code,
        e
      );
    }
  }
  /**
   * Sets up the user repository for the upload service
   * This function does a couple of things:
   * 1. Gets the index document for the user
   * 2. Gets the children of the index document
   * 3. If there is only one child, that is the repository
   * 4. If there are multiple children, it finds the temp folder. If there is no temp folder, it uses the first child as the repository
   * 5. Returns the repository ID and path
   * @returns Promise resolving to the repository
   */
  async setupUserRepository() {
    var i, a;
    const e = await this.session.getIndexDocument(), { assignedDirectories: s } = e.result, r = (i = s == null ? void 0 : s[0]) == null ? void 0 : i.repositoryId, n = (a = s == null ? void 0 : s[0]) == null ? void 0 : a.assetId;
    this.config.directory = new Er({ repositoryId: r, assetId: n }, this.httpService);
    const o = await this.config.directory.getPagedChildren();
    if (o != null && o.result) {
      const d = o.result.children;
      if (d.length === 1) {
        const h = d[0];
        return {
          repositoryId: h["repo:repositoryId"],
          path: h["repo:path"]
        };
      } else {
        let h = d.find((l) => l["repo:name"] === "temp");
        return h || (h = d[0]), {
          repositoryId: h["repo:repositoryId"],
          path: h["repo:path"]
        };
      }
    }
    return null;
  }
  /**
   * Get the current upload status
   * @returns The current upload status
   */
  get uploadStatus() {
    return this._uploadStatus;
  }
  /**
   * Set the upload status
   * @param status - The status to set
   */
  set uploadStatus(e) {
    this._uploadStatus = e, this.dispatchStatusEvent(e);
  }
  /**
   * Initialize the upload service
   */
  async setIndexRepository() {
    this.authConfig.tokenType === "user" && await this.initializeUserRepository();
  }
  /**
   * Upload an asset to storage
   * @param options - Upload options including file, path, and metadata
   * @returns Promise resolving to upload result
   */
  async uploadAsset(e) {
    this.uploadStatus = nt.IDLE;
    try {
      const {
        file: s,
        fileName: r,
        path: n = this.config.basePath,
        onProgress: o = this.getUploadProgress()
      } = e, i = this.convertToSliceableData(s), a = this.getFileSize(s), d = this.buildPath(n, this.generateFileName(r)), h = { ...e, onProgress: o };
      let l;
      switch (this.authConfig.tokenType) {
        case "guest": {
          l = (await this.createAssetForGuest(
            h,
            i,
            a,
            d
          )).result;
          break;
        }
        case "user":
        default: {
          l = (await this.createAssetForUser(
            h,
            i,
            a,
            d
          )).result;
          break;
        }
      }
      return this._uploadBytesCompleted && (this.uploadStatus = nt.COMPLETED), {
        asset: l.result
      };
    } catch (s) {
      throw this.handleError(
        Fe.UPLOAD_FAILED.code,
        s
      );
    }
  }
  /**
   * Create asset for guest users
   * @param options - Upload options
   * @param fileData - Processed file data
   * @param fileSize - Size of the file
   * @param fullPath - Full path for the asset
   * @returns Promise resolving to asset creation result and optionlally pre-signed URL
   */
  async createAssetForGuest(e, s, r, n) {
    var l, p, _, f;
    const {
      contentType: o,
      resourceDesignator: i,
      additionalHeaders: a = {},
      repoMetaPatch: d,
      onProgress: h
    } = e;
    (l = this.logService) == null || l.log("LOG_UPLOAD_START", "guest", {
      fullPath: n,
      contentType: o,
      fileSize: r,
      hasResourceDesignator: !!i,
      hasRepoMetaPatch: !!d
    });
    try {
      const A = await this.session.createAssetForGuest(
        n,
        o,
        i,
        a,
        s,
        r,
        d,
        h
      );
      return (p = this.logService) == null || p.log("LOG_UPLOAD_RESPONSE", "createAssetForGuest", A, n, r), (_ = this.logService) == null || _.log("LOG_UPLOAD_STATUS", A.response.statusCode, A.response, "guest"), { result: A };
    } catch (A) {
      throw (f = this.logService) == null || f.log("LOG_UPLOAD_ERROR", "guest", {
        fullPath: n,
        contentType: o,
        fileSize: r
      }, A), A;
    }
  }
  /**
   * Create asset for authenticated users
   * @param options - Upload options
   * @param fileData - Processed file data
   * @param fileSize - Size of the file
   * @param fullPath - Full path for the asset
   * @returns Promise resolving to asset creation result
   */
  async createAssetForUser(e, s, r, n) {
    var _, f, A, y, b, v;
    const {
      contentType: o,
      resourceDesignator: i,
      additionalHeaders: a = {},
      repoMetaPatch: d,
      createIntermediates: h,
      onProgress: l
    } = e;
    let p;
    this.validateRequiredConfig([
      { field: "directory", errorCode: Fe.DIRECTORY_REQUIRED },
      { field: "repository", errorCode: Fe.REPOSITORY_REQUIRED }
    ]), (f = this.logService) == null || f.log("LOG_UPLOAD_START", "user", {
      fullPath: n,
      contentType: o,
      fileSize: r,
      createIntermediates: h || !0,
      hasResourceDesignator: !!i,
      hasRepoMetaPatch: !!d,
      repository: ((_ = this.config.repository) == null ? void 0 : _.name) || "unknown"
    });
    try {
      p = await this.config.directory.createAsset(
        n,
        h || !0,
        o,
        i,
        a,
        s,
        r,
        d,
        l
      ), (A = this.logService) == null || A.log("LOG_UPLOAD_RESPONSE", "createAssetForUser", p, n, r), (y = this.logService) == null || y.log("LOG_UPLOAD_STATUS", p.response.statusCode, p.response, "user");
    } catch (P) {
      throw (v = this.logService) == null || v.log("LOG_UPLOAD_ERROR", "user", {
        fullPath: n,
        contentType: o,
        fileSize: r,
        repository: ((b = this.config.repository) == null ? void 0 : b.name) || "unknown"
      }, P), this.handleError(
        Fe.UPLOAD_FAILED.code,
        P
      );
    }
    return { result: p };
  }
  /**
   * Generate a pre-signed URL for downloading an asset
   * @param options - Options for URL generation
   * @returns Promise resolving to pre-signed URL result
   */
  async generatePreSignedUrl(e) {
    try {
      const {
        asset: s
      } = e, { result: r } = await bo(this.httpService, s);
      return r;
    } catch (s) {
      throw this.handleError(
        Fe.URL_GENERATION_FAILED.code,
        s
      );
    }
  }
  /**
   * Generate a shareable pre-signed URL by base64 encoding the URL
   * This is useful for passing the URL via URL params
   * @param url - The pre-signed URL to share
   * @returns The shareable pre-signed URL
   */
  generateShareablePreSignedUrl(e) {
    return e ? btoa(e) : "";
  }
  /**
   * Generate a unique file name for the uploaded file
   * @param fileName - The original file name
   * @returns The unique file name
   */
  generateFileName(e) {
    const [s, r] = e.split("."), n = Date.now();
    return `${s}-${n}.${r}`;
  }
  /**
   * Dispatch a status event
   * @param status - The status to dispatch
   */
  dispatchStatusEvent(e) {
    window.dispatchEvent(new Sd({ status: e, progress: this._uploadProgressPercentage }));
  }
  /**
   * Get upload progress for an ongoing upload
   * @returns Promise resolving to upload progress information
   */
  getUploadProgress() {
    return (e, s) => {
      this._uploadProgressPercentage = Math.round(e / s * 100), e === s && (this._uploadBytesCompleted = !0), this.uploadStatus = nt.UPLOADING;
    };
  }
  /**
   * Prepare the RAPI session for the upload service.
   */
  prepareSession() {
    this.httpService.setAuthToken(this.authConfig.token), this.httpService.setApiKey(this.authConfig.apiKey);
    const e = pd(this.httpService, this.config.endpoint);
    return e.setLinksCache(new Do()), e;
  }
  /**
   * Convert a file to a sliceable data object
   * @param file - The file to convert
   * @returns The sliceable data object
   */
  convertToSliceableData(e) {
    return e instanceof ArrayBuffer ? new Uint8Array(e) : e;
  }
  /**
   * Get the size of a file
   * @param file - The file to get the size of
   * @returns The size of the file
   */
  getFileSize(e) {
    return e instanceof ArrayBuffer ? e.byteLength : "size" in e ? e.size : 0;
  }
  /**
   * Build a path for an asset for uploading.
   * @param path - The path to the asset
   * @param fileName - The name of the asset
   * @returns The full path to the asset
   */
  buildPath(e, s) {
    const r = [e, s].filter(Boolean).join("/").replace(/\/+/g, "/");
    return r.startsWith("/") ? r.substring(1) : r;
  }
  /**
   * Validate required configuration fields
   * @param validations - Array of field validations to perform
   * @throws Error if any required field is missing
   */
  validateRequiredConfig(e) {
    for (const { field: s, errorCode: r } of e)
      if (!this.config[s])
        throw this.handleError(
          r.code,
          new Error(r.message)
        );
  }
  /**
   * Handle an error
   * @param code - The error code
   * @param originalError - The original error
   * @param message - The error message
   * @returns The error
   */
  handleError(e, s, r) {
    const n = Fe[e];
    n.code === Fe.UPLOAD_FAILED.code && (this.uploadStatus = nt.FAILED);
    const o = r || n.message, i = new class extends Error {
      constructor(a, d, h) {
        super(a), this.code = d, this.originalError = h, this.name = "UploadServiceError";
      }
    }(o, n.code, s);
    return (this.config.environment === "local" || this.config.environment === "stage") && (window.lana.log(`UploadService Error [${n.code}]: ${o}`), window.lana.log(s)), i;
  }
  /**
   * Update the service configuration
   * @param newConfig - New configuration to apply
   */
  updateConfig(e) {
    this.config = { ...this.config, ...e }, (e.authConfig || e.endpoint) && (this.session = this.prepareSession());
  }
  /**
   * Get the current configuration
   * @returns Current service configuration
   */
  getConfig() {
    return { ...this.config };
  }
}
const Ld = async (t) => {
  var n, o, i;
  const s = {
    tokenType: ((n = window == null ? void 0 : window.adobeIMS) == null ? void 0 : n.isSignedInUser()) || !1 ? "user" : "guest",
    token: (i = (o = window == null ? void 0 : window.adobeIMS) == null ? void 0 : o.getAccessToken()) == null ? void 0 : i.token,
    apiKey: fd
  }, r = new Cd({
    authConfig: s,
    endpoint: _d[t.environment],
    basePath: Ed,
    environment: t.environment
  });
  return await r.setIndexRepository(), await r.initializeLogging(), r;
};
export {
  Nd as E,
  Id as U,
  Ld as i
};
//# sourceMappingURL=index-CxD35VFe.min.js.map
