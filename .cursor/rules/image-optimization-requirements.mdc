
# Image Optimization Performance Rules - Three-Phase Strategy

**APPLY: EVERY QUERY - CRITICAL PERFORMANCE RULE**

## AEM Bandwidth Budget Management (CRITICAL)
Based on [AEM's performance guidelines](https://www.aem.live/developer/keeping-it-100):
- **100kb total payload before LCP** including all images, CSS, JS
- **Single origin only** before LCP (no CDN/external image connections)
- **LCP target**: 1560ms on mobile for Lighthouse 100 score

## Phase E (Eager) - LCP Image Optimization (REQUIRED)
For first section hero/marquee images that are LCP candidates:

```javascript
// ✅ REQUIRED for LCP candidate images (Phase E)
const optimizeLCPImage = (img, block) => {
  const isFirstSection = block.closest('.section') === document.querySelector('.section');
  const isFirstImage = img === block.querySelector('img');
  
  if (isFirstSection && isFirstImage) {
    // Phase E: Critical LCP optimization
    img.removeAttribute('loading');
    img.setAttribute('loading', 'eager');  
    img.setAttribute('fetchpriority', 'high');
    
    // Calculate optimal size for bandwidth budget
    const optimalWidth = getOptimalImageSize();
    const aspectRatio = getImageAspectRatio(img);
    
    img.setAttribute('width', optimalWidth);
    img.setAttribute('height', Math.round(optimalWidth * aspectRatio));
    
    // Preload only if within bandwidth budget
    const estimatedSize = estimateImagePayload(img.src, optimalWidth);
    if (payloadTracker.canLoadResource(estimatedSize)) {
      preloadLCPImage(img.src, optimalWidth);
    } else {
      console.warn('LCP image exceeds bandwidth budget, consider optimization');
    }
  }
};

// ✅ REQUIRED - Bandwidth-aware image preloading
const preloadLCPImage = (src, width) => {
  const link = document.createElement('link');
  link.rel = 'preload';
  link.as = 'image';
  link.href = `${src}?width=${width}&format=webp&optimize=medium`;
  link.fetchPriority = 'high';
  document.head.appendChild(link);
};
```

## Bandwidth Budget Calculation (REQUIRED)

```javascript
// ✅ REQUIRED - Track image payload in bandwidth budget
const payloadTracker = {
  totalBytes: 0,
  budget: 100000, // 100kb limit for Phase E
  imagePayload: 0,
  
  estimateImageSize(width, format = 'webp') {
    // Conservative estimates for bandwidth planning
    const compressionRatios = {
      webp: 0.8,   // 80% reduction from uncompressed
      jpeg: 0.9,   // 90% reduction  
      png: 0.95    // 95% reduction
    };
    
    const uncompressedSize = width * (width * 0.6) * 4; // Assume 0.6 aspect ratio, 4 bytes/pixel
    return Math.round(uncompressedSize * compressionRatios[format]);
  },
  
  canPreloadImage(src, width) {
    const estimatedSize = this.estimateImageSize(width);
    return (this.totalBytes + estimatedSize) <= this.budget;
  }
};

// ✅ USAGE - Check before preloading
if (payloadTracker.canPreloadImage(imageSrc, 400)) {
  preloadLCPImage(imageSrc, 400);
} else {
  console.log('Deferring image preload to Phase L due to bandwidth constraints');
}
```

## Responsive Image Pattern - Phase Aware (REQUIRED)

```javascript
// ✅ REQUIRED - Phase-aware responsive images
const createOptimizedPictureByPhase = (src, alt, isLCPCandidate = false) => {
  const picture = document.createElement('picture');
  
  if (isLCPCandidate) {
    // Phase E: Optimized for LCP and bandwidth budget
    const webpSource = document.createElement('source');
    webpSource.type = 'image/webp';
    webpSource.srcset = `
      ${src}?width=400&format=webp&optimize=medium 400w,
      ${src}?width=600&format=webp&optimize=medium 600w,
      ${src}?width=900&format=webp&optimize=medium 900w
    `;
    webpSource.sizes = '(max-width: 600px) 400px, (max-width: 900px) 600px, 900px';
    
    const fallbackImg = document.createElement('img');
    fallbackImg.src = `${src}?width=400&format=jpeg&optimize=medium`;
    fallbackImg.alt = alt;
    fallbackImg.loading = 'eager';
    fallbackImg.fetchPriority = 'high';
    fallbackImg.width = getOptimalImageSize();
    fallbackImg.height = Math.round(fallbackImg.width * getImageAspectRatio(src));
    
    picture.appendChild(webpSource);
    picture.appendChild(fallbackImg);
  } else {
    // Phase L: Standard lazy loading
    const img = document.createElement('img');
    img.src = `${src}?width=400&format=webp&optimize=medium`;
    img.alt = alt;
    img.loading = 'lazy';
    img.width = getOptimalImageSize();
    img.height = Math.round(img.width * getImageAspectRatio(src));
    
    picture.appendChild(img);
  }
  
  return picture;
};
```

## External Image Origins (FORBIDDEN in Phase E)

```javascript
// ❌ FORBIDDEN - External image connections before LCP
// These add TLS/DNS overhead that delays LCP

// ✅ REQUIRED - Only connect to external origins AFTER LCP
const handleExternalImages = (imageUrl) => {
  const observer = new PerformanceObserver((list) => {
    const lcpEntry = list.getEntries()[list.getEntries().length - 1];
    if (lcpEntry) {
      // Now safe to preconnect for Phase L external images
      addImagePreconnects(imageUrl);
    }
  });
  
  observer.observe({ entryTypes: ['largest-contentful-paint'] });
};

// ✅ REQUIRED - Preconnect only after LCP
function addImagePreconnects(imageUrl) {
  if (!imageUrl) return;
  
  try {
    const url = new URL(imageUrl, window.location.href);
    if (url.origin !== window.location.origin) {
      const existingPreconnect = document.querySelector(`link[rel="preconnect"][href="${url.origin}"]`);
      if (!existingPreconnect) {
        const link = document.createElement('link');
        link.rel = 'preconnect';
        link.href = url.origin;
        link.crossOrigin = 'anonymous';
        document.head.appendChild(link);
      }
    }
  } catch (e) {
    console.warn('Invalid image URL:', imageUrl);
  }
}
```

## Image Format Optimization (REQUIRED)

```javascript
// ✅ REQUIRED - Optimal format selection for bandwidth efficiency
const getOptimizedImageUrl = (src, width, isLCPCandidate = false) => {
  const params = new URLSearchParams();
  params.set('width', width);
  params.set('optimize', isLCPCandidate ? 'high' : 'medium');
  
  // Format selection based on content and phase
  if (isLCPCandidate) {
    // Phase E: Prioritize smallest size for bandwidth budget
    params.set('format', 'webp');
  } else {
    // Phase L: Balance quality and size
    params.set('format', 'webp');
  }
  
  return `${src}?${params.toString()}`;
};

// ✅ REQUIRED - Format priorities
const formatPriority = ['webp', 'avif', 'jpeg', 'png'];
```

## Optimal Sizing Function (BANDWIDTH AWARE)

```javascript
// ✅ REQUIRED - Bandwidth-conscious image sizing
function getOptimalImageSize(isLCPCandidate = false) {
  if (isLCPCandidate) {
    // Phase E: Conservative sizing for bandwidth budget
    if (window.innerWidth <= 600) return 400;  // Mobile
    if (window.innerWidth <= 900) return 600;  // Tablet  
    return 900; // Desktop
  } else {
    // Phase L: Can be more generous
    if (window.innerWidth <= 600) return 500;  // Mobile
    if (window.innerWidth <= 900) return 750;  // Tablet
    return 1200; // Desktop
  }
}

// ✅ REQUIRED - Estimate payload for budget planning
function estimateImagePayload(src, width, format = 'webp') {
  // Conservative estimates for different image types
  const baseSize = width * width * 0.6 * 0.1; // Assume 0.6 aspect ratio, 10% of uncompressed
  
  const formatMultipliers = {
    webp: 0.8,
    avif: 0.7,
    jpeg: 1.0,
    png: 1.5
  };
  
  return Math.round(baseSize * formatMultipliers[format]);
}
```

## Delayed Decoration Pattern (REQUIRED)
Delay non-critical visual elements until main image loads to avoid competing for bandwidth:

```javascript
// ✅ REQUIRED - Delay decorative elements until LCP image loads
const handleImageDecorations = (cell) => {
  const mainImg = cell.querySelector('img');
  
  if (mainImg) {
    let overlaysCreated = false;
    
    const createOverlaysDelayed = () => {
      if (!overlaysCreated) {
        overlaysCreated = true;
        // Phase L: Create decorative elements after main image
        setTimeout(() => createCornerOverlays(cell), 100);
      }
    };
    
    if (mainImg.complete) {
      // Image already loaded
      createOverlaysDelayed();
    } else {
      // Wait for image load with fallback timeout
      mainImg.addEventListener('load', createOverlaysDelayed, { once: true });
      setTimeout(createOverlaysDelayed, 2000); // Fallback
    }
  } else {
    // No main image, create overlays in Phase L
    setTimeout(() => createCornerOverlays(cell), 0);
  }
};
```

## Image Loading Priority by Phase (REQUIRED)

### Phase E (Eager - LCP Critical)
- **Hero/Marquee first image**: `loading="eager"` + `fetchpriority="high"` + selective preload
- **Bandwidth budget**: Include in 100kb total payload calculation
- **Single origin**: No external CDN connections before LCP
- **Format**: WebP with high optimization for smallest size

### Phase L (Lazy - Below Fold)  
- **Secondary images**: `loading="lazy"` attribute
- **External origins**: Safe to preconnect after LCP
- **Format**: WebP with medium optimization
- **Sizing**: More generous dimensions allowed

### Phase D (Delayed - Decorative)
- **Decorative images**: Load after 3+ second delay
- **Background images**: Load via CSS after main content
- **Social media images**: Load with social embeds
- **Analytics pixels**: Load with tracking scripts

## Aspect Ratio Preservation (CLS Prevention)

```javascript
// ✅ REQUIRED - Prevent layout shift with proper dimensions
const preserveAspectRatio = (img, targetWidth) => {
  // Calculate aspect ratio from source or use default
  const aspectRatio = getImageAspectRatio(img.src) || 0.6; // Default to 3:5 ratio
  const height = Math.round(targetWidth * aspectRatio);
  
  img.setAttribute('width', targetWidth);
  img.setAttribute('height', height);
  
  // Set CSS for responsive behavior
  img.style.width = '100%';
  img.style.height = 'auto';
  img.style.aspectRatio = `${targetWidth} / ${height}`;
};

// ✅ REQUIRED - Extract aspect ratio from image metadata or URL
function getImageAspectRatio(src) {
  // Try to extract from URL parameters if available
  const url = new URL(src, window.location.href);
  const width = url.searchParams.get('width');
  const height = url.searchParams.get('height');
  
  if (width && height) {
    return parseInt(height) / parseInt(width);
  }
  
  // Fallback to common aspect ratios
  return 0.6; // 3:5 aspect ratio default
}
```

## Image Performance Monitoring (REQUIRED)

```javascript
// ✅ REQUIRED - Monitor image impact on LCP
const monitorImagePerformance = () => {
  const observer = new PerformanceObserver((list) => {
    list.getEntries().forEach(entry => {
      if (entry.element && entry.element.tagName === 'IMG') {
        console.log(`LCP Image: ${entry.element.src}, Time: ${entry.startTime}ms`);
        
        // Track if image payload exceeded budget
        const imageSize = estimateImagePayload(entry.element.src, entry.element.width);
        if (imageSize > 30000) { // 30kb threshold
          console.warn('LCP image may be too large for optimal performance');
        }
      }
    });
  });
  
  observer.observe({ entryTypes: ['largest-contentful-paint'] });
};
```

## Anti-Patterns to Avoid (CRITICAL)

```javascript
// ❌ FORBIDDEN - These violate bandwidth budget principles

// NO image preloading without budget checking
// preloadImage(src); // Can exceed 100kb budget

// NO external image CDNs before LCP  
// img.src = 'https://cdn.example.com/image.jpg'; // Adds TLS/DNS overhead

// NO multiple image preloads
// preloadImage(hero1); preloadImage(hero2); // Exceeds bandwidth budget

// NO high-resolution images for LCP
// img.src = 'image.jpg?width=2000'; // Too large for bandwidth budget

// ✅ CORRECT - Budget-conscious image loading
if (payloadTracker.canLoadResource(estimatedSize)) {
  preloadLCPImage(optimizedSrc, optimalWidth);
}
```

img.setAttribute('height', height);
```
