name: QA Label Management

on:
  pull_request:
    types: [opened, edited, ready_for_review, converted_to_draft, labeled, unlabeled, synchronize, reopened]

jobs:
  manage-labels:
    name: Manage All PR Labels
    runs-on: ubuntu-latest
    steps:
      - name: Manage labels based on PR state and approvals
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo, number } = context.issue;
            
            console.log(`Workflow triggered for PR #${number}, action: ${context.payload.action}`);
            
            // Get PR details with error handling
            let pr;
            try {
              pr = await github.rest.pulls.get({
                owner,
                repo,
                pull_number: number
              });
              console.log(`Successfully retrieved PR #${number} details`);
            } catch (error) {
              console.log(`‚ùå Failed to get PR details: ${error.message}`);
              if (error.status === 404) {
                console.log(`PR #${number} not found - may have been deleted`);
              } else if (error.status === 403) {
                console.log(`Insufficient permissions to access PR #${number}`);
              }
              return; // Exit gracefully
            }
            
            // No approval checking needed - just Ready for Review
            
            const currentLabels = pr.data.labels.map(label => label.name);
            const isDraft = pr.data.draft;
            
            console.log(`Current labels on PR #${number}:`, currentLabels);
            console.log(`Is draft: ${isDraft}`);
            
            // Start fresh - only keep non-Ready labels
            const targetLabels = currentLabels.filter(label => 
              !['Ready for Review', 'Ready for review', 'Ready for QA', 'Ready for qa'].includes(label)
            );
            
            // Add the correct Ready label based on state
            if (isDraft) {
              // Draft PRs should have no Ready labels
              console.log(`Draft PR - no Ready labels needed`);
            } else {
              // Ready for Review - default for non-draft PRs
              targetLabels.push('Ready for Review');
              console.log(`Adding Ready for Review label`);
            }
            
            // Check if labels actually changed to avoid unnecessary operations
            const currentReadyLabels = currentLabels.filter(label => 
              label.includes('Ready for')
            );
            const targetReadyLabels = targetLabels.filter(label => 
              label.includes('Ready for')
            );
            
            // More efficient label comparison
            const labelsChanged = currentReadyLabels.length !== targetReadyLabels.length || 
              !currentReadyLabels.every(label => targetReadyLabels.includes(label));
            
            if (labelsChanged) {
              console.log(`Labels changed: ${currentReadyLabels.join(', ')} ‚Üí ${targetReadyLabels.join(', ')}`);
              
              // Set the exact label list with error handling
              try {
                await github.rest.issues.setLabels({
                  owner,
                  repo,
                  issue_number: number,
                  labels: targetLabels
                });
                console.log(`‚úÖ Successfully set labels to: ${targetLabels.join(', ')}`);
                
                // Send Slack notification if "Ready for Review" was added
                if (targetLabels.includes('Ready for Review')) {
                  await sendSlackNotification(pr.data);
                }
              } catch (error) {
                console.log(`‚ùå Failed to set labels: ${error.message}`);
                if (error.status === 404) {
                  console.log(`PR #${number} not found - may have been deleted`);
                } else if (error.status === 403) {
                  console.log(`Insufficient permissions to modify labels on PR #${number}`);
                } else if (error.status === 422) {
                  console.log(`Invalid label data provided: ${JSON.stringify(targetLabels)}`);
                }
                return; // Exit gracefully
              }
            } else {
              console.log(`No label changes needed - Ready labels already correct`);
            }
            
            // No approval checking functions needed - simplified to just Ready for Review
            
            // Helper function to send Slack notification
            async function sendSlackNotification(prData) {
              try {
                const title = prData.title;
                const author = prData.user.login;
                const url = prData.html_url;
                const branch = prData.head.ref;
                const baseBranch = prData.base.ref;
                
                // Extract Jira ticket if present
                let jiraTicket = null;
                const titleMatch = title.match(/(MWPW-\d+)/);
                if (titleMatch) {
                  jiraTicket = titleMatch[1];
                } else {
                  const bodyMatch = (prData.body || '').match(/(MWPW-\d+)/);
                  if (bodyMatch) {
                    jiraTicket = bodyMatch[1];
                  }
                }
                
                // Format the message
                const displayTitle = jiraTicket ? `${jiraTicket}: ${title.replace(`${jiraTicket}: `, '')}` : title;
                const jiraLink = jiraTicket ? `\nüîó <https://jira.corp.adobe.com/browse/${jiraTicket}|${jiraTicket}>` : '';
                
                const isTestMode = true; // Always test mode during testing phase
                const message = {
                  text: `üîç *New PR Ready for Review*${isTestMode ? ' (TEST MODE)' : ''}`,
                  attachments: [
                    {
                      color: "#0066cc",
                      fields: [
                        {
                          title: "üìù PR Title",
                          value: displayTitle,
                          short: false
                        },
                        {
                          title: "üë§ Author",
                          value: author,
                          short: true
                        },
                        {
                          title: "üåø Branch",
                          value: `\`${branch}\` ‚Üí \`${baseBranch}\``,
                          short: true
                        },
                        {
                          title: "üîó Links",
                          value: `<${url}|PR #${prData.number}>${jiraLink}`,
                          short: false
                        }
                      ],
                      footer: "Express Milo ‚Ä¢ Ready for Review",
                      footer_icon: "https://github.com/adobecom/express-milo/raw/main/express/code/img/favicon.ico"
                    }
                  ]
                };
                
                // Send to Slack
                const webhookUrl = process.env.SLACK_WEBHOOK_URL;
                if (!webhookUrl) {
                  console.log('‚ùå SLACK_WEBHOOK_URL not configured');
                  return;
                }
                
                const response = await fetch(webhookUrl, {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                  },
                  body: JSON.stringify(message)
                });
                
                if (response.ok) {
                  console.log('‚úÖ Ready for Review notification sent successfully');
                } else {
                  console.log(`‚ùå Failed to send notification: ${response.status} ${response.statusText}`);
                }
              } catch (error) {
                console.log(`‚ùå Error sending notification: ${error.message}`);
              }
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL_PR_TEST }}

