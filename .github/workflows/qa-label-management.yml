name: QA Label Management

on:
  pull_request:
    types: [opened, edited, ready_for_review, converted_to_draft, labeled, unlabeled, submitted, synchronize, reopened]

jobs:
  manage-labels:
    name: Manage All PR Labels
    runs-on: ubuntu-latest
    steps:
      - name: Manage labels based on PR state and approvals
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo, number } = context.issue;
            
            console.log(`Workflow triggered for PR #${number}, action: ${context.payload.action}`);
            
            // Get PR details
            const pr = await github.rest.pulls.get({
              owner,
              repo,
              pull_number: number
            });
            
            const currentLabels = pr.data.labels.map(label => label.name);
            const isDraft = pr.data.draft;
            const isTestMode = currentLabels.includes('test-qa-workflow');
            
            console.log(`Current labels on PR #${number}:`, currentLabels);
            console.log(`Is draft: ${isDraft}, Is test mode: ${isTestMode}`);
            
            // Start fresh - only keep non-Ready labels
            const targetLabels = currentLabels.filter(label => 
              !['Ready for Review', 'Ready for review', 'Ready for QA', 'Ready for qa'].includes(label)
            );
            
            // Add the correct Ready label based on state
            if (isDraft) {
              // Draft PRs should have no Ready labels
              console.log(`Draft PR - no Ready labels needed`);
            } else if (isTestMode || (await checkApprovals(owner, repo, number)) >= 2) {
              // Ready for QA - 2+ approvals and no request changes
              targetLabels.push('Ready for QA');
              console.log(`Adding Ready for QA label`);
            } else {
              // Ready for Review - default for non-draft PRs
              targetLabels.push('Ready for Review');
              console.log(`Adding Ready for Review label`);
            }
            
            // Check if labels actually changed to avoid unnecessary operations
            const currentReadyLabels = currentLabels.filter(label => 
              label.includes('Ready for')
            );
            const targetReadyLabels = targetLabels.filter(label => 
              label.includes('Ready for')
            );
            
            const labelsChanged = JSON.stringify(currentReadyLabels.sort()) !== JSON.stringify(targetReadyLabels.sort());
            
            if (labelsChanged) {
              console.log(`Labels changed: ${currentReadyLabels.join(', ')} â†’ ${targetReadyLabels.join(', ')}`);
              
              // Set the exact label list
              await github.rest.issues.setLabels({
                owner,
                repo,
                issue_number: number,
                labels: targetLabels
              });
              console.log(`Set labels to: ${targetLabels.join(', ')}`);
              
              // Force UI refresh using multiple strategies
              if (targetReadyLabels.length > 0) {
                const mainLabel = targetReadyLabels[0];
                console.log(`Forcing UI refresh using multiple strategies`);
                
                // Strategy 1: Add a comment to trigger UI refresh
                try {
                  await github.rest.issues.createComment({
                    owner,
                    repo,
                    issue_number: number,
                    body: `ðŸ”„ Label updated to: **${mainLabel}**`
                  });
                  console.log(`Added comment for UI refresh`);
                  
                  // Wait a moment for comment to be processed
                  await new Promise(resolve => setTimeout(resolve, 1000));
                  
                  // Delete the comment immediately
                  const comments = await github.rest.issues.listComments({
                    owner,
                    repo,
                    issue_number: number
                  });
                  
                  const refreshComment = comments.data.find(comment => 
                    comment.body.includes('ðŸ”„ Label updated to:')
                  );
                  
                  if (refreshComment) {
                    await github.rest.issues.deleteComment({
                      owner,
                      repo,
                      comment_id: refreshComment.id
                    });
                    console.log(`Deleted refresh comment`);
                  }
                } catch (error) {
                  console.log(`Comment-based UI refresh failed: ${error.message}`);
                }
                
                // Strategy 2: Update PR description with timestamp
                try {
                  const currentDesc = pr.data.body || '';
                  const timestamp = new Date().toISOString();
                  const newDesc = currentDesc.replace(/<!-- UI-REFRESH:.*?-->/g, '') + `\n\n<!-- UI-REFRESH:${timestamp} -->`;
                  
                  await github.rest.pulls.update({
                    owner,
                    repo,
                    pull_number: number,
                    body: newDesc
                  });
                  console.log(`Updated PR description for UI refresh`);
                } catch (error) {
                  console.log(`Description-based UI refresh failed: ${error.message}`);
                }
              }
            } else {
              console.log(`No label changes needed - Ready labels already correct`);
            }
            
            // Helper function to check approvals
            async function checkApprovals(owner, repo, number) {
              const reviews = await github.rest.pulls.listReviews({
                owner,
                repo,
                pull_number: number
              });
              
              let approvalCount = 0;
              for (const review of reviews.data) {
                if (review.state === 'APPROVED') {
                  approvalCount++;
                } else if (review.state === 'CHANGES_REQUESTED') {
                  return 0; // Request changes blocks QA
                }
              }
              return approvalCount;
            }
