name: Slack Release Notification

on:
  push:
    branches:
      - main
    paths-ignore:
      - 'README.md'
      - 'docs/**'
      - '*.md'
  pull_request:
    types: [labeled]
  workflow_dispatch:
    inputs:
      test_mode:
        description: 'Test mode (uses test webhook)'
        required: false
        default: false
        type: boolean

env:
  # Webhook URL (required)
  SLACK_WEBHOOK_URL: ${{ (github.event.inputs.test_mode == 'true' || (github.event_name == 'pull_request' && contains(github.event.label.name, 'test-release-notification'))) && secrets.SLACK_WEBHOOK_URL_TEST || secrets.SLACK_WEBHOOK_URL }}
  # Express Agent Bot token for pinning messages
  SLACK_BOT_TOKEN: ${{ (github.event.inputs.test_mode == 'true' || (github.event_name == 'pull_request' && contains(github.event.label.name, 'test-release-notification'))) && secrets.SLACK_EXPRESS_AGENT_BOT_TOKEN_TEST || secrets.SLACK_EXPRESS_AGENT_BOT_TOKEN }}
  # Express Agent channel ID for pinning messages
  SLACK_CHANNEL_ID: ${{ (github.event.inputs.test_mode == 'true' || (github.event_name == 'pull_request' && contains(github.event.label.name, 'test-release-notification'))) && secrets.SLACK_EXPRESS_AGENT_CHANNEL_ID_TEST || secrets.SLACK_EXPRESS_AGENT_CHANNEL_ID }}

jobs:
  notify-release:
    runs-on: ubuntu-latest
    if: |
      github.repository_owner == 'adobecom' && 
      (github.ref == 'refs/heads/main' || 
       github.event_name == 'workflow_dispatch' ||
       (github.event_name == 'pull_request' && contains(github.event.label.name, 'test-release-notification')))
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get short SHA
        id: short-sha
        run: echo "short-sha=${GITHUB_SHA::7}" >> $GITHUB_OUTPUT

      - name: Extract PR information
        id: extract-prs
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            
            console.log('üîç Fetching recent PRs with detailed information...');
            
            // Get recent commits
            const commits = await github.rest.repos.listCommits({
              owner,
              repo,
              sha: 'main',
              per_page: 10
            });
            
            const mergeCommits = commits.data.filter(commit => 
              commit.commit.message.includes('Merge pull request')
            );
            
            console.log(`Found ${mergeCommits.length} merge commits`);
            
            if (mergeCommits.length === 0) {
              return {
                prList: 'No recent PRs found'
              };
            }
            
            // Extract PR numbers from merge commits
            const prNumbers = mergeCommits.map(commit => {
              const match = commit.commit.message.match(/#(\d+)/);
              return match ? parseInt(match[1]) : null;
            }).filter(num => num !== null);
            
            console.log(`Extracted PR numbers: ${prNumbers.join(', ')}`);
            
            // Get detailed PR information
            const prDetails = [];
            for (const prNumber of prNumbers) {
              try {
                const pr = await github.rest.pulls.get({
                  owner,
                  repo,
                  pull_number: prNumber
                });
                
                const title = pr.data.title;
                const body = pr.data.body || '';
                
                // Look for ticket numbers in various formats
                let ticketNumber = null;
                let cleanTitle = title;
                
                // Check title first (MWPW-XXXXXX pattern)
                const titleMatch = title.match(/(MWPW-\d+)/);
                if (titleMatch) {
                  ticketNumber = titleMatch[1];
                  cleanTitle = title.replace(`${ticketNumber}: `, '');
                } else {
                  // Check PR body for ticket numbers
                  const bodyMatch = body.match(/(MWPW-\d+)/);
                  if (bodyMatch) {
                    ticketNumber = bodyMatch[1];
                  }
                  
                  // Also check for other ticket patterns in body
                  const otherTicketMatch = body.match(/([A-Z]+-\d+)/);
                  if (otherTicketMatch && !ticketNumber) {
                    ticketNumber = otherTicketMatch[1];
                  }
                }
                
                prDetails.push({
                  number: prNumber,
                  title: cleanTitle,
                  originalTitle: title,
                  body: body,
                  ticketNumber: ticketNumber,
                  url: pr.data.html_url
                });
                
                console.log(`PR #${prNumber}: "${cleanTitle}" ${ticketNumber ? `(Ticket: ${ticketNumber})` : '(No ticket found)'}`);
                
              } catch (error) {
                console.log(`Failed to get PR #${prNumber}: ${error.message}`);
              }
            }
            
            // Format the PR list
            let prList = '';
            prDetails.forEach(pr => {
              if (pr.ticketNumber) {
                // Show ticket number in title, link to Jira, show GitHub PR at end
                const displayTitle = `${pr.ticketNumber}: ${pr.title}`;
                prList += `- <https://jira.corp.adobe.com/browse/${pr.ticketNumber}|${displayTitle}> (#${pr.number})\n`;
              } else {
                // Link to GitHub PR
                prList += `- <https://github.com/${owner}/${repo}/pull/${pr.number}|${pr.title}> (#${pr.number})\n`;
              }
            });
            
            core.setOutput('prList', prList);

      - name: Send release notification with bot token
        if: env.SLACK_BOT_TOKEN != '' && steps.extract-prs.outputs.prList != ''
        id: send-notification
        run: |
          echo "üì§ Sending release notification with bot token..."
          
          # Use bot token to send message and get message details
          MESSAGE_RESPONSE=$(curl -s -X POST -H "Authorization: Bearer ${{ env.SLACK_BOT_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d '{
              "channel": "${{ env.SLACK_CHANNEL_ID }}",
              "text": "@ax-devs üöÄ *Express Milo Release Deployed* ${{ (github.event.inputs.test_mode == 'true' || (github.event_name == 'pull_request' && contains(github.event.label.name, 'test-release-notification'))) && '(TEST_MODE)' || '' }}",
              "attachments": [
                {
                  "color": "#0066cc",
                  "fields": [
                    {
                      "title": "üåø Branch", 
                      "value": "main",
                      "short": true
                    },
                    {
                      "title": "üîó Commit",
                      "value": "<https://github.com/${{ github.repository }}/commit/${{ github.sha }}|${{ steps.short-sha.outputs.short-sha }}>",
                      "short": true
                    }
                  ]
                },
                {
                  "color": "#ff6b35",
                  "fields": [
                    {
                      "title": "üåê Test URLs",
                      "value": "‚Ä¢ <https://main--express-milo--adobecom.aem.page/express|main--express-milo--adobecom.aem.page/express>\n‚Ä¢ <https://adobecom.com/express|adobecom.com/express>",
                      "short": false
                    }
                  ]
                },
                {
                  "color": "#28a745",
                  "fields": [
                    {
                      "title": "üìã Changes in this Release",
                      "value": "${{ steps.extract-prs.outputs.prList }}",
                      "short": false
                    }
                  ]
                }
              ]
            }' \
            "https://slack.com/api/chat.postMessage")
          
          echo "Message response: $MESSAGE_RESPONSE"
          
          # Extract message timestamp for pinning
          MESSAGE_TS=$(echo "$MESSAGE_RESPONSE" | jq -r '.ts')
          if [ "$MESSAGE_TS" != "null" ] && [ "$MESSAGE_TS" != "" ]; then
            echo "MESSAGE_TS=$MESSAGE_TS" >> $GITHUB_OUTPUT
            echo "‚úÖ Message sent successfully with timestamp: $MESSAGE_TS"
          else
            echo "‚ùå Failed to get message timestamp"
            exit 1
          fi

      - name: Send release notification with webhook (fallback)
        if: env.SLACK_WEBHOOK_URL != '' && env.SLACK_BOT_TOKEN == '' && steps.extract-prs.outputs.prList != ''
        id: send-notification-webhook
        run: |
          echo "üì§ Sending release notification with webhook (no pinning available)..."
          
          curl -X POST -H 'Content-type: application/json' \
            --data '{
              "text": "<!here> üöÄ *Express Milo Release Deployed* ${{ (github.event.inputs.test_mode == 'true' || (github.event_name == 'pull_request' && contains(github.event.label.name, 'test-release-notification'))) && '(TEST MODE)' || '' }}",
              "attachments": [
                {
                  "color": "#0066cc",
                  "fields": [
                    {
                      "title": "üåø Branch", 
                      "value": "main",
                      "short": true
                    },
                    {
                      "title": "üîó Commit",
                      "value": "<https://github.com/${{ github.repository }}/commit/${{ github.sha }}|${{ steps.short-sha.outputs.short-sha }}>",
                      "short": true
                    }
                  ]
                },
                {
                  "color": "#ff6b35",
                  "fields": [
                    {
                      "title": "üåê Test URLs",
                      "value": "‚Ä¢ <https://main--express-milo--adobecom.aem.page/express|main--express-milo--adobecom.aem.page/express>\n‚Ä¢ <https://adobecom.com/express|adobecom.com/express>",
                      "short": false
                    }
                  ]
                },
                {
                  "color": "#28a745",
                  "fields": [
                    {
                      "title": "üìã Changes in this Release",
                      "value": "${{ steps.extract-prs.outputs.prList }}",
                      "short": false
                    }
                  ]
                }
              ]
            }' \
            ${{ env.SLACK_WEBHOOK_URL }}
          
          echo "‚úÖ Webhook notification sent (no pinning available)"

      - name: Pin release message
        if: env.SLACK_BOT_TOKEN != '' && steps.send-notification.outcome == 'success'
        run: |
          echo "üìå Pinning release message..."
          
          # Use the message timestamp from the bot token response
          MESSAGE_TS="${{ steps.send-notification.outputs.MESSAGE_TS }}"
          CHANNEL_ID="${{ env.SLACK_CHANNEL_ID }}"
          
          if [ -z "$MESSAGE_TS" ] || [ -z "$CHANNEL_ID" ]; then
            echo "‚ö†Ô∏è Missing MESSAGE_TS or CHANNEL_ID, skipping pin"
            exit 0
          fi
          
          echo "üìå Pinning message with timestamp: $MESSAGE_TS"
          
          # Pin the message
          PIN_RESPONSE=$(curl -s -X POST -H "Authorization: Bearer ${{ env.SLACK_BOT_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d "{\"channel\":\"$CHANNEL_ID\",\"timestamp\":\"$MESSAGE_TS\"}" \
            "https://slack.com/api/pins.add")
          
          echo "Pin response: $PIN_RESPONSE"
          
          # Check if pin was successful
          PIN_SUCCESS=$(echo "$PIN_RESPONSE" | jq -r '.ok')
          if [ "$PIN_SUCCESS" = "true" ]; then
            echo "‚úÖ Message pinned successfully!"
          else
            echo "‚ùå Failed to pin message: $(echo "$PIN_RESPONSE" | jq -r '.error')"
          fi

      - name: Fallback notification
        if: failure() && env.SLACK_WEBHOOK_URL != ''
        run: |
          echo "‚ùå Release notification failed"
          echo "Commit: ${{ github.sha }}"
          echo "Repository: ${{ github.repository }}"
