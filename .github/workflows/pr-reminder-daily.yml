name: Daily PR Reminder

on:
  schedule:
    # Production: Run at 10 AM and 2 PM PST (6 PM and 10 PM UTC)
    - cron: '0 18 * * *'  # 6 PM UTC (10 AM PST)
    - cron: '0 22 * * *'  # 10 PM UTC (2 PM PST)
  workflow_dispatch: # Allow manual trigger for testing

jobs:
  remind-open-prs:
    runs-on: ubuntu-latest
    if: |
      github.repository_owner == 'adobecom' &&
      (github.event_name == 'workflow_dispatch' || 
       github.event_name == 'schedule')
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Find PRs needing review
        id: find-prs
        uses: actions/github-script@v6
        with:
          script: |
            const { owner, repo } = context.repo;
            
            
            // Get all open PRs targeting main branches (stage or main)
            const openPRs = await github.rest.pulls.list({
              owner,
              repo,
              state: 'open',
              per_page: 100,
              base: 'stage' // Only look for PRs targeting stage branch
            });
            
            
            const prsNeedingReview = [];
            
            for (const pr of openPRs.data) {
              // Include all PRs (including drafts) - we'll categorize them later
              
              // Get reviews for this PR
              const reviews = await github.rest.pulls.listReviews({
                owner,
                repo,
                pull_number: pr.number
              });
              
              let approvalCount = 0;
              let hasRequestChanges = false;
              
              for (const review of reviews.data) {
                if (review.state === 'APPROVED') {
                  approvalCount++;
                } else if (review.state === 'CHANGES_REQUESTED') {
                  hasRequestChanges = true;
                }
              }
              
              // If there are requested changes, reset approval count
              if (hasRequestChanges) {
                approvalCount = 0;
              }
              
              // Include ALL PRs for comprehensive reminder
                // Extract Jira ticket if present
                let jiraTicket = null;
                const titleMatch = pr.title.match(/(MWPW-\d+)/);
                if (titleMatch) {
                  jiraTicket = titleMatch[1];
                } else {
                  const bodyMatch = (pr.body || '').match(/(MWPW-\d+)/);
                  if (bodyMatch) {
                    jiraTicket = bodyMatch[1];
                  }
                }
                
                const jiraPrefix = jiraTicket + ': ';
                const displayTitle = jiraTicket ? `${jiraTicket}: ${pr.title.replace(jiraPrefix, '')}` : pr.title;
                const jiraLink = jiraTicket ? ` üîó <https://jira.corp.adobe.com/browse/${jiraTicket}|${jiraTicket}>` : '';
                
                prsNeedingReview.push({
                  number: pr.number,
                  title: displayTitle,
                  author: pr.user.login,
                  url: pr.html_url,
                  approvalCount,
                  jiraTicket,
                  jiraLink,
                  createdAt: pr.created_at,
                  hasRequestChanges,
                  labels: pr.labels.map(label => label.name),
                  draft: pr.draft
                });
            }
            
            
            // Clean PR data before serializing
            const escapeJson = (str) => {
              if (!str) return '';
              return str
                .replace(/\\/g, '\\\\')
                .replace(/"/g, '\\"')
                .replace(/\n/g, '\\n')
                .replace(/\r/g, '\\r')
                .replace(/\t/g, '\\t')
                .replace(/[\x00-\x1F\x7F-\x9F]/g, ''); // Remove control characters
            };
            
            // Clean all PR data
            const cleanedPRs = prsNeedingReview.map(pr => ({
              number: pr.number,
              title: escapeJson(pr.title),
              author: escapeJson(pr.author),
              url: pr.url,
              approvalCount: pr.approvalCount,
              jiraTicket: pr.jiraTicket,
              jiraLink: escapeJson(pr.jiraLink),
              createdAt: pr.createdAt,
              labels: pr.labels || [],
              draft: pr.draft || false
            }));
            
            // Set output for next step
            try {
              core.setOutput('prs', JSON.stringify(cleanedPRs));
              core.setOutput('count', cleanedPRs.length);
            } catch (error) {
              console.log(`‚ùå Error serializing PRs: ${error.message}`);
              core.setOutput('prs', '[]');
              core.setOutput('count', '0');
            }

      - name: Send reminder notification
        if: steps.find-prs.outputs.count != '0'
        uses: actions/github-script@v6
        with:
          script: |
            // Use environment variables instead of GitHub Actions expressions
            
            let prs = [];
            let count = 0;
            
            try {
              const prsString = process.env.PRS_OUTPUT || '[]';
              prs = JSON.parse(prsString);
              count = parseInt(process.env.COUNT_OUTPUT || '0');
              
            } catch (error) {
              console.log('JSON parse error:', error.message);
              count = 0;
            }
            
            // Group PRs by status for better organization
            const prsByStatus = {
              changesRequested: prs.filter(pr => pr.hasRequestChanges && !pr.draft),
              noApprovals: prs.filter(pr => pr.approvalCount === 0 && !pr.hasRequestChanges && !pr.draft && !pr.labels.includes('Ready for QA')),
              oneApproval: prs.filter(pr => pr.approvalCount === 1 && !pr.hasRequestChanges && !pr.draft),
              twoApprovalsNoQA: prs.filter(pr => pr.approvalCount >= 2 && !pr.labels.includes('Ready for QA') && !pr.hasRequestChanges && !pr.draft),
              readyForQA: prs.filter(pr => pr.labels.includes('Ready for QA') && !pr.draft),
              draft: prs.filter(pr => pr.draft)
            };
            
            // Escape special characters for JSON
            const escapeJson = (str) => {
              if (!str) return '';
              return str
                .replace(/\\/g, '\\\\')
                .replace(/"/g, '\\"')
                .replace(/\n/g, '\\n')
                .replace(/\r/g, '\\r')
                .replace(/\t/g, '\\t')
                .replace(/[\x00-\x1F\x7F-\x9F]/g, '');
            };
            
            // Check if this is the last reminder of the day (afternoon reminder)
            const now = new Date();
            const hour = now.getUTCHours();
            const isLastReminder = hour >= 22; // 10 PM UTC or later (2 PM PST)
            
            let messageText;
            if (isLastReminder) {
              // Star Wars theme for afternoon/evening reminder
              messageText = '@ax-devs ‚öîÔ∏è *JEDI COUNCIL MEETING*\n\n';
            } else {
              // Regular theme for morning reminder
              messageText = '@ax-devs üö® *PRs REMINDER*\n\n';
            }
            
            // 1. Changes requested (highest priority)
            if (prsByStatus.changesRequested.length > 0) {
              if (isLastReminder) {
                messageText += `üî¥ *SITH CORRUPTION DETECTED* (${prsByStatus.changesRequested.length} PRs - Changes Requested):\n`;
              } else {
                messageText += `üî¥ *CHANGES REQUESTED (${prsByStatus.changesRequested.length} PRs):*\n`;
              }
              for (const pr of prsByStatus.changesRequested) {
                messageText += '‚Ä¢ <' + pr.url + '|' + escapeJson(pr.title) + '> (#' + pr.number + ') by @' + escapeJson(pr.author) + '\n';
              }
              messageText += `\n`;
            }
            
            // 2. No approvals (second priority)
            if (prsByStatus.noApprovals.length > 0) {
              if (isLastReminder) {
                messageText += `üü° *DARK SIDE THREATS* (${prsByStatus.noApprovals.length} PRs - 0 approvals):\n`;
              } else {
                messageText += `üü° *NEEDS REVIEW (${prsByStatus.noApprovals.length} PRs - 0 approvals):*\n`;
              }
              for (const pr of prsByStatus.noApprovals) {
                messageText += '‚Ä¢ <' + pr.url + '|' + escapeJson(pr.title) + '> (#' + pr.number + ') by @' + escapeJson(pr.author) + '\n';
              }
              messageText += `\n`;
            }

            // 3. 1 approval
            if (prsByStatus.oneApproval.length > 0) {
              if (isLastReminder) {
                messageText += `üü† *PENDING JEDI TRAINING* (${prsByStatus.oneApproval.length} PRs - 1 approval):\n`;
              } else {
                messageText += `üü† *NEEDS MORE REVIEW (${prsByStatus.oneApproval.length} PRs - 1 approval):*\n`;
              }
              for (const pr of prsByStatus.oneApproval) {
                messageText += '‚Ä¢ <' + pr.url + '|' + escapeJson(pr.title) + '> (#' + pr.number + ') by @' + escapeJson(pr.author) + '\n';
              }
              messageText += `\n`;
            }

            // 4. 2+ approvals but not ready for QA
            if (prsByStatus.twoApprovalsNoQA.length > 0) {
              if (isLastReminder) {
                messageText += `üü¢ *JEDI MASTERS AWAITING* (${prsByStatus.twoApprovalsNoQA.length} PRs - 2+ approvals, needs QA):\n`;
              } else {
                messageText += `üü† *MISSING QA LABEL (${prsByStatus.twoApprovalsNoQA.length} PRs - 2+ APPROVALS):*\n`;
              }
              for (const pr of prsByStatus.twoApprovalsNoQA) {
                messageText += '‚Ä¢ <' + pr.url + '|' + escapeJson(pr.title) + '> (#' + pr.number + ') by @' + escapeJson(pr.author) + '\n';
              }
              messageText += `\n`;
            }

            // 5. Ready for QA
            if (prsByStatus.readyForQA.length > 0) {
              if (isLastReminder) {
                messageText += `üéØ *READY FOR BATTLE* (${prsByStatus.readyForQA.length} PRs - Ready for QA):\n`;
              } else {
                messageText += `üü¢ *READY FOR QA (${prsByStatus.readyForQA.length} PRs):*\n`;
              }
              for (const pr of prsByStatus.readyForQA) {
                messageText += '‚Ä¢ <' + pr.url + '|' + escapeJson(pr.title) + '> (#' + pr.number + ') by @' + escapeJson(pr.author) + '\n';
              }
              messageText += `\n`;
            }

            // 6. Draft PRs (informational)
            if (prsByStatus.draft.length > 0) {
              if (isLastReminder) {
                messageText += `üìù *DRAFT PADAWANS* (${prsByStatus.draft.length} PRs - Draft status):\n`;
              } else {
                messageText += `üìù *DRAFT PRs (${prsByStatus.draft.length} PRs):*\n`;
              }
              for (const pr of prsByStatus.draft) {
                messageText += '‚Ä¢ <' + pr.url + '|' + escapeJson(pr.title) + '> (#' + pr.number + ') by @' + escapeJson(pr.author) + '\n';
              }
              messageText += `\n`;
            }

            if (isLastReminder) {
              messageText += `\nüí° *The Force is strong with those who review promptly!*`;
            } else {
              messageText += `\nüí° *Please review PRs promptly to keep the development flow smooth!*`;
            }
            
            // Send to Slack
            const slackMessage = {
              text: messageText,
              username: 'Express Agent',
              icon_emoji: ':adobe:'
            };
            
            const response = await fetch(process.env.SLACK_WEBHOOK_URL_PR, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify(slackMessage)
            });
            
            if (!response.ok) {
              throw new Error(`Slack API error: ${response.status} ${response.statusText}`);
            }
            
            console.log('‚úÖ Reminder sent successfully');
        env:
          SLACK_WEBHOOK_URL_PR: ${{ secrets.SLACK_WEBHOOK_URL_PR }}
          PRS_OUTPUT: ${{ steps.find-prs.outputs.prs }}
          COUNT_OUTPUT: ${{ steps.find-prs.outputs.count }}
