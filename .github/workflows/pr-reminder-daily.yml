name: Daily PR Reminder

on:
  schedule:
    # Production: Run at 9 AM and 2 PM UTC (adjust timezone as needed)
    - cron: '0 9 * * *'  # 9 AM UTC
    - cron: '0 14 * * *' # 2 PM UTC
    # Testing: every 1 minute (for feature branch testing only)
    - cron: '* * * * *'  # Every 1 minute (test mode only)
  push:
    branches:
      - feature/pr-label-management
  workflow_dispatch: # Allow manual trigger for testing

jobs:
  remind-open-prs:
    runs-on: ubuntu-latest
    if: |
      github.repository_owner == 'adobecom' &&
      (github.event_name == 'workflow_dispatch' || 
       github.event_name == 'push' || 
       github.event_name == 'schedule')
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Find PRs needing review
        id: find-prs
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            
            console.log('üîç Finding open PRs with less than 2 approvals...');
            
            // Get all open PRs
            const openPRs = await github.rest.pulls.list({
              owner,
              repo,
              state: 'open',
              per_page: 100
            });
            
            console.log(`Found ${openPRs.data.length} open PRs`);
            
            const prsNeedingReview = [];
            
            for (const pr of openPRs.data) {
              // Skip draft PRs
              if (pr.draft) {
                console.log(`Skipping draft PR #${pr.number}`);
                continue;
              }
              
              // Get reviews for this PR
              const reviews = await github.rest.pulls.listReviews({
                owner,
                repo,
                pull_number: pr.number
              });
              
              let approvalCount = 0;
              let hasRequestChanges = false;
              
              for (const review of reviews.data) {
                if (review.state === 'APPROVED') {
                  approvalCount++;
                } else if (review.state === 'CHANGES_REQUESTED') {
                  hasRequestChanges = true;
                }
              }
              
              // If there are requested changes, reset approval count
              if (hasRequestChanges) {
                approvalCount = 0;
              }
              
              // Only include PRs with less than 2 approvals
              if (approvalCount < 2) {
                // Extract Jira ticket if present
                let jiraTicket = null;
                const titleMatch = pr.title.match(/(MWPW-\d+)/);
                if (titleMatch) {
                  jiraTicket = titleMatch[1];
                } else {
                  const bodyMatch = (pr.body || '').match(/(MWPW-\d+)/);
                  if (bodyMatch) {
                    jiraTicket = bodyMatch[1];
                  }
                }
                
                const displayTitle = jiraTicket ? `${jiraTicket}: ${pr.title.replace(`${jiraTicket}: `, '')}` : pr.title;
                const jiraLink = jiraTicket ? `\nüîó <https://jira.corp.adobe.com/browse/${jiraTicket}|${jiraTicket}>` : '';
                
                prsNeedingReview.push({
                  number: pr.number,
                  title: displayTitle,
                  author: pr.user.login,
                  url: pr.html_url,
                  approvalCount,
                  jiraTicket,
                  jiraLink,
                  createdAt: pr.created_at
                });
              }
            }
            
            console.log(`Found ${prsNeedingReview.length} PRs needing review`);
            
            // Clean PR data before serializing
            const escapeJson = (str) => {
              if (!str) return '';
              return str
                .replace(/\\/g, '\\\\')
                .replace(/"/g, '\\"')
                .replace(/\n/g, '\\n')
                .replace(/\r/g, '\\r')
                .replace(/\t/g, '\\t')
                .replace(/[\x00-\x1F\x7F-\x9F]/g, ''); // Remove control characters
            };
            
            // Clean all PR data
            const cleanedPRs = prsNeedingReview.map(pr => ({
              number: pr.number,
              title: escapeJson(pr.title),
              author: escapeJson(pr.author),
              url: pr.url,
              approvalCount: pr.approvalCount,
              jiraTicket: pr.jiraTicket,
              jiraLink: escapeJson(pr.jiraLink),
              createdAt: pr.createdAt,
              labels: pr.labels || [],
              draft: pr.draft || false
            }));
            
            // Set output for next step
            try {
              core.setOutput('prs', JSON.stringify(cleanedPRs));
              core.setOutput('count', cleanedPRs.length);
            } catch (error) {
              console.log(`‚ùå Error serializing PRs: ${error.message}`);
              core.setOutput('prs', '[]');
              core.setOutput('count', '0');
            }

      - name: Send reminder notification
        if: steps.find-prs.outputs.count != '0'
        uses: actions/github-script@v7
        with:
          script: |
            const prs = JSON.parse('${{ steps.find-prs.outputs.prs }}');
            const count = parseInt('${{ steps.find-prs.outputs.count }}');
            
            console.log(`üì¢ Sending reminder for ${count} PRs needing review`);
            
            // Group PRs by status for better organization
            const prsByStatus = {
              readyForReview: prs.filter(pr => pr.approvalCount < 2),
              readyForQA: prs.filter(pr => pr.approvalCount >= 2 && !pr.labels.includes('Ready for QA')),
              readyForQAWithLabel: prs.filter(pr => pr.labels.includes('Ready for QA')),
              draft: prs.filter(pr => pr.draft)
            };
            
            // Test mode: if this is the every-1-minute cron (testing only) OR if we're on feature branch
            const isTestMode = (context.event_name === 'schedule' && context.ref === 'refs/heads/main') || 
                              context.ref === 'refs/heads/feature/pr-label-management';
            
            // Escape special characters for JSON
            const escapeJson = (str) => {
              if (!str) return '';
              return str
                .replace(/\\/g, '\\\\')
                .replace(/"/g, '\\"')
                .replace(/\n/g, '\\n')
                .replace(/\r/g, '\\r')
                .replace(/\t/g, '\\t')
                .replace(/[\x00-\x1F\x7F-\x9F]/g, ''); // Remove control characters
            };
            
            let messageText = `üö® *URGENT: OPEN PRs REMINDER*${isTestMode ? ' [TEST_MODE]' : ''}\n\n`;
            messageText += `üìä *SYSTEM STATUS OVERVIEW:*\n\n`;
            
            // Ready for Review but less than 2 approvals
            if (prsByStatus.readyForReview.length > 0) {
              messageText += `üî¥ *READY FOR REVIEW (${prsByStatus.readyForReview.length} PRs) - NEEDS APPROVAL:*\n`;
              for (const pr of prsByStatus.readyForReview) {
                const approvalText = pr.approvalCount === 0 ? 'NO APPROVALS' : '1 APPROVAL';
                messageText += `‚Ä¢ <${pr.url}|${escapeJson(pr.title)}> (#${pr.number}) by @${escapeJson(pr.author)} - ${approvalText}${pr.jiraLink}\n`;
              }
              messageText += `\n`;
            }
            
            // Ready for Review with 2+ approvals, but no Ready for QA label
            if (prsByStatus.readyForQA.length > 0) {
              messageText += `üü° *READY FOR QA (${prsByStatus.readyForQA.length} PRs) - MISSING LABEL:*\n`;
              for (const pr of prsByStatus.readyForQA) {
                messageText += `‚Ä¢ <${pr.url}|${escapeJson(pr.title)}> (#${pr.number}) by @${escapeJson(pr.author)} - ${pr.approvalCount} approvals${pr.jiraLink}\n`;
              }
              messageText += `\n`;
            }
            
            // Ready for QA Label
            if (prsByStatus.readyForQAWithLabel.length > 0) {
              messageText += `üü¢ *READY FOR QA LABEL (${prsByStatus.readyForQAWithLabel.length} PRs) - READY TO DEPLOY:*\n`;
              for (const pr of prsByStatus.readyForQAWithLabel) {
                messageText += `‚Ä¢ <${pr.url}|${escapeJson(pr.title)}> (#${pr.number}) by @${escapeJson(pr.author)} - ${pr.approvalCount} approvals${pr.jiraLink}\n`;
              }
              messageText += `\n`;
            }
            
            // Draft PRs
            if (prsByStatus.draft.length > 0) {
              messageText += `‚ö™ *DRAFT PRs (${prsByStatus.draft.length} PRs) - IN PROGRESS:*\n`;
              for (const pr of prsByStatus.draft) {
                messageText += `‚Ä¢ <${pr.url}|${escapeJson(pr.title)}> (#${pr.number}) by @${escapeJson(pr.author)}${pr.jiraLink}\n`;
              }
              messageText += `\n`;
            }
            
            messageText += `‚ö° *IMMEDIATE ACTION REQUIRED: Review and process these PRs to maintain development velocity!*`;
            
            const message = {
              text: messageText,
              attachments: [
                {
                  color: "#ff6b35",
                  footer: "Express Milo ‚Ä¢ Daily Reminder",
                  footer_icon: "https://github.com/adobecom/express-milo/raw/main/express/code/img/favicon.ico",
                  ts: Math.floor(Date.now() / 1000)
                }
              ]
            };
            
            // Send to Slack
            const webhookUrl = process.env.SLACK_WEBHOOK_URL;
            if (!webhookUrl) {
              console.log('‚ùå SLACK_WEBHOOK_URL not configured');
              return;
            }
            
            try {
              let jsonPayload;
              try {
                jsonPayload = JSON.stringify(message);
              } catch (jsonError) {
                console.log(`‚ùå Error creating JSON payload: ${jsonError.message}`);
                console.log('Message object:', JSON.stringify(message, null, 2));
                return;
              }
              
              const response = await fetch(webhookUrl, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: jsonPayload
              });
              
              if (response.ok) {
                console.log('‚úÖ Daily reminder sent successfully');
              } else {
                console.log(`‚ùå Failed to send reminder: ${response.status} ${response.statusText}`);
              }
            } catch (error) {
              console.log(`‚ùå Error sending reminder: ${error.message}`);
            }
        env:
          SLACK_WEBHOOK_URL: ${{ github.event_name == 'schedule' && secrets.SLACK_WEBHOOK_URL_PR_TEST || secrets.SLACK_WEBHOOK_URL_PR }}

      - name: No PRs reminder
        if: steps.find-prs.outputs.count == '0'
        run: |
          echo "‚úÖ No PRs need review - skipping reminder"
