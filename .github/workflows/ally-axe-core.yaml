name: Accessibility Checks

on:
  pull_request:
    types: [opened, synchronize, reopened, labeled]
    branches:
      - stage
      - main

jobs:
  a11y-check:
    if: |
      github.event.pull_request.draft == false &&
      contains(github.event.pull_request.labels.*.name, 'engineering')
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 18

      - name: Install dependencies
        run: npm install axe-core puppeteer

      - name: Extract Test URLs from PR body
        id: extract-urls
        run: |
          echo "BEFORE_URL=$(echo "${{ github.event.pull_request.body }}" | grep -oP '(?<=\| \*\*Before\*\*  \|).*' | xargs)" >> $GITHUB_ENV
          echo "AFTER_URL=$(echo "${{ github.event.pull_request.body }}" | grep -oP '(?<=\| \*\*After\*\*   \|).*' | xargs)" >> $GITHUB_ENV

      - name: Run axe-core on URLs
        id: run-a11y
        run: |
          node <<'EOF'
          const puppeteer = require('puppeteer');
          const { AxePuppeteer } = require('axe-core/puppeteer');
          const fs = require('fs');

          const urls = [process.env.BEFORE_URL, process.env.AFTER_URL].filter(Boolean);

          (async () => {
            const browser = await puppeteer.launch({ headless: true, args: ['--no-sandbox'] });
            let results = [];

            for (const url of urls) {
              const page = await browser.newPage();
              await page.goto(url, { waitUntil: 'networkidle2' });
              const axe = new AxePuppeteer(page);
              const result = await axe.analyze();

              results.push({ url, violations: result.violations });
            }

            await browser.close();

            // Group by WCAG level
            const grouped = results.map(r => ({
              url: r.url,
              A: r.violations.filter(v => v.tags.includes('wcag2a')),
              AA: r.violations.filter(v => v.tags.includes('wcag2aa')),
              AAA: r.violations.filter(v => v.tags.includes('wcag2aaa')),
            }));

            // Build Markdown report
            let md = `## ‚ôø Accessibility Report\n\n`;
            grouped.forEach(r => {
              md += `### üîó [${r.url}](${r.url})\n`;

              if (r.A.length === 0 && r.AA.length === 0 && r.AAA.length === 0) {
                md += `‚úÖ No violations found.\n\n`;
              } else {
                if (r.A.length > 0) {
                  md += `**‚ùå Level A Violations:**\n`;
                  r.A.forEach(v => {
                    md += `- ${v.help} ([link](${v.helpUrl}))\n`;
                  });
                  md += `\n`;
                }
                if (r.AA.length > 0) {
                  md += `**‚ö†Ô∏è Level AA Violations:**\n`;
                  r.AA.forEach(v => {
                    md += `- ${v.help} ([link](${v.helpUrl}))\n`;
                  });
                  md += `\n`;
                }
                if (r.AAA.length > 0) {
                  md += `**‚ÑπÔ∏è Level AAA Violations:**\n`;
                  r.AAA.forEach(v => {
                    md += `- ${v.help} ([link](${v.helpUrl}))\n`;
                  });
                  md += `\n`;
                }
              }
            });

            fs.writeFileSync('a11y-report.md', md);

            // Fail if Level A violations exist
            const hasA = grouped.some(r => r.A.length > 0);
            if (hasA) {
              console.error('‚ùå Accessibility check failed: Level A violations found.');
              process.exit(1);
            }
          })();
          EOF

      - name: Upload results as artifact
        uses: actions/upload-artifact@v3
        with:
          name: a11y-report
          path: a11y-report.md

      - name: Comment results on PR
        uses: marocchino/sticky-pull-request-comment@v2
        with:
          path: a11y-report.md
