name: Ready for Review Label Management

on:
  pull_request:
    types: [opened, ready_for_review, converted_to_draft, reopened]

jobs:
  manage-labels:
    name: Manage Ready for Review Labels
    runs-on: ubuntu-latest
    steps:
      - name: Manage Ready for Review labels based on PR state
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo, number } = context.issue;
            
            console.log(`Workflow triggered for PR #${number}, action: ${context.payload.action}`);
            
            // Only handle draft ‚Üî non-draft transitions
            // All manual label changes are respected and ignored

            // Get PR details with error handling
            let pr;
            try {
              pr = await github.rest.pulls.get({
                owner,
                repo,
                pull_number: number
              });
              console.log(`Successfully retrieved PR #${number} details`);
            } catch (error) {
              console.log(`‚ùå Failed to get PR details: ${error.message}`);
              if (error.status === 404) {
                console.log(`PR #${number} not found - may have been deleted`);
              } else if (error.status === 403) {
                console.log(`Insufficient permissions to access PR #${number}`);
              }
              return; // Exit gracefully
            }
            
            const currentLabels = pr.data.labels.map(label => label.name);
            const isDraft = pr.data.draft;
            const action = context.payload.action;
            
            console.log(`Current labels on PR #${number}:`, currentLabels);
            console.log(`Is draft: ${isDraft}, Action: ${action}`);
            
            // Only handle specific draft ‚Üî non-draft transitions
            if (action === 'opened') {
              // New PR opened - add Ready for Review if not draft
              if (!isDraft) {
                console.log(`New PR opened (non-draft) - adding Ready for Review label`);
                const targetLabels = [...currentLabels, 'Ready for Review'];
                await setLabels(owner, repo, number, targetLabels);
                await sendSlackNotification(pr.data);
              } else {
                console.log(`New PR opened (draft) - no Ready for Review label needed`);
              }
            } else if (action === 'ready_for_review') {
              // PR converted from draft to ready - add Ready for Review label
              console.log(`PR marked ready for review - adding Ready for Review label`);
              const targetLabels = [...currentLabels, 'Ready for Review'];
              await setLabels(owner, repo, number, targetLabels);
              await sendSlackNotification(pr.data);
            } else if (action === 'converted_to_draft') {
              // PR converted back to draft - remove Ready for Review labels
              console.log(`PR converted to draft - removing Ready for Review labels`);
              const targetLabels = currentLabels.filter(label => 
                !['Ready for Review', 'Ready for review'].includes(label)
              );
              await setLabels(owner, repo, number, targetLabels);
            } else if (action === 'reopened') {
              // PR reopened - add Ready for Review if not draft
              if (!isDraft) {
                console.log(`PR reopened (non-draft) - adding Ready for Review label`);
                const targetLabels = [...currentLabels, 'Ready for Review'];
                await setLabels(owner, repo, number, targetLabels);
                await sendSlackNotification(pr.data);
              } else {
                console.log(`PR reopened (draft) - no Ready for Review label needed`);
              }
            }
            
            // Helper function to set labels with error handling
            async function setLabels(owner, repo, number, labels) {
              try {
                await github.rest.issues.setLabels({
                  owner,
                  repo,
                  issue_number: number,
                  labels: labels
                });
                console.log(`‚úÖ Successfully set labels to: ${labels.join(', ')}`);
              } catch (error) {
                console.log(`‚ùå Failed to set labels: ${error.message}`);
                if (error.status === 404) {
                  console.log(`PR #${number} not found - may have been deleted`);
                } else if (error.status === 403) {
                  console.log(`Insufficient permissions to modify labels on PR #${number}`);
                } else if (error.status === 422) {
                  console.log(`Invalid label data provided: ${JSON.stringify(labels)}`);
                }
              }
            }
            
            // Only manages Ready for Review labels - QA labels are not touched
            
            // Helper function to escape JSON special characters
            function escapeJson(str) {
              return str
                .replace(/\\/g, '\\\\')
                .replace(/"/g, '\\"')
                .replace(/\n/g, '\\n')
                .replace(/\r/g, '\\r')
                .replace(/\t/g, '\\t');
            }
            
            // Helper function to send Slack notification
            async function sendSlackNotification(prData) {
              try {
                const title = prData.title;
                const author = prData.user.login;
                const url = prData.html_url;
                const branch = prData.head.ref;
                const baseBranch = prData.base.ref;
                
                // Extract Jira ticket if present
                let jiraTicket = null;
                const titleMatch = title.match(/(MWPW-\d+)/);
                if (titleMatch) {
                  jiraTicket = titleMatch[1];
                } else {
                  const bodyMatch = (prData.body || '').match(/(MWPW-\d+)/);
                  if (bodyMatch) {
                    jiraTicket = bodyMatch[1];
                  }
                }
                
                // Format the message
                const displayTitle = jiraTicket ? `${jiraTicket}: ${title.replace(`${jiraTicket}: `, '')}` : title;
                const jiraLink = jiraTicket ? `\nüîó <https://jira.corp.adobe.com/browse/${jiraTicket}|${jiraTicket}>` : '';
                
                const isTestMode = prData.head.ref === 'feature/pr-label-management';
                const message = {
                  text: `@here üöÄ *CODE DEPLOYED*${isTestMode ? ' [TEST_MODE]' : ''} - Ready for Review`,
                  attachments: [
                    {
                      color: isTestMode ? "#ff6b35" : "#00ff00",
                      fields: [
                        {
                          title: "üíª TARGET",
                          value: escapeJson(displayTitle),
                          short: false
                        },
                        {
                          title: "üë®‚Äçüíª HACKER",
                          value: escapeJson(author),
                          short: true
                        },
                        {
                          title: "üåê ROUTE",
                          value: escapeJson(`\`${branch}\` ‚Üí \`${baseBranch}\``),
                          short: true
                        },
                        {
                          title: "üîó ACCESS_POINT",
                          value: escapeJson(`<${url}|PR #${prData.number}>${jiraLink}`),
                          short: false
                        }
                      ],
                      footer: "Express Milo ‚Ä¢ System Online",
                      footer_icon: "https://github.com/adobecom/express-milo/raw/main/express/code/img/favicon.ico"
                    }
                  ]
                };
                
                // Send to Slack
                const webhookUrl = process.env.SLACK_WEBHOOK_URL_PR;
                if (!webhookUrl) {
                  console.log('‚ùå SLACK_WEBHOOK_URL_PR not configured');
                  return;
                }
                
                const response = await fetch(webhookUrl, {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                  },
                  body: JSON.stringify(message)
                });
                
                if (response.ok) {
                  console.log('‚úÖ Ready for Review notification sent successfully');
                } else {
                  console.log(`‚ùå Failed to send notification: ${response.status} ${response.statusText}`);
                }
              } catch (error) {
                console.log(`‚ùå Error sending notification: ${error.message}`);
              }
            }
        env:
          SLACK_WEBHOOK_URL_PR: ${{ github.event.pull_request.head.ref == 'feature/pr-label-management' && secrets.SLACK_WEBHOOK_URL_PR_TEST || secrets.SLACK_WEBHOOK_URL_PR }}
